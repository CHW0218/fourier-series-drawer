[{"/Users/ayao/vscode/fourier-series-drawer/src/index.tsx":"1","/Users/ayao/vscode/fourier-series-drawer/src/theme.ts":"2","/Users/ayao/vscode/fourier-series-drawer/src/App.tsx":"3","/Users/ayao/vscode/fourier-series-drawer/src/components/Canvas.tsx":"4","/Users/ayao/vscode/fourier-series-drawer/src/components/Menu.tsx":"5","/Users/ayao/vscode/fourier-series-drawer/src/components/DrawerMenu.tsx":"6","/Users/ayao/vscode/fourier-series-drawer/src/computations/index.ts":"7","/Users/ayao/vscode/fourier-series-drawer/src/components/ColorModeSwitcher.tsx":"8","/Users/ayao/vscode/fourier-series-drawer/src/computations/integral.ts":"9"},{"size":465,"mtime":1655744649577,"results":"10","hashOfConfig":"11"},{"size":407,"mtime":1655747598784,"results":"12","hashOfConfig":"11"},{"size":1501,"mtime":1655744649575,"results":"13","hashOfConfig":"11"},{"size":9899,"mtime":1655744649575,"results":"14","hashOfConfig":"11"},{"size":2948,"mtime":1655747616274,"results":"15","hashOfConfig":"11"},{"size":5695,"mtime":1655746846060,"results":"16","hashOfConfig":"11"},{"size":2404,"mtime":1655744649576,"results":"17","hashOfConfig":"11"},{"size":770,"mtime":1655744649576,"results":"18","hashOfConfig":"11"},{"size":573,"mtime":1655744649576,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","suppressedMessages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"14vcyn",{"filePath":"23","messages":"24","suppressedMessages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","suppressedMessages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32"},{"filePath":"33","messages":"34","suppressedMessages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","suppressedMessages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","suppressedMessages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","suppressedMessages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","suppressedMessages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/ayao/vscode/fourier-series-drawer/src/index.tsx",[],[],"/Users/ayao/vscode/fourier-series-drawer/src/theme.ts",[],[],"/Users/ayao/vscode/fourier-series-drawer/src/App.tsx",[],[],"/Users/ayao/vscode/fourier-series-drawer/src/components/Canvas.tsx",["48"],[],"import { FC, useEffect, useState } from 'react'\nimport Sketch from 'react-p5'\nimport P5 from 'p5'\nimport { computeFourierSeries, functionFromPoints } from '../computations'\nimport { add, Complex } from 'mathjs'\nimport _ from 'lodash'\nimport { useColorModeValue } from '@chakra-ui/react'\n\ntype CanvasProps = { \n    n: number,\n    mode: string, \n    setMode: (m: string) => void,\n    lineColor: string,\n    drawCircles: boolean,\n    drawerIsOpen: boolean,\n    showUserInput: boolean\n}\n\ntype FourierCoefficients = (t: number) => Complex[]\n\nconst Canvas: FC<CanvasProps> = props => {\n\n    const step = 0.001\n    const colorMode = useColorModeValue('light', 'dark')\n    const colors = {\n        userLine: {\n            light: '#101010',\n            dark: '#efefef'\n        },\n        fourierLine: {\n            light: '#ee5c5c',\n            dark: '#aa5151'\n        },\n        vectorRadius: {\n            light: '#5a5a5a',\n            dark: '#b2b2b2'\n        },\n        vectorCircle: {\n            light: '#c9c9c9',\n            dark: '#484848'\n        }\n    }\n\n    const [p5, setP5] = useState<P5>()\n    const [n, setN] = useState<number>(props.n)\n    const [t, setT] = useState<number>(0)\n    const [points, setPoints] = useState<Array<[number, number]>>([])\n    const [fourierCoefficients, setFourierCoefficients] = useState <FourierCoefficients>(() => () => [])\n    const [fourierComputedPoints, setFourierComputedPoints] = useState<Array<[number, number]>>([])\n    const [addToFourierComputedPoints, setAddToFourierComputedPoints] = useState<boolean>(true)\n\n    /**\n     * Setup P5 Sketch \n     * @param p5 \n     * @param parentRef \n     */\n    const setup = (p5: P5, parentRef: Element ) => {\n        setP5(p5)\n        p5.createCanvas(window.innerWidth, window.innerHeight).parent(parentRef);\n        p5.frameRate(60)\n    }\n\n    /**\n     * Draw function for P5 sketch, updates on an infinite loop\n     * @param p5 \n     */\n    const draw = (p5: P5) => {\n        switch (props.mode) {\n            /* \n            Input mode: allow user to draw using cursor\n            */\n            case 'input': {\n                if (!props.drawerIsOpen) {\n                    // p5.stroke(colors.userLine[colorMode])\n\n                    // add the cursor's coordinates to the set of points and draw the line\n                    if (p5.mouseIsPressed === true && (p5.mouseX > 220 || p5.mouseY > 34)) {\n                        // <points> is the array of coordinate pairs centred about (0,0)\n                        // so the cursor's position needs to be offset and reflected across the x-axis in order for the\n                        // first quadrant to be located in the top right (on the P5 canvas, it's the bottom right)\n                        setPoints(addToPoints([p5.mouseX - window.innerWidth / 2, -p5.mouseY + window.innerHeight / 2]))\n                        // p5.line(p5.mouseX, p5.mouseY, p5.pmouseX, p5.pmouseY);\n                        plotPoints(p5, points, colors.userLine[colorMode])\n                    }\n                }\n                break\n            }\n\n            /*\n            Animate mode: perform computations, drawing, and frame rendering\n            */\n            case 'animate': {\n                // clear the canvas\n                p5.clear()\n                // plot user-inputted line\n                if (props.showUserInput) {\n                    plotPoints(p5, points, colors.userLine[colorMode])\n                }\n\n                // get fourier coefficients for the current <t>            \n                let fourier_t = fourierCoefficients(t)\n\n                // add to the line generated by the fourier series if it has not yet been fully created\n                // the line being drawn out by the tip of the vectors is the sum of all the vectors\n                if (addToFourierComputedPoints) {\n                    const endpoint = fourier_t.reduce((a, b) => add(a, b))\n                    setFourierComputedPoints((fourierComputedPoints: Array<[number, number]>) => [...fourierComputedPoints, [endpoint.re, endpoint.im]])\n                }\n\n                // plot the line generate so far by the fourier series\n                plotPoints(p5, fourierComputedPoints.slice(1), colors.fourierLine[colorMode])\n\n                /*\n                Render lines for each vector in the Fourier series\n                */\n                // set starting point to 0, 0\n                let [lx1, ly1] = [0, 0]\n\n                // iterate <i> such that its absolute value descends by one every other index from n // 2 to 0\n                // while oscillating between negative and positive\n                // e.g.: for n=7: [-3, 3, -2, 2, -1, 1, 0]\n                for (const i of _.range(1, n + 1).map(m => Math.pow(-1, m) * Math.floor(m / 2))) {\n                    // get the value in the Fourier series at index <i>\n                    // const vector = fourier_t[i < 0 ? fourier_t.length + i : i]\n                    const vector = fourier_t.at(i) as Complex\n\n                    // set the endpoint of the vector\n                    let lx2 = vector.re + lx1\n                    let ly2 = vector.im + ly1\n\n                    // draw the singular vector\n                    p5.stroke(colors.vectorRadius[colorMode])\n                    p5.line(...centreCoords(lx2, ly2), ...centreCoords(lx1, ly1))\n\n                    if (props.drawCircles) {\n                        p5.noFill()\n                        p5.stroke(colors.vectorCircle[colorMode])\n                        const r = Math.round(Math.hypot(lx2 - lx1, ly2 - ly1))\n                        p5.circle(...centreCoords(lx1, ly1), 2 * r)\n                    }\n\n                    lx1 = lx2\n                    ly1 = ly2\n                }\n\n                // stop adding redundant points if all points have been computed\n                setAddToFourierComputedPoints(fourierComputedPoints.length > (1 / step) + 1 ? false : true)\n\n                // increment the value of t, 0 ≤ t ≤ 1 and rollover to 0 when it reaches 1\n                if (t >= 1) {\n                    setT(0)\n                } else {\n                    setT(t + step)\n                }\n                break\n            }\n        }\n    }\n\n    /**\n     * Adjusts a coordinate pair centred about (0,0) to be centred about the centre of the canvas\n     * @param x number\n     * @param y number\n     * @returns [number, number] tuple of numbers with values adjusted to display on canvas\n     */\n    const centreCoords = (x: number, y: number): [number, number] => {\n        return [x + window.innerWidth / 2, -y + window.innerHeight / 2] as [number, number]\n    }\n\n    /**\n     * Appends <p> to <points> because an anonymous function doesn't seem to work\n     * @param p [number, number] coordinate pair\n     * @returns [number, number][] original array with <p> appended\n     */\n    const addToPoints = (p: [number, number]) => {\n        return [...points, p]\n    }\n    \n    /**\n     * Update Sketch dimensions on windowResize event \n     * @param p5 \n     */\n    const windowResized = (p5: P5) => {\n        p5.resizeCanvas(window.innerWidth, window.innerHeight);\n\n        // render the line because canvas gets cleared on resize\n        plotPoints(p5, points, colors.userLine[colorMode])\n    }\n\n    /**\n     * Plot a line of color <lineColor> in order of the coordinate pairs provided in <points>\n     * @param p5 \n     * @param points [number, number][] array of coordinate pairs\n     * @param lineColor string of the line color\n     */\n    const plotPoints = (p5: P5, points: Array<[number, number]>, lineColor: string) => {\n        p5.stroke(lineColor)\n        p5.strokeWeight(1)\n        for (let i = 1; i < points.length; i++) {\n            const [x1, y1] = centreCoords(points[i - 1][0], points[i - 1][1])\n            const [x2, y2] = centreCoords(points[i][0], points[i][1])\n            p5.line(x1, y1, x2, y2)\n        }\n    }\n\n\n    useEffect(() => {\n\n        switch (props.mode) {\n            case 'input': {\n                if (p5) {\n                    plotPoints(p5, points, colors.userLine[colorMode])\n                }\n                break\n            }\n\n            /* Get Fourier series function when animation button pressed */\n            case 'processing': {\n                if (points.length > 0) {\n                    const f = computeFourierSeries(\n                        n,\n                        functionFromPoints(points.reverse())\n                    )\n                    setFourierCoefficients(() => (t: number) => f(t))\n                    props.setMode('animate')\n                } else {\n                    // revert back to input if no points have been inputted\n                    props.setMode('input')\n                }\n                break\n            }\n\n            /* Reset all parameters to default and clear the canvas */\n            case 'reset': {\n                setT(0)\n                setPoints([])\n                setFourierComputedPoints([])\n                setAddToFourierComputedPoints(true)\n                setFourierCoefficients(() => () => [])\n                props.setMode('input')\n\n                if (p5) {\n                    p5.clear()\n                }\n                break\n            }\n\n        }\n\n        if (props.n !== n) {\n            if (props.mode === 'animate') {\n                const f = computeFourierSeries(\n                    props.n,\n                    functionFromPoints(points)\n                )\n                setFourierCoefficients(() => (t: number) => f(t))\n                setFourierComputedPoints([])\n                setAddToFourierComputedPoints(true)\n            }\n            setN(props.n)\n        }\n    }, [\n        fourierCoefficients,\n        props,\n        points,\n        fourierComputedPoints,\n        n,\n        p5,\n        colorMode\n    ])\n  \n\n    return <Sketch setup={setup} draw={draw} windowResized={windowResized} />\n}\n\nexport default Canvas","/Users/ayao/vscode/fourier-series-drawer/src/components/Menu.tsx",[],[],"/Users/ayao/vscode/fourier-series-drawer/src/components/DrawerMenu.tsx",[],[],"/Users/ayao/vscode/fourier-series-drawer/src/computations/index.ts",[],[],"/Users/ayao/vscode/fourier-series-drawer/src/components/ColorModeSwitcher.tsx",[],[],"/Users/ayao/vscode/fourier-series-drawer/src/computations/integral.ts",[],[],{"ruleId":"49","severity":1,"message":"50","line":262,"column":8,"nodeType":"51","endLine":270,"endColumn":6,"suggestions":"52"},"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'colors.userLine' and 'plotPoints'. Either include them or remove the dependency array.","ArrayExpression",["53"],{"desc":"54","fix":"55"},"Update the dependencies array to be: [fourierCoefficients, props, points, fourierComputedPoints, n, p5, colorMode, plotPoints, colors.userLine]",{"range":"56","text":"57"},[9648,9787],"[fourierCoefficients, props, points, fourierComputedPoints, n, p5, colorMode, plotPoints, colors.userLine]"]