{"ast":null,"code":"import { isConstantNode, isParenthesisNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { createUtil } from './simplify/util.js';\nimport { createSimplifyConstant } from './simplify/simplifyConstant.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { createEmptyMap, createMap } from '../../utils/map.js';\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', 'resolve', 'simplifyCore', '?fraction', '?bignumber', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplify = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var config = _ref.config,\n      typed = _ref.typed,\n      parse = _ref.parse,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      isZero = _ref.isZero,\n      equal = _ref.equal,\n      resolve = _ref.resolve,\n      simplifyCore = _ref.simplifyCore,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      mathWithTransform = _ref.mathWithTransform,\n      matrix = _ref.matrix,\n      AccessorNode = _ref.AccessorNode,\n      ArrayNode = _ref.ArrayNode,\n      ConstantNode = _ref.ConstantNode,\n      FunctionNode = _ref.FunctionNode,\n      IndexNode = _ref.IndexNode,\n      ObjectNode = _ref.ObjectNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      SymbolNode = _ref.SymbolNode;\n  var simplifyConstant = createSimplifyConstant({\n    typed: typed,\n    config: config,\n    mathWithTransform: mathWithTransform,\n    matrix: matrix,\n    fraction: fraction,\n    bignumber: bignumber,\n    AccessorNode: AccessorNode,\n    ArrayNode: ArrayNode,\n    ConstantNode: ConstantNode,\n    FunctionNode: FunctionNode,\n    IndexNode: IndexNode,\n    ObjectNode: ObjectNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  });\n\n  var _createUtil = createUtil({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      hasProperty = _createUtil.hasProperty,\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      mergeContext = _createUtil.mergeContext,\n      flatten = _createUtil.flatten,\n      unflattenr = _createUtil.unflattenr,\n      unflattenl = _createUtil.unflattenl,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction,\n      defaultContext = _createUtil.defaultContext,\n      realContext = _createUtil.realContext,\n      positiveContext = _createUtil.positiveContext;\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules.\n   *\n   * To specify a rule as a string, separate the left and right pattern by '->'\n   * When specifying a rule as an object, the following keys are meaningful:\n   * - l - the left pattern\n   * - r - the right pattern\n   * - s - in lieu of l and r, the string form that is broken at -> to give them\n   * - repeat - whether to repeat this rule until the expression stabilizes\n   * - assuming - gives a context object, as in the 'context' option to\n   *     simplify. Every property in the context object must match the current\n   *     context in order, or else the rule will not be applied.\n   * - imposeContext - gives a context object, as in the 'context' option to\n   *     simplify. Any settings specified will override the incoming context\n   *     for all matches of this rule.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  Currently available options (defaults in parentheses):\n   *  - `consoleDebug` (false): whether to write the expression being simplified\n   *    and any changes to it, along with the rule responsible, to console\n   *  - `context` (simplify.defaultContext): an object giving properties of\n   *    each operator, which determine what simplifications are allowed. The\n   *    currently meaningful properties are commutative, associative,\n   *    total (whether the operation is defined for all arguments), and\n   *    trivial (whether the operation applied to a single argument leaves\n   *    that argument unchanged). The default context is very permissive and\n   *    allows almost all simplifications. Only properties differing from\n   *    the default need to be specified; the default context is used as a\n   *    fallback. Additional contexts `simplify.realContext` and\n   *    `simplify.positiveContext` are supplied to cause simplify to perform\n   *    just simplifications guaranteed to preserve all values of the expression\n   *    assuming all variables and subexpressions are real numbers or\n   *    positive real numbers, respectively. (Note that these are in some cases\n   *    more restrictive than the default context; for example, the default\n   *    context will allow `x/x` to simplify to 1, whereas\n   *    `simplify.realContext` will not, as `0/0` is not equal to 1.)\n   *  - `exactFractions` (true): whether to try to convert all constants to\n   *    exact rational numbers.\n   *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will\n   *    be expressed as fractions only when both numerator and denominator\n   *    are smaller than `fractionsLimit`.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     simplifyCore, derivative, evaluate, parse, rationalize, resolve\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\n   *            Optional list with custom rules\n   * @return {Node} Returns the simplified form of `expr`\n   */\n\n\n  var simplify = typed('simplify', {\n    string: function string(expr) {\n      return this(parse(expr), this.rules, createEmptyMap(), {});\n    },\n    'string, Map | Object': function stringMapObject(expr, scope) {\n      return this(parse(expr), this.rules, scope, {});\n    },\n    'string, Map | Object, Object': function stringMapObjectObject(expr, scope, options) {\n      return this(parse(expr), this.rules, scope, options);\n    },\n    'string, Array': function stringArray(expr, rules) {\n      return this(parse(expr), rules, createEmptyMap(), {});\n    },\n    'string, Array, Map | Object': function stringArrayMapObject(expr, rules, scope) {\n      return this(parse(expr), rules, scope, {});\n    },\n    'string, Array, Map | Object, Object': function stringArrayMapObjectObject(expr, rules, scope, options) {\n      return this(parse(expr), rules, scope, options);\n    },\n    'Node, Map | Object': function NodeMapObject(expr, scope) {\n      return this(expr, this.rules, scope, {});\n    },\n    'Node, Map | Object, Object': function NodeMapObjectObject(expr, scope, options) {\n      return this(expr, this.rules, scope, options);\n    },\n    Node: function Node(expr) {\n      return this(expr, this.rules, createEmptyMap(), {});\n    },\n    'Node, Array': function NodeArray(expr, rules) {\n      return this(expr, rules, createEmptyMap(), {});\n    },\n    'Node, Array, Map | Object': function NodeArrayMapObject(expr, rules, scope) {\n      return this(expr, rules, scope, {});\n    },\n    'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {\n      return this(expr, rules, createMap(scope), options);\n    },\n    'Node, Array, Map, Object': function NodeArrayMapObject(expr, rules, scope, options) {\n      var debug = options.consoleDebug;\n      rules = _buildRules(rules, options.context);\n      var res = resolve(expr, scope);\n      res = removeParens(res);\n      var visited = {};\n      var str = res.toString({\n        parenthesis: 'all'\n      });\n\n      while (!visited[str]) {\n        visited[str] = true;\n        _lastsym = 0; // counter for placeholder symbols\n\n        var laststr = str;\n        if (debug) console.log('Working on: ', str);\n\n        for (var i = 0; i < rules.length; i++) {\n          var rulestr = '';\n\n          if (typeof rules[i] === 'function') {\n            res = rules[i](res, options);\n            if (debug) rulestr = rules[i].name;\n          } else {\n            flatten(res, options.context);\n            res = applyRule(res, rules[i], options.context);\n\n            if (debug) {\n              rulestr = \"\".concat(rules[i].l.toString(), \" -> \").concat(rules[i].r.toString());\n            }\n          }\n\n          if (debug) {\n            var newstr = res.toString({\n              parenthesis: 'all'\n            });\n\n            if (newstr !== laststr) {\n              console.log('Applying', rulestr, 'produced', newstr);\n              laststr = newstr;\n            }\n          }\n          /* Use left-heavy binary tree internally,\n           * since custom rule functions may expect it\n           */\n\n\n          unflattenl(res, options.context);\n        }\n\n        str = res.toString({\n          parenthesis: 'all'\n        });\n      }\n\n      return res;\n    }\n  });\n  simplify.defaultContext = defaultContext;\n  simplify.realContext = realContext;\n  simplify.positiveContext = positiveContext;\n\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return isParenthesisNode(node) ? removeParens(node.content) : node;\n    });\n  } // All constants that are allowed in rules\n\n\n  var SUPPORTED_CONSTANTS = {\n    true: true,\n    false: true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true // null: false,\n    // undefined: false,\n    // version: false,\n\n  }; // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n\n  simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  }, // temporary rules\n  // Note initially we tend constants to the right because like-term\n  // collection prefers the left, and we would rather collect nonconstants\n  {\n    s: 'n-n1 -> n+-n1',\n    // temporarily replace 'subtract' so we can further flatten the 'add' operator\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n-n -> 0',\n    // partial alternative when we can't always subtract\n    assuming: {\n      subtract: {\n        total: false\n      }\n    }\n  }, {\n    s: '-(c*v) -> v * (-c)',\n    // make non-constant terms positive\n    assuming: {\n      multiply: {\n        commutative: true\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(c*v) -> (-c) * v',\n    // non-commutative version, part 1\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(v*c) -> v * (-c)',\n    // non-commutative version, part 2\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    l: '-(n1/n2)',\n    r: '-n1/n2'\n  }, {\n    l: '-v',\n    r: 'v * (-1)'\n  }, // finish making non-constant terms positive\n  {\n    l: '(n1 + n2)*(-1)',\n    r: 'n1*(-1) + n2*(-1)',\n    repeat: true\n  }, // expand negations to achieve as much sign cancellation as possible\n  {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, {\n    s: '(n1*n2)^n3 -> n1^n3 * n2^n3',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: '(n1*n2)^(-1) -> n2^(-1) * n1^(-1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // expand nested exponentiation\n  {\n    s: '(n ^ n1) ^ n2 -> n ^ (n1 * n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // 1/(1/n) = n needs 1/n to exist\n\n  }, // collect like factors; into a sum, only do this for nonconstants\n  {\n    l: ' v   * ( v   * n1 + n2)',\n    r: 'v^2       * n1 +  v   * n2'\n  }, {\n    s: ' v   * (v^n4 * n1 + n2)   ->  v^(1+n4)  * n1 +  v   * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // v*1/v = v^(1+-1) needs 1/v\n\n  }, {\n    s: 'v^n3 * ( v   * n1 + n2)   ->  v^(n3+1)  * n1 + v^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    s: 'v^n3 * (v^n4 * n1 + n2)   ->  v^(n3+n4) * n1 + v^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    s: 'n * n^n1 -> n^(n1+1)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // n*1/n = n^(-1+1) needs 1/n\n\n  }, {\n    s: 'n^n1 * n^n2 -> n^(n1+n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // ditto for n^2*1/n^2\n\n  }, // Unfortunately, to deal with more complicated cancellations, it\n  // becomes necessary to simplify constants twice per pass. It's not\n  // terribly expensive compared to matching rules, so this should not\n  // pose a performance problem.\n  simplifyConstant, // First: before collecting like terms\n  // collect like terms\n  {\n    s: 'n+n -> 2*n',\n    assuming: {\n      add: {\n        total: true\n      }\n    } // 2 = 1 + 1 needs to exist\n\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'v*n + v',\n    r: 'v*(n+1)'\n  }, // NOTE: leftmost position is special:\n  {\n    l: 'n3*n1 + n3*n2',\n    r: 'n3*(n1+n2)'\n  }, // All sub-monomials tried there.\n  {\n    l: 'n3^(-n4)*n1 +   n3  * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+1) *n2)'\n  }, {\n    l: 'n3^(-n4)*n1 + n3^n5 * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+n5)*n2)'\n  }, {\n    s: 'n*v + v -> (n+1)*v',\n    // noncommutative additional cases\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3 + n2*n3 -> (n1+n2)*n3',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'n*c + c',\n    r: '(n+1)*c'\n  }, {\n    s: 'c*n + c -> c*(n+1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, simplifyConstant, // Second: before returning expressions to \"standard form\"\n  // make factors positive (and undo 'make non-constant terms positive')\n  {\n    s: '(-n)*n1 -> -(n*n1)',\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n1*(-n) -> -(n1*n)',\n    // in case * non-commutative\n    assuming: {\n      subtract: {\n        total: true\n      },\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // final ordering of constants\n  {\n    s: 'c+v -> v+c',\n    assuming: {\n      add: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'v*c -> c*v',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  }, // undo replace 'subtract'\n  {\n    s: 'n*(n1^-1) -> n/n1',\n    // undo replace 'divide'; for * commutative\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n\n  }, {\n    s: 'n*n1^-n2 -> n/n1^n2',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n\n  }, {\n    s: 'n^-1 -> 1/n',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n\n  }, {\n    l: 'n^1',\n    r: 'n'\n  }, // can be produced by power cancellation\n  {\n    s: 'n*(n1/n2) -> (n*n1)/n2',\n    // '*' before '/'\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    s: 'n-(n1+n2) -> n-n1-n2',\n    // '-' before '+'\n    assuming: {\n      addition: {\n        associative: true,\n        commutative: true\n      }\n    }\n  }, // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n  // simplifyConstant can leave an extra factor of 1, which can always\n  // be eliminated, since the identity always commutes\n  {\n    l: '1*n',\n    r: 'n',\n    imposeContext: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: 'n1/(n2/n3) -> (n1*n3)/n2',\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    l: 'n1/(-n2)',\n    r: '-n1/n2'\n  }];\n  /**\n   * Takes any rule object as allowed by the specification in simplify\n   * and puts it in a standard form used by applyRule\n   */\n\n  function _canonicalizeRule(ruleObject, context) {\n    var newRule = {};\n\n    if (ruleObject.s) {\n      var lr = ruleObject.s.split('->');\n\n      if (lr.length === 2) {\n        newRule.l = lr[0];\n        newRule.r = lr[1];\n      } else {\n        throw SyntaxError('Could not parse rule: ' + ruleObject.s);\n      }\n    } else {\n      newRule.l = ruleObject.l;\n      newRule.r = ruleObject.r;\n    }\n\n    newRule.l = removeParens(parse(newRule.l));\n    newRule.r = removeParens(parse(newRule.r));\n\n    for (var _i3 = 0, _arr = ['imposeContext', 'repeat', 'assuming']; _i3 < _arr.length; _i3++) {\n      var prop = _arr[_i3];\n\n      if (prop in ruleObject) {\n        newRule[prop] = ruleObject[prop];\n      }\n    }\n\n    if (ruleObject.evaluate) {\n      newRule.evaluate = parse(ruleObject.evaluate);\n    }\n\n    if (isAssociative(newRule.l, context)) {\n      var makeNode = createMakeNodeFunction(newRule.l);\n\n      var expandsym = _getExpandPlaceholderSymbol();\n\n      newRule.expanded = {};\n      newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.\n      // This helps to match the newRule against nodes returned from getSplits() later on.\n\n      flatten(newRule.expanded.l, context);\n      unflattenr(newRule.expanded.l, context);\n      newRule.expanded.r = makeNode([newRule.r, expandsym]);\n    }\n\n    return newRule;\n  }\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n\n\n  function _buildRules(rules, context) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n      var ruleType = typeof rule;\n\n      switch (ruleType) {\n        case 'string':\n          rule = {\n            s: rule\n          };\n\n        /* falls through */\n\n        case 'object':\n          newRule = _canonicalizeRule(rule, context);\n          break;\n\n        case 'function':\n          newRule = rule;\n          break;\n\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      } // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n\n\n      ruleSet.push(newRule);\n    }\n\n    return ruleSet;\n  }\n\n  var _lastsym = 0;\n\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n\n  function mapRule(nodes, rule, context) {\n    var resNodes = nodes;\n\n    if (nodes) {\n      for (var i = 0; i < nodes.length; ++i) {\n        var newNode = applyRule(nodes[i], rule, context);\n\n        if (newNode !== nodes[i]) {\n          if (resNodes === nodes) {\n            resNodes = nodes.slice();\n          }\n\n          resNodes[i] = newNode;\n        }\n      }\n    }\n\n    return resNodes;\n  }\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {Object | Function} rule\n   * @param  {Object} context -- information about assumed properties of operators\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n\n\n  function applyRule(node, rule, context) {\n    //    console.log('Entering applyRule(\"', rule.l.toString({parenthesis:'all'}), '->', rule.r.toString({parenthesis:'all'}), '\",', node.toString({parenthesis:'all'}),')')\n    // check that the assumptions for this rule are satisfied by the current\n    // context:\n    if (rule.assuming) {\n      for (var symbol in rule.assuming) {\n        for (var property in rule.assuming[symbol]) {\n          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {\n            return node;\n          }\n        }\n      }\n    }\n\n    var mergedContext = mergeContext(rule.imposeContext, context); // Do not clone node unless we find a match\n\n    var res = node; // First replace our child nodes with their simplified versions\n    // If a child could not be simplified, applying the rule to it\n    // will have no effect since the node is returned unchanged\n\n    if (res instanceof OperatorNode || res instanceof FunctionNode) {\n      var newArgs = mapRule(res.args, rule, context);\n\n      if (newArgs !== res.args) {\n        res = res.clone();\n        res.args = newArgs;\n      }\n    } else if (res instanceof ParenthesisNode) {\n      if (res.content) {\n        var newContent = applyRule(res.content, rule, context);\n\n        if (newContent !== res.content) {\n          res = new ParenthesisNode(newContent);\n        }\n      }\n    } else if (res instanceof ArrayNode) {\n      var newItems = mapRule(res.items, rule, context);\n\n      if (newItems !== res.items) {\n        res = new ArrayNode(newItems);\n      }\n    } else if (res instanceof AccessorNode) {\n      var newObj = res.object;\n\n      if (res.object) {\n        newObj = applyRule(res.object, rule, context);\n      }\n\n      var newIndex = res.index;\n\n      if (res.index) {\n        newIndex = applyRule(res.index, rule, context);\n      }\n\n      if (newObj !== res.object || newIndex !== res.index) {\n        res = new AccessorNode(newObj, newIndex);\n      }\n    } else if (res instanceof IndexNode) {\n      var newDims = mapRule(res.dimensions, rule, context);\n\n      if (newDims !== res.dimensions) {\n        res = new IndexNode(newDims);\n      }\n    } else if (res instanceof ObjectNode) {\n      var changed = false;\n      var newProps = {};\n\n      for (var prop in res.properties) {\n        newProps[prop] = applyRule(res.properties[prop], rule, context);\n\n        if (newProps[prop] !== res.properties[prop]) {\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        res = new ObjectNode(newProps);\n      }\n    } // Try to match a rule against this node\n\n\n    var repl = rule.r;\n\n    var matches = _ruleMatch(rule.l, res, mergedContext)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\n    // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n\n\n    if (!matches && rule.expanded) {\n      repl = rule.expanded.r;\n      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];\n    }\n\n    if (matches) {\n      // const before = res.toString({parenthesis: 'all'})\n      // Create a new node by cloning the rhs of the matched rule\n      // we keep any implicit multiplication state if relevant\n      var implicit = res.implicit;\n      res = repl.clone();\n\n      if (implicit && 'implicit' in repl) {\n        res.implicit = true;\n      } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n\n\n      res = res.transform(function (node) {\n        if (node.isSymbolNode && hasOwnProperty(matches.placeholders, node.name)) {\n          return matches.placeholders[node.name].clone();\n        } else {\n          return node;\n        }\n      }); // const after = res.toString({parenthesis: 'all'})\n      // console.log('Simplified ' + before + ' to ' + after)\n    }\n\n    if (rule.repeat && res !== node) {\n      res = applyRule(res, rule, context);\n    }\n\n    return res;\n  }\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n\n\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      // Keep order, but try all parenthesizations\n      for (var _i = 1; _i < node.args.length; _i++) {\n        var left = node.args[0];\n\n        if (_i > 1) {\n          left = makeNode(node.args.slice(0, _i));\n        }\n\n        rightArgs = node.args.slice(_i);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([left, right]));\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n\n\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    }; // Some matches may not have placeholders; this is OK\n\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    } // Placeholders with the same key must match exactly\n\n\n    for (var key in match1.placeholders) {\n      if (hasOwnProperty(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n\n        if (hasOwnProperty(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n\n    for (var _key in match2.placeholders) {\n      if (hasOwnProperty(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n\n\n  function combineChildMatches(list1, list2) {\n    var res = [];\n\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n\n    var merged;\n\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n\n\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n\n    return uniqueSets;\n  }\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param {Object} context -- provides assumed properties of operators\n   * @param {Boolean} isSplit -- whether we are in process of splitting an\n   *                    n-ary operator node into possible binary combinations.\n   *                    Defaults to false.\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _ruleMatch(rule, node, context, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n    //    console.log('Entering _ruleMatch(', rule.toString({parenthesis:'all'}), ', ', node.toString({parenthesis:'all'}), ', ', context, ')')\n    var res = [{\n      placeholders: {}\n    }];\n\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } // rule and node match. Search the children of rule and node.\n\n\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly,\n        // except in any order if operator is commutative\n        var childMatches = [];\n\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i], context);\n\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            break;\n          } // The child matched, so add the information returned from the child to our result\n\n\n          childMatches.push(childMatch);\n        }\n\n        if (childMatches.length !== rule.args.length) {\n          if (!isCommutative(node, context) || // exact match in order needed\n          rule.args.length === 1) {\n            // nothing to commute\n            return [];\n          }\n\n          if (rule.args.length > 2) {\n            /* Need to generate all permutations and try them.\n             * It's a bit complicated, and unlikely to come up since there\n             * are very few ternary or higher operators. So punt for now.\n             */\n            throw new Error('permuting >2 commutative non-associative rule arguments not yet implemented');\n          }\n          /* Exactly two arguments, try them reversed */\n\n\n          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);\n\n          if (leftMatch.length === 0) {\n            return [];\n          }\n\n          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);\n\n          if (rightMatch.length === 0) {\n            return [];\n          }\n\n          childMatches = [leftMatch, rightMatch];\n        }\n\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, context);\n        var splitMatches = [];\n\n        for (var _i2 = 0; _i2 < splits.length; _i2++) {\n          var matchSet = _ruleMatch(rule, splits[_i2], context, true); // recursing at the same tree depth here\n\n\n          splitMatches = splitMatches.concat(matchSet);\n        }\n\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!isConstantNode(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    } // It's a match!\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n\n\n    return res;\n  }\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  return simplify;\n});","map":{"version":3,"names":["isConstantNode","isParenthesisNode","factory","createUtil","createSimplifyConstant","hasOwnProperty","createEmptyMap","createMap","name","dependencies","createSimplify","_ref","config","typed","parse","add","subtract","multiply","divide","pow","isZero","equal","resolve","simplifyCore","fraction","bignumber","mathWithTransform","matrix","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode","simplifyConstant","hasProperty","isCommutative","isAssociative","mergeContext","flatten","unflattenr","unflattenl","createMakeNodeFunction","defaultContext","realContext","positiveContext","simplify","string","expr","rules","stringMapObject","scope","stringMapObjectObject","options","stringArray","stringArrayMapObject","stringArrayMapObjectObject","NodeMapObject","NodeMapObjectObject","Node","NodeArray","NodeArrayMapObject","NodeArrayObjectObject","debug","consoleDebug","_buildRules","context","res","removeParens","visited","str","toString","parenthesis","_lastsym","laststr","console","log","i","length","rulestr","applyRule","concat","l","r","newstr","node","transform","path","parent","content","SUPPORTED_CONSTANTS","true","false","e","Infinity","LN2","LN10","LOG2E","LOG10E","NaN","phi","pi","SQRT1_2","SQRT2","tau","s","assuming","total","commutative","repeat","imposeContext","associative","addition","_canonicalizeRule","ruleObject","newRule","lr","split","SyntaxError","prop","evaluate","makeNode","expandsym","_getExpandPlaceholderSymbol","expanded","clone","ruleSet","rule","ruleType","TypeError","push","mapRule","nodes","resNodes","newNode","slice","symbol","property","mergedContext","newArgs","args","newContent","newItems","items","newObj","object","newIndex","index","newDims","dimensions","changed","newProps","properties","repl","matches","_ruleMatch","implicit","isSymbolNode","placeholders","getSplits","right","rightArgs","splice","_i","left","mergeMatch","match1","match2","key","_exactMatch","_key","combineChildMatches","list1","list2","merged","i1","i2","mergeChildMatches","childMatches","sets","reduce","uniqueSets","unique","JSON","stringify","isSplit","op","fn","childMatch","Error","leftMatch","rightMatch","splits","splitMatches","_i2","matchSet","substring","value","p","q"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/algebra/simplify.js"],"sourcesContent":["import { isConstantNode, isParenthesisNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { createUtil } from './simplify/util.js';\nimport { createSimplifyConstant } from './simplify/simplifyConstant.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { createEmptyMap, createMap } from '../../utils/map.js';\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', 'resolve', 'simplifyCore', '?fraction', '?bignumber', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplify = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    parse,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    isZero,\n    equal,\n    resolve,\n    simplifyCore,\n    fraction,\n    bignumber,\n    mathWithTransform,\n    matrix,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  var simplifyConstant = createSimplifyConstant({\n    typed,\n    config,\n    mathWithTransform,\n    matrix,\n    fraction,\n    bignumber,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    SymbolNode\n  });\n  var {\n    hasProperty,\n    isCommutative,\n    isAssociative,\n    mergeContext,\n    flatten,\n    unflattenr,\n    unflattenl,\n    createMakeNodeFunction,\n    defaultContext,\n    realContext,\n    positiveContext\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules.\n   *\n   * To specify a rule as a string, separate the left and right pattern by '->'\n   * When specifying a rule as an object, the following keys are meaningful:\n   * - l - the left pattern\n   * - r - the right pattern\n   * - s - in lieu of l and r, the string form that is broken at -> to give them\n   * - repeat - whether to repeat this rule until the expression stabilizes\n   * - assuming - gives a context object, as in the 'context' option to\n   *     simplify. Every property in the context object must match the current\n   *     context in order, or else the rule will not be applied.\n   * - imposeContext - gives a context object, as in the 'context' option to\n   *     simplify. Any settings specified will override the incoming context\n   *     for all matches of this rule.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  Currently available options (defaults in parentheses):\n   *  - `consoleDebug` (false): whether to write the expression being simplified\n   *    and any changes to it, along with the rule responsible, to console\n   *  - `context` (simplify.defaultContext): an object giving properties of\n   *    each operator, which determine what simplifications are allowed. The\n   *    currently meaningful properties are commutative, associative,\n   *    total (whether the operation is defined for all arguments), and\n   *    trivial (whether the operation applied to a single argument leaves\n   *    that argument unchanged). The default context is very permissive and\n   *    allows almost all simplifications. Only properties differing from\n   *    the default need to be specified; the default context is used as a\n   *    fallback. Additional contexts `simplify.realContext` and\n   *    `simplify.positiveContext` are supplied to cause simplify to perform\n   *    just simplifications guaranteed to preserve all values of the expression\n   *    assuming all variables and subexpressions are real numbers or\n   *    positive real numbers, respectively. (Note that these are in some cases\n   *    more restrictive than the default context; for example, the default\n   *    context will allow `x/x` to simplify to 1, whereas\n   *    `simplify.realContext` will not, as `0/0` is not equal to 1.)\n   *  - `exactFractions` (true): whether to try to convert all constants to\n   *    exact rational numbers.\n   *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will\n   *    be expressed as fractions only when both numerator and denominator\n   *    are smaller than `fractionsLimit`.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     simplifyCore, derivative, evaluate, parse, rationalize, resolve\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\n   *            Optional list with custom rules\n   * @return {Node} Returns the simplified form of `expr`\n   */\n\n  var simplify = typed('simplify', {\n    string: function string(expr) {\n      return this(parse(expr), this.rules, createEmptyMap(), {});\n    },\n    'string, Map | Object': function stringMapObject(expr, scope) {\n      return this(parse(expr), this.rules, scope, {});\n    },\n    'string, Map | Object, Object': function stringMapObjectObject(expr, scope, options) {\n      return this(parse(expr), this.rules, scope, options);\n    },\n    'string, Array': function stringArray(expr, rules) {\n      return this(parse(expr), rules, createEmptyMap(), {});\n    },\n    'string, Array, Map | Object': function stringArrayMapObject(expr, rules, scope) {\n      return this(parse(expr), rules, scope, {});\n    },\n    'string, Array, Map | Object, Object': function stringArrayMapObjectObject(expr, rules, scope, options) {\n      return this(parse(expr), rules, scope, options);\n    },\n    'Node, Map | Object': function NodeMapObject(expr, scope) {\n      return this(expr, this.rules, scope, {});\n    },\n    'Node, Map | Object, Object': function NodeMapObjectObject(expr, scope, options) {\n      return this(expr, this.rules, scope, options);\n    },\n    Node: function Node(expr) {\n      return this(expr, this.rules, createEmptyMap(), {});\n    },\n    'Node, Array': function NodeArray(expr, rules) {\n      return this(expr, rules, createEmptyMap(), {});\n    },\n    'Node, Array, Map | Object': function NodeArrayMapObject(expr, rules, scope) {\n      return this(expr, rules, scope, {});\n    },\n    'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {\n      return this(expr, rules, createMap(scope), options);\n    },\n    'Node, Array, Map, Object': function NodeArrayMapObject(expr, rules, scope, options) {\n      var debug = options.consoleDebug;\n      rules = _buildRules(rules, options.context);\n      var res = resolve(expr, scope);\n      res = removeParens(res);\n      var visited = {};\n      var str = res.toString({\n        parenthesis: 'all'\n      });\n\n      while (!visited[str]) {\n        visited[str] = true;\n        _lastsym = 0; // counter for placeholder symbols\n\n        var laststr = str;\n        if (debug) console.log('Working on: ', str);\n\n        for (var i = 0; i < rules.length; i++) {\n          var rulestr = '';\n\n          if (typeof rules[i] === 'function') {\n            res = rules[i](res, options);\n            if (debug) rulestr = rules[i].name;\n          } else {\n            flatten(res, options.context);\n            res = applyRule(res, rules[i], options.context);\n\n            if (debug) {\n              rulestr = \"\".concat(rules[i].l.toString(), \" -> \").concat(rules[i].r.toString());\n            }\n          }\n\n          if (debug) {\n            var newstr = res.toString({\n              parenthesis: 'all'\n            });\n\n            if (newstr !== laststr) {\n              console.log('Applying', rulestr, 'produced', newstr);\n              laststr = newstr;\n            }\n          }\n          /* Use left-heavy binary tree internally,\n           * since custom rule functions may expect it\n           */\n\n\n          unflattenl(res, options.context);\n        }\n\n        str = res.toString({\n          parenthesis: 'all'\n        });\n      }\n\n      return res;\n    }\n  });\n  simplify.defaultContext = defaultContext;\n  simplify.realContext = realContext;\n  simplify.positiveContext = positiveContext;\n\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return isParenthesisNode(node) ? removeParens(node.content) : node;\n    });\n  } // All constants that are allowed in rules\n\n\n  var SUPPORTED_CONSTANTS = {\n    true: true,\n    false: true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true // null: false,\n    // undefined: false,\n    // version: false,\n\n  }; // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n\n  simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  }, // temporary rules\n  // Note initially we tend constants to the right because like-term\n  // collection prefers the left, and we would rather collect nonconstants\n  {\n    s: 'n-n1 -> n+-n1',\n    // temporarily replace 'subtract' so we can further flatten the 'add' operator\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n-n -> 0',\n    // partial alternative when we can't always subtract\n    assuming: {\n      subtract: {\n        total: false\n      }\n    }\n  }, {\n    s: '-(c*v) -> v * (-c)',\n    // make non-constant terms positive\n    assuming: {\n      multiply: {\n        commutative: true\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(c*v) -> (-c) * v',\n    // non-commutative version, part 1\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(v*c) -> v * (-c)',\n    // non-commutative version, part 2\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    l: '-(n1/n2)',\n    r: '-n1/n2'\n  }, {\n    l: '-v',\n    r: 'v * (-1)'\n  }, // finish making non-constant terms positive\n  {\n    l: '(n1 + n2)*(-1)',\n    r: 'n1*(-1) + n2*(-1)',\n    repeat: true\n  }, // expand negations to achieve as much sign cancellation as possible\n  {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, {\n    s: '(n1*n2)^n3 -> n1^n3 * n2^n3',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: '(n1*n2)^(-1) -> n2^(-1) * n1^(-1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // expand nested exponentiation\n  {\n    s: '(n ^ n1) ^ n2 -> n ^ (n1 * n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // 1/(1/n) = n needs 1/n to exist\n\n  }, // collect like factors; into a sum, only do this for nonconstants\n  {\n    l: ' v   * ( v   * n1 + n2)',\n    r: 'v^2       * n1 +  v   * n2'\n  }, {\n    s: ' v   * (v^n4 * n1 + n2)   ->  v^(1+n4)  * n1 +  v   * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // v*1/v = v^(1+-1) needs 1/v\n\n  }, {\n    s: 'v^n3 * ( v   * n1 + n2)   ->  v^(n3+1)  * n1 + v^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    s: 'v^n3 * (v^n4 * n1 + n2)   ->  v^(n3+n4) * n1 + v^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    s: 'n * n^n1 -> n^(n1+1)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // n*1/n = n^(-1+1) needs 1/n\n\n  }, {\n    s: 'n^n1 * n^n2 -> n^(n1+n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // ditto for n^2*1/n^2\n\n  }, // Unfortunately, to deal with more complicated cancellations, it\n  // becomes necessary to simplify constants twice per pass. It's not\n  // terribly expensive compared to matching rules, so this should not\n  // pose a performance problem.\n  simplifyConstant, // First: before collecting like terms\n  // collect like terms\n  {\n    s: 'n+n -> 2*n',\n    assuming: {\n      add: {\n        total: true\n      }\n    } // 2 = 1 + 1 needs to exist\n\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'v*n + v',\n    r: 'v*(n+1)'\n  }, // NOTE: leftmost position is special:\n  {\n    l: 'n3*n1 + n3*n2',\n    r: 'n3*(n1+n2)'\n  }, // All sub-monomials tried there.\n  {\n    l: 'n3^(-n4)*n1 +   n3  * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+1) *n2)'\n  }, {\n    l: 'n3^(-n4)*n1 + n3^n5 * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+n5)*n2)'\n  }, {\n    s: 'n*v + v -> (n+1)*v',\n    // noncommutative additional cases\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3 + n2*n3 -> (n1+n2)*n3',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'n*c + c',\n    r: '(n+1)*c'\n  }, {\n    s: 'c*n + c -> c*(n+1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, simplifyConstant, // Second: before returning expressions to \"standard form\"\n  // make factors positive (and undo 'make non-constant terms positive')\n  {\n    s: '(-n)*n1 -> -(n*n1)',\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n1*(-n) -> -(n1*n)',\n    // in case * non-commutative\n    assuming: {\n      subtract: {\n        total: true\n      },\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // final ordering of constants\n  {\n    s: 'c+v -> v+c',\n    assuming: {\n      add: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'v*c -> c*v',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  }, // undo replace 'subtract'\n  {\n    s: 'n*(n1^-1) -> n/n1',\n    // undo replace 'divide'; for * commutative\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n\n  }, {\n    s: 'n*n1^-n2 -> n/n1^n2',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n\n  }, {\n    s: 'n^-1 -> 1/n',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n\n  }, {\n    l: 'n^1',\n    r: 'n'\n  }, // can be produced by power cancellation\n  {\n    s: 'n*(n1/n2) -> (n*n1)/n2',\n    // '*' before '/'\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    s: 'n-(n1+n2) -> n-n1-n2',\n    // '-' before '+'\n    assuming: {\n      addition: {\n        associative: true,\n        commutative: true\n      }\n    }\n  }, // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n  // simplifyConstant can leave an extra factor of 1, which can always\n  // be eliminated, since the identity always commutes\n  {\n    l: '1*n',\n    r: 'n',\n    imposeContext: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: 'n1/(n2/n3) -> (n1*n3)/n2',\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    l: 'n1/(-n2)',\n    r: '-n1/n2'\n  }];\n  /**\n   * Takes any rule object as allowed by the specification in simplify\n   * and puts it in a standard form used by applyRule\n   */\n\n  function _canonicalizeRule(ruleObject, context) {\n    var newRule = {};\n\n    if (ruleObject.s) {\n      var lr = ruleObject.s.split('->');\n\n      if (lr.length === 2) {\n        newRule.l = lr[0];\n        newRule.r = lr[1];\n      } else {\n        throw SyntaxError('Could not parse rule: ' + ruleObject.s);\n      }\n    } else {\n      newRule.l = ruleObject.l;\n      newRule.r = ruleObject.r;\n    }\n\n    newRule.l = removeParens(parse(newRule.l));\n    newRule.r = removeParens(parse(newRule.r));\n\n    for (var prop of ['imposeContext', 'repeat', 'assuming']) {\n      if (prop in ruleObject) {\n        newRule[prop] = ruleObject[prop];\n      }\n    }\n\n    if (ruleObject.evaluate) {\n      newRule.evaluate = parse(ruleObject.evaluate);\n    }\n\n    if (isAssociative(newRule.l, context)) {\n      var makeNode = createMakeNodeFunction(newRule.l);\n\n      var expandsym = _getExpandPlaceholderSymbol();\n\n      newRule.expanded = {};\n      newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.\n      // This helps to match the newRule against nodes returned from getSplits() later on.\n\n      flatten(newRule.expanded.l, context);\n      unflattenr(newRule.expanded.l, context);\n      newRule.expanded.r = makeNode([newRule.r, expandsym]);\n    }\n\n    return newRule;\n  }\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n\n\n  function _buildRules(rules, context) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n      var ruleType = typeof rule;\n\n      switch (ruleType) {\n        case 'string':\n          rule = {\n            s: rule\n          };\n\n        /* falls through */\n\n        case 'object':\n          newRule = _canonicalizeRule(rule, context);\n          break;\n\n        case 'function':\n          newRule = rule;\n          break;\n\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      } // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n\n\n      ruleSet.push(newRule);\n    }\n\n    return ruleSet;\n  }\n\n  var _lastsym = 0;\n\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n\n  function mapRule(nodes, rule, context) {\n    var resNodes = nodes;\n\n    if (nodes) {\n      for (var i = 0; i < nodes.length; ++i) {\n        var newNode = applyRule(nodes[i], rule, context);\n\n        if (newNode !== nodes[i]) {\n          if (resNodes === nodes) {\n            resNodes = nodes.slice();\n          }\n\n          resNodes[i] = newNode;\n        }\n      }\n    }\n\n    return resNodes;\n  }\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {Object | Function} rule\n   * @param  {Object} context -- information about assumed properties of operators\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n\n\n  function applyRule(node, rule, context) {\n    //    console.log('Entering applyRule(\"', rule.l.toString({parenthesis:'all'}), '->', rule.r.toString({parenthesis:'all'}), '\",', node.toString({parenthesis:'all'}),')')\n    // check that the assumptions for this rule are satisfied by the current\n    // context:\n    if (rule.assuming) {\n      for (var symbol in rule.assuming) {\n        for (var property in rule.assuming[symbol]) {\n          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {\n            return node;\n          }\n        }\n      }\n    }\n\n    var mergedContext = mergeContext(rule.imposeContext, context); // Do not clone node unless we find a match\n\n    var res = node; // First replace our child nodes with their simplified versions\n    // If a child could not be simplified, applying the rule to it\n    // will have no effect since the node is returned unchanged\n\n    if (res instanceof OperatorNode || res instanceof FunctionNode) {\n      var newArgs = mapRule(res.args, rule, context);\n\n      if (newArgs !== res.args) {\n        res = res.clone();\n        res.args = newArgs;\n      }\n    } else if (res instanceof ParenthesisNode) {\n      if (res.content) {\n        var newContent = applyRule(res.content, rule, context);\n\n        if (newContent !== res.content) {\n          res = new ParenthesisNode(newContent);\n        }\n      }\n    } else if (res instanceof ArrayNode) {\n      var newItems = mapRule(res.items, rule, context);\n\n      if (newItems !== res.items) {\n        res = new ArrayNode(newItems);\n      }\n    } else if (res instanceof AccessorNode) {\n      var newObj = res.object;\n\n      if (res.object) {\n        newObj = applyRule(res.object, rule, context);\n      }\n\n      var newIndex = res.index;\n\n      if (res.index) {\n        newIndex = applyRule(res.index, rule, context);\n      }\n\n      if (newObj !== res.object || newIndex !== res.index) {\n        res = new AccessorNode(newObj, newIndex);\n      }\n    } else if (res instanceof IndexNode) {\n      var newDims = mapRule(res.dimensions, rule, context);\n\n      if (newDims !== res.dimensions) {\n        res = new IndexNode(newDims);\n      }\n    } else if (res instanceof ObjectNode) {\n      var changed = false;\n      var newProps = {};\n\n      for (var prop in res.properties) {\n        newProps[prop] = applyRule(res.properties[prop], rule, context);\n\n        if (newProps[prop] !== res.properties[prop]) {\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        res = new ObjectNode(newProps);\n      }\n    } // Try to match a rule against this node\n\n\n    var repl = rule.r;\n\n    var matches = _ruleMatch(rule.l, res, mergedContext)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\n    // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n\n\n    if (!matches && rule.expanded) {\n      repl = rule.expanded.r;\n      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];\n    }\n\n    if (matches) {\n      // const before = res.toString({parenthesis: 'all'})\n      // Create a new node by cloning the rhs of the matched rule\n      // we keep any implicit multiplication state if relevant\n      var implicit = res.implicit;\n      res = repl.clone();\n\n      if (implicit && 'implicit' in repl) {\n        res.implicit = true;\n      } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n\n\n      res = res.transform(function (node) {\n        if (node.isSymbolNode && hasOwnProperty(matches.placeholders, node.name)) {\n          return matches.placeholders[node.name].clone();\n        } else {\n          return node;\n        }\n      }); // const after = res.toString({parenthesis: 'all'})\n      // console.log('Simplified ' + before + ' to ' + after)\n    }\n\n    if (rule.repeat && res !== node) {\n      res = applyRule(res, rule, context);\n    }\n\n    return res;\n  }\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n\n\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      // Keep order, but try all parenthesizations\n      for (var _i = 1; _i < node.args.length; _i++) {\n        var left = node.args[0];\n\n        if (_i > 1) {\n          left = makeNode(node.args.slice(0, _i));\n        }\n\n        rightArgs = node.args.slice(_i);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([left, right]));\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n\n\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    }; // Some matches may not have placeholders; this is OK\n\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    } // Placeholders with the same key must match exactly\n\n\n    for (var key in match1.placeholders) {\n      if (hasOwnProperty(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n\n        if (hasOwnProperty(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n\n    for (var _key in match2.placeholders) {\n      if (hasOwnProperty(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n\n\n  function combineChildMatches(list1, list2) {\n    var res = [];\n\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n\n    var merged;\n\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n\n\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n\n    return uniqueSets;\n  }\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param {Object} context -- provides assumed properties of operators\n   * @param {Boolean} isSplit -- whether we are in process of splitting an\n   *                    n-ary operator node into possible binary combinations.\n   *                    Defaults to false.\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _ruleMatch(rule, node, context, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n    //    console.log('Entering _ruleMatch(', rule.toString({parenthesis:'all'}), ', ', node.toString({parenthesis:'all'}), ', ', context, ')')\n    var res = [{\n      placeholders: {}\n    }];\n\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } // rule and node match. Search the children of rule and node.\n\n\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly,\n        // except in any order if operator is commutative\n        var childMatches = [];\n\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i], context);\n\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            break;\n          } // The child matched, so add the information returned from the child to our result\n\n\n          childMatches.push(childMatch);\n        }\n\n        if (childMatches.length !== rule.args.length) {\n          if (!isCommutative(node, context) || // exact match in order needed\n          rule.args.length === 1) {\n            // nothing to commute\n            return [];\n          }\n\n          if (rule.args.length > 2) {\n            /* Need to generate all permutations and try them.\n             * It's a bit complicated, and unlikely to come up since there\n             * are very few ternary or higher operators. So punt for now.\n             */\n            throw new Error('permuting >2 commutative non-associative rule arguments not yet implemented');\n          }\n          /* Exactly two arguments, try them reversed */\n\n\n          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);\n\n          if (leftMatch.length === 0) {\n            return [];\n          }\n\n          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);\n\n          if (rightMatch.length === 0) {\n            return [];\n          }\n\n          childMatches = [leftMatch, rightMatch];\n        }\n\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, context);\n        var splitMatches = [];\n\n        for (var _i2 = 0; _i2 < splits.length; _i2++) {\n          var matchSet = _ruleMatch(rule, splits[_i2], context, true); // recursing at the same tree depth here\n\n\n          splitMatches = splitMatches.concat(matchSet);\n        }\n\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!isConstantNode(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    } // It's a match!\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n\n\n    return res;\n  }\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  return simplify;\n});"],"mappings":"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sBARF;EAAA,IASEC,cATF,eASEA,cATF;EAAA,IAUEC,WAVF,eAUEA,WAVF;EAAA,IAWEC,eAXF,eAWEA,eAXF;EAiBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAEE,IAAIC,QAAQ,GAAGpC,KAAK,CAAC,UAAD,EAAa;IAC/BqC,MAAM,EAAE,SAASA,MAAT,CAAgBC,IAAhB,EAAsB;MAC5B,OAAO,KAAKrC,KAAK,CAACqC,IAAD,CAAV,EAAkB,KAAKC,KAAvB,EAA8B9C,cAAc,EAA5C,EAAgD,EAAhD,CAAP;IACD,CAH8B;IAI/B,wBAAwB,SAAS+C,eAAT,CAAyBF,IAAzB,EAA+BG,KAA/B,EAAsC;MAC5D,OAAO,KAAKxC,KAAK,CAACqC,IAAD,CAAV,EAAkB,KAAKC,KAAvB,EAA8BE,KAA9B,EAAqC,EAArC,CAAP;IACD,CAN8B;IAO/B,gCAAgC,SAASC,qBAAT,CAA+BJ,IAA/B,EAAqCG,KAArC,EAA4CE,OAA5C,EAAqD;MACnF,OAAO,KAAK1C,KAAK,CAACqC,IAAD,CAAV,EAAkB,KAAKC,KAAvB,EAA8BE,KAA9B,EAAqCE,OAArC,CAAP;IACD,CAT8B;IAU/B,iBAAiB,SAASC,WAAT,CAAqBN,IAArB,EAA2BC,KAA3B,EAAkC;MACjD,OAAO,KAAKtC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"},"metadata":{},"sourceType":"module"}