{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport { factory } from '../utils/factory.js';\nimport { isAccessorNode, isConstantNode, isFunctionNode, isOperatorNode, isSymbolNode } from '../utils/is.js';\nimport { deepMap } from '../utils/collection.js';\nimport { hasOwnProperty } from '../utils/object.js';\nvar name = 'parse';\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\nexport var createParse = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      numeric = _ref.numeric,\n      config = _ref.config,\n      AccessorNode = _ref.AccessorNode,\n      ArrayNode = _ref.ArrayNode,\n      AssignmentNode = _ref.AssignmentNode,\n      BlockNode = _ref.BlockNode,\n      ConditionalNode = _ref.ConditionalNode,\n      ConstantNode = _ref.ConstantNode,\n      FunctionAssignmentNode = _ref.FunctionAssignmentNode,\n      FunctionNode = _ref.FunctionNode,\n      IndexNode = _ref.IndexNode,\n      ObjectNode = _ref.ObjectNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      RangeNode = _ref.RangeNode,\n      RelationalNode = _ref.RelationalNode,\n      SymbolNode = _ref.SymbolNode;\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.evaluate().\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.parse(expr)\n   *     math.parse(expr, options)\n   *     math.parse([expr1, expr2, expr3, ...])\n   *     math.parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\n   *     node1.compile().evaluate() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node2 = math.parse('a * b') // 12\n   *     const code2 = node2.compile()\n   *     code2.evaluate(scope) // 12\n   *     scope.a = 5\n   *     code2.evaluate(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile().evaluate() // 12\n   *\n   * See also:\n   *\n   *     evaluate, compile\n   *\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n\n  var parse = typed(name, {\n    string: function string(expression) {\n      return parseStart(expression, {});\n    },\n    'Array | Matrix': function ArrayMatrix(expressions) {\n      return parseMultiple(expressions, {});\n    },\n    'string, Object': function stringObject(expression, options) {\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\n      return parseStart(expression, extraNodes);\n    },\n    'Array | Matrix, Object': parseMultiple\n  });\n\n  function parseMultiple(expressions) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var extraNodes = options.nodes !== undefined ? options.nodes : {}; // parse an array or matrix with expressions\n\n    return deepMap(expressions, function (elem) {\n      if (typeof elem !== 'string') throw new TypeError('String expected');\n      return parseStart(elem, extraNodes);\n    });\n  } // token types enumeration\n\n\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4\n  }; // map with all delimiters\n\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  }; // map with all named delimiters\n\n  var NAMED_DELIMITERS = {\n    mod: true,\n    to: true,\n    in: true,\n    and: true,\n    xor: true,\n    or: true,\n    not: true\n  };\n  var CONSTANTS = {\n    true: true,\n    false: false,\n    null: null,\n    undefined: undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n\n    };\n  }\n  /**\n   * View upto `length` characters of the expression starting at the current character.\n   *\n   * @param {Object} state\n   * @param {number} [length=1] Number of characters to view\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n  /**\n   * View the current character. Returns '' if end of expression is reached.\n   *\n   * @param {Object} state\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n\n\n  function next(state) {\n    state.index++;\n  }\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and tokenType\n   * @private\n   */\n\n\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = ''; // skip over ignored characters:\n\n    while (true) {\n      // comments:\n      if (currentCharacter(state) === '#') {\n        while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n          state.comment += currentCharacter(state);\n          next(state);\n        }\n      } // whitespace: space, tab, and newline when inside parameters\n\n\n      if (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n        next(state);\n      } else {\n        break;\n      }\n    } // check for end of expression\n\n\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    } // check for new line character\n\n\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 2 characters\n\n\n    if (c2.length === 2 && DELIMITERS[c2]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 1 character\n\n\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    } // check for a number\n\n\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER; // check for binary, octal, or hex\n\n      var _c = currentString(state, 2);\n\n      if (_c === '0b' || _c === '0o' || _c === '0x') {\n        state.token += currentCharacter(state);\n        next(state);\n        state.token += currentCharacter(state);\n        next(state);\n\n        while (parse.isHexDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (currentCharacter(state) === '.') {\n          // this number has a radix point\n          state.token += '.';\n          next(state); // get the digits after the radix\n\n          while (parse.isHexDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        } else if (currentCharacter(state) === 'i') {\n          // this number has a word size suffix\n          state.token += 'i';\n          next(state); // get the word size\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        }\n\n        return;\n      } // get number, can have a single dot\n\n\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n          return;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      } // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n\n\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          } // Scientific notation MUST be followed by an exponent\n\n\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (nextCharacter(state) === '.') {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n\n      return;\n    } // check for variables, functions, named operators\n\n\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n\n      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    } // something unknown is found, wrong characters -> a syntax error\n\n\n    state.tokenType = TOKENTYPE.UNKNOWN;\n\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n  /**\n   * Get next token and skip newline tokens\n   */\n\n\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n\n  }\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams(state) is called\n   */\n\n\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n\n\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n\n\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n\n\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * https://unicode-table.com/en/\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n\n\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n\n\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\n' && nestingLevel > 0;\n  };\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n\n\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n  /**\n   * checks if the given char c is a hex digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isHexDigit = function isHexDigit(c) {\n    return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n  };\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n\n    _extends(state, {\n      expression: expression,\n      extraNodes: extraNodes\n    });\n\n    getToken(state);\n    var node = parseBlock(state); // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n      node.comment = state.comment;\n    } // TODO: simplify this loop\n\n\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n\n      getToken(state);\n\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n        node.comment = state.comment;\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n        node.comment = state.comment;\n      }\n\n      return node;\n    }\n  }\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n\n    if (state.token === '=') {\n      if (isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if (isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (isSymbolNode(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level\n\n      state.conditionalLevel = prev;\n    }\n\n    return node;\n  }\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a chained conditional, like 'a > b >= c'\n   * @return {Node} node\n   */\n\n\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(function (c) {\n        return c.fn;\n      }), params);\n    }\n  }\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseShift(state) {\n    var node, name, fn, params;\n    node = parseConversion(state);\n    var operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConversion(state) {\n    var node, name, fn, params;\n    node = parseRange(state);\n    var operators = {\n      to: 'to',\n      in: 'to' // alias of 'to'\n\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === 'in' && state.token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRange(state) {\n    var node;\n    var params = [];\n\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node); // parse step and end\n\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAddSubtract(state) {\n    var node, name, fn, params;\n    node = parseMultiplyDivide(state);\n    var operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      var rightNode = parseMultiplyDivide(state);\n\n      if (rightNode.isPercentage) {\n        params = [node, new OperatorNode('*', 'multiply', [node, rightNode])];\n      } else {\n        params = [node, rightNode];\n      }\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMultiplyDivide(state) {\n    var node, last, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    var operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide'\n    };\n\n    while (true) {\n      if (hasOwnProperty(operators, state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * implicit multiplication\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true\n        /* implicit */\n        );\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\n   * Explicit division gets higher precedence than implicit multiplication\n   * when the division matches this pattern: [number] / [number] [symbol]\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRule2(state) {\n    var node = parsePercentage(state);\n    var last = node;\n    var tokenStates = [];\n\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && isConstantNode(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state); // Match the \"number / number\" part of the pattern\n\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state); // Match the \"symbol\" part of the pattern, or a left parenthesis\n\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n\n            tokenStates.pop();\n            last = parsePercentage(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n\n            _extends(state, tokenStates.pop());\n\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * percentage or mod\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parsePercentage(state) {\n    var node, name, fn, params;\n    node = parseUnary(state);\n    var operators = {\n      '%': 'mod',\n      mod: 'mod'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === '%' && state.tokenType === TOKENTYPE.DELIMITER && state.token !== '(') {\n        // If the expression contains only %, then treat that as /100\n        node = new OperatorNode('/', 'divide', [node, new ConstantNode(100)], false, true);\n      } else {\n        params = [node, parseUnary(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      not: 'not'\n    };\n\n    if (hasOwnProperty(operators, state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow(state);\n  }\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseLeftHandOperators(state);\n\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * Left hand operators: factorial x!, ctranspose x'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLeftHandOperators(state) {\n    var node, name, fn, params;\n    node = parseCustomNodes(state);\n    var operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     }\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params)\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes)\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseCustomNodes(state) {\n    var params = [];\n\n    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state); // parse parameters\n\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ')') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n      } // create a new custom node\n      // noinspection JSValidateTypes\n\n\n      return new CustomNode(params);\n    }\n\n    return parseSymbol(state);\n  }\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSymbol(state) {\n    var node, name;\n\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n\n      if (hasOwnProperty(CONSTANTS, name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      } // parse function parameters and matrix index\n\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseDoubleQuotesString(state);\n  }\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Object} state\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAccessors(state, node, types) {\n    var params;\n\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      params = [];\n\n      if (state.token === '(') {\n        if (isSymbolNode(node) || isAccessorNode(node)) {\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\n          openParams(state);\n          getToken(state);\n\n          if (state.token !== ')') {\n            params.push(parseAssignment(state)); // parse a list with parameters\n\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ']') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params));\n      } else {\n        // dot notation like variable.prop\n        getToken(state);\n\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError(state, 'Property name expected after dot');\n        }\n\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a double quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseDoubleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\"') {\n      str = parseDoubleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseSingleQuotesString(state);\n  }\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n\n\n  function parseDoubleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\"') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\\"'\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\"') {\n      throw createSyntaxError(state, 'End of string \" expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * Parse a single quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSingleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\\'') {\n      str = parseSingleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseMatrix(state);\n  }\n  /**\n   * Parse a string surrounded by single quotes '...'\n   * @return {string}\n   */\n\n\n  function parseSingleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\'') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\''\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\\'') {\n      throw createSyntaxError(state, 'End of string \\' expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row]; // the rows of the matrix are separated by dot-comma's\n\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params[rows] = parseRow(state);\n            rows++;\n          }\n\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state); // check if the number of columns matches in all rows\n\n          cols = params[0].items.length;\n\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(state, array);\n    }\n\n    return parseObject(state);\n  }\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n\n\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state); // parse expression\n\n      params[len] = parseAssignment(state);\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n\n      do {\n        getToken(state);\n\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"') {\n            key = parseDoubleQuotesStringToken(state);\n          } else if (state.token === '\\'') {\n            key = parseSingleQuotesStringToken(state);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          } // parse key/value separator\n\n\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n\n          getToken(state); // parse key\n\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseNumber(state);\n  }\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseNumber(state) {\n    var numberStr;\n\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      return new ConstantNode(numeric(numberStr, config.number));\n    }\n\n    return parseParentheses(state);\n  }\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseParentheses(state) {\n    var node; // check if it is a parenthesized expression\n\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseEnd(state);\n  }\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n\n\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last state.token starts\n   * @private\n   */\n\n\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n\n\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n\n\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n\n  return parse;\n});","map":{"version":3,"names":["_extends","factory","isAccessorNode","isConstantNode","isFunctionNode","isOperatorNode","isSymbolNode","deepMap","hasOwnProperty","name","dependencies","createParse","_ref","typed","numeric","config","AccessorNode","ArrayNode","AssignmentNode","BlockNode","ConditionalNode","ConstantNode","FunctionAssignmentNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","RangeNode","RelationalNode","SymbolNode","parse","string","expression","parseStart","ArrayMatrix","expressions","parseMultiple","stringObject","options","extraNodes","nodes","undefined","arguments","length","elem","TypeError","TOKENTYPE","NULL","DELIMITER","NUMBER","SYMBOL","UNKNOWN","DELIMITERS","NAMED_DELIMITERS","mod","to","in","and","xor","or","not","CONSTANTS","true","false","null","NUMERIC_CONSTANTS","initialState","comment","index","token","tokenType","nestingLevel","conditionalLevel","currentString","state","substr","currentCharacter","next","prevCharacter","charAt","nextCharacter","getToken","isWhitespace","c1","c2","c3","isDigitDot","_c","isHexDigit","isDigit","isDecimalMark","createSyntaxError","isAlpha","getTokenSkipNewline","openParams","closeParams","c","cPrev","cNext","isValidLatinOrGreek","isValidMathSymbol","test","high","low","node","parseBlock","createError","blocks","visible","parseAssignment","push","args","value","valid","parseConditional","object","fn","forEach","arg","parseLogicalOr","prev","condition","trueExpr","falseExpr","parseLogicalXor","parseLogicalAnd","parseBitwiseOr","parseBitwiseXor","parseBitwiseAnd","parseRelational","params","parseShift","conditionals","operators","cond","map","parseConversion","parseRange","parseAddSubtract","parseMultiplyDivide","rightNode","isPercentage","last","parseImplicitMultiplication","parseRule2","op","parsePercentage","tokenStates","pop","parseUnary","parsePow","parseLeftHandOperators","parseCustomNodes","parseAccessors","CustomNode","parseSymbol","indexOf","parseDoubleQuotesString","types","dotNotation","str","parseDoubleQuotesStringToken","parseSingleQuotesString","JSON","parseSingleQuotesStringToken","parseMatrix","array","rows","cols","row","parseRow","items","r","parseObject","len","key","properties","parseNumber","numberStr","number","parseParentheses","parseEnd","col","message","error","SyntaxError","char"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/expression/parse.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport { factory } from '../utils/factory.js';\nimport { isAccessorNode, isConstantNode, isFunctionNode, isOperatorNode, isSymbolNode } from '../utils/is.js';\nimport { deepMap } from '../utils/collection.js';\nimport { hasOwnProperty } from '../utils/object.js';\nvar name = 'parse';\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\nexport var createParse = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    numeric,\n    config,\n    AccessorNode,\n    ArrayNode,\n    AssignmentNode,\n    BlockNode,\n    ConditionalNode,\n    ConstantNode,\n    FunctionAssignmentNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    RangeNode,\n    RelationalNode,\n    SymbolNode\n  } = _ref;\n\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.evaluate().\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.parse(expr)\n   *     math.parse(expr, options)\n   *     math.parse([expr1, expr2, expr3, ...])\n   *     math.parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\n   *     node1.compile().evaluate() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node2 = math.parse('a * b') // 12\n   *     const code2 = node2.compile()\n   *     code2.evaluate(scope) // 12\n   *     scope.a = 5\n   *     code2.evaluate(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile().evaluate() // 12\n   *\n   * See also:\n   *\n   *     evaluate, compile\n   *\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n  var parse = typed(name, {\n    string: function string(expression) {\n      return parseStart(expression, {});\n    },\n    'Array | Matrix': function ArrayMatrix(expressions) {\n      return parseMultiple(expressions, {});\n    },\n    'string, Object': function stringObject(expression, options) {\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\n      return parseStart(expression, extraNodes);\n    },\n    'Array | Matrix, Object': parseMultiple\n  });\n\n  function parseMultiple(expressions) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var extraNodes = options.nodes !== undefined ? options.nodes : {}; // parse an array or matrix with expressions\n\n    return deepMap(expressions, function (elem) {\n      if (typeof elem !== 'string') throw new TypeError('String expected');\n      return parseStart(elem, extraNodes);\n    });\n  } // token types enumeration\n\n\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4\n  }; // map with all delimiters\n\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  }; // map with all named delimiters\n\n  var NAMED_DELIMITERS = {\n    mod: true,\n    to: true,\n    in: true,\n    and: true,\n    xor: true,\n    or: true,\n    not: true\n  };\n  var CONSTANTS = {\n    true: true,\n    false: false,\n    null: null,\n    undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n\n    };\n  }\n  /**\n   * View upto `length` characters of the expression starting at the current character.\n   *\n   * @param {Object} state\n   * @param {number} [length=1] Number of characters to view\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n  /**\n   * View the current character. Returns '' if end of expression is reached.\n   *\n   * @param {Object} state\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n\n\n  function next(state) {\n    state.index++;\n  }\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and tokenType\n   * @private\n   */\n\n\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = ''; // skip over ignored characters:\n\n    while (true) {\n      // comments:\n      if (currentCharacter(state) === '#') {\n        while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n          state.comment += currentCharacter(state);\n          next(state);\n        }\n      } // whitespace: space, tab, and newline when inside parameters\n\n\n      if (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n        next(state);\n      } else {\n        break;\n      }\n    } // check for end of expression\n\n\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    } // check for new line character\n\n\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 2 characters\n\n\n    if (c2.length === 2 && DELIMITERS[c2]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 1 character\n\n\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    } // check for a number\n\n\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER; // check for binary, octal, or hex\n\n      var _c = currentString(state, 2);\n\n      if (_c === '0b' || _c === '0o' || _c === '0x') {\n        state.token += currentCharacter(state);\n        next(state);\n        state.token += currentCharacter(state);\n        next(state);\n\n        while (parse.isHexDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (currentCharacter(state) === '.') {\n          // this number has a radix point\n          state.token += '.';\n          next(state); // get the digits after the radix\n\n          while (parse.isHexDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        } else if (currentCharacter(state) === 'i') {\n          // this number has a word size suffix\n          state.token += 'i';\n          next(state); // get the word size\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        }\n\n        return;\n      } // get number, can have a single dot\n\n\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n          return;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      } // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n\n\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          } // Scientific notation MUST be followed by an exponent\n\n\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (nextCharacter(state) === '.') {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n\n      return;\n    } // check for variables, functions, named operators\n\n\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n\n      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    } // something unknown is found, wrong characters -> a syntax error\n\n\n    state.tokenType = TOKENTYPE.UNKNOWN;\n\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n  /**\n   * Get next token and skip newline tokens\n   */\n\n\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n\n  }\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams(state) is called\n   */\n\n\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n\n\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n\n\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n\n\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * https://unicode-table.com/en/\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n\n\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n\n\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\n' && nestingLevel > 0;\n  };\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n\n\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n  /**\n   * checks if the given char c is a hex digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isHexDigit = function isHexDigit(c) {\n    return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n  };\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n\n    _extends(state, {\n      expression,\n      extraNodes\n    });\n\n    getToken(state);\n    var node = parseBlock(state); // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n      node.comment = state.comment;\n    } // TODO: simplify this loop\n\n\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node,\n          visible\n        });\n      }\n\n      getToken(state);\n\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n        node.comment = state.comment;\n        visible = state.token !== ';';\n        blocks.push({\n          node,\n          visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n        node.comment = state.comment;\n      }\n\n      return node;\n    }\n  }\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n\n    if (state.token === '=') {\n      if (isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if (isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (isSymbolNode(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level\n\n      state.conditionalLevel = prev;\n    }\n\n    return node;\n  }\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a chained conditional, like 'a > b >= c'\n   * @return {Node} node\n   */\n\n\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(c => c.fn), params);\n    }\n  }\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseShift(state) {\n    var node, name, fn, params;\n    node = parseConversion(state);\n    var operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConversion(state) {\n    var node, name, fn, params;\n    node = parseRange(state);\n    var operators = {\n      to: 'to',\n      in: 'to' // alias of 'to'\n\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === 'in' && state.token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRange(state) {\n    var node;\n    var params = [];\n\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node); // parse step and end\n\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAddSubtract(state) {\n    var node, name, fn, params;\n    node = parseMultiplyDivide(state);\n    var operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      var rightNode = parseMultiplyDivide(state);\n\n      if (rightNode.isPercentage) {\n        params = [node, new OperatorNode('*', 'multiply', [node, rightNode])];\n      } else {\n        params = [node, rightNode];\n      }\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMultiplyDivide(state) {\n    var node, last, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    var operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide'\n    };\n\n    while (true) {\n      if (hasOwnProperty(operators, state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * implicit multiplication\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true\n        /* implicit */\n        );\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\n   * Explicit division gets higher precedence than implicit multiplication\n   * when the division matches this pattern: [number] / [number] [symbol]\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRule2(state) {\n    var node = parsePercentage(state);\n    var last = node;\n    var tokenStates = [];\n\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && isConstantNode(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state); // Match the \"number / number\" part of the pattern\n\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state); // Match the \"symbol\" part of the pattern, or a left parenthesis\n\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n\n            tokenStates.pop();\n            last = parsePercentage(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n\n            _extends(state, tokenStates.pop());\n\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * percentage or mod\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parsePercentage(state) {\n    var node, name, fn, params;\n    node = parseUnary(state);\n    var operators = {\n      '%': 'mod',\n      mod: 'mod'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === '%' && state.tokenType === TOKENTYPE.DELIMITER && state.token !== '(') {\n        // If the expression contains only %, then treat that as /100\n        node = new OperatorNode('/', 'divide', [node, new ConstantNode(100)], false, true);\n      } else {\n        params = [node, parseUnary(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      not: 'not'\n    };\n\n    if (hasOwnProperty(operators, state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow(state);\n  }\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseLeftHandOperators(state);\n\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * Left hand operators: factorial x!, ctranspose x'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLeftHandOperators(state) {\n    var node, name, fn, params;\n    node = parseCustomNodes(state);\n    var operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     }\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params)\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes)\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseCustomNodes(state) {\n    var params = [];\n\n    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state); // parse parameters\n\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ')') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n      } // create a new custom node\n      // noinspection JSValidateTypes\n\n\n      return new CustomNode(params);\n    }\n\n    return parseSymbol(state);\n  }\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSymbol(state) {\n    var node, name;\n\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n\n      if (hasOwnProperty(CONSTANTS, name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      } // parse function parameters and matrix index\n\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseDoubleQuotesString(state);\n  }\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Object} state\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAccessors(state, node, types) {\n    var params;\n\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      params = [];\n\n      if (state.token === '(') {\n        if (isSymbolNode(node) || isAccessorNode(node)) {\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\n          openParams(state);\n          getToken(state);\n\n          if (state.token !== ')') {\n            params.push(parseAssignment(state)); // parse a list with parameters\n\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ']') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params));\n      } else {\n        // dot notation like variable.prop\n        getToken(state);\n\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError(state, 'Property name expected after dot');\n        }\n\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a double quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseDoubleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\"') {\n      str = parseDoubleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseSingleQuotesString(state);\n  }\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n\n\n  function parseDoubleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\"') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\\"'\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\"') {\n      throw createSyntaxError(state, 'End of string \" expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * Parse a single quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSingleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\\'') {\n      str = parseSingleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseMatrix(state);\n  }\n  /**\n   * Parse a string surrounded by single quotes '...'\n   * @return {string}\n   */\n\n\n  function parseSingleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\'') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\''\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\\'') {\n      throw createSyntaxError(state, 'End of string \\' expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row]; // the rows of the matrix are separated by dot-comma's\n\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params[rows] = parseRow(state);\n            rows++;\n          }\n\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state); // check if the number of columns matches in all rows\n\n          cols = params[0].items.length;\n\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(state, array);\n    }\n\n    return parseObject(state);\n  }\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n\n\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state); // parse expression\n\n      params[len] = parseAssignment(state);\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n\n      do {\n        getToken(state);\n\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"') {\n            key = parseDoubleQuotesStringToken(state);\n          } else if (state.token === '\\'') {\n            key = parseSingleQuotesStringToken(state);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          } // parse key/value separator\n\n\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n\n          getToken(state); // parse key\n\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseNumber(state);\n  }\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseNumber(state) {\n    var numberStr;\n\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      return new ConstantNode(numeric(numberStr, config.number));\n    }\n\n    return parseParentheses(state);\n  }\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseParentheses(state) {\n    var node; // check if it is a parenthesized expression\n\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseEnd(state);\n  }\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n\n\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last state.token starts\n   * @private\n   */\n\n\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n\n\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n\n\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n\n  return parse;\n});"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,gCAArB;AACA,SAASC,OAAT,QAAwB,qBAAxB;AACA,SAASC,cAAT,EAAyBC,cAAzB,EAAyCC,cAAzC,EAAyDC,cAAzD,EAAyEC,YAAzE,QAA6F,gBAA7F;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,cAAT,QAA+B,oBAA/B;AACA,IAAIC,IAAI,GAAG,OAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,SAAV,EAAqB,QAArB,EAA+B,cAA/B,EAA+C,WAA/C,EAA4D,gBAA5D,EAA8E,WAA9E,EAA2F,iBAA3F,EAA8G,cAA9G,EAA8H,wBAA9H,EAAwJ,cAAxJ,EAAwK,WAAxK,EAAqL,YAArL,EAAmM,cAAnM,EAAmN,iBAAnN,EAAsO,WAAtO,EAAmP,gBAAnP,EAAqQ,YAArQ,CAAnB;AACA,OAAO,IAAIC,WAAW,GAAG,eAAeV,OAAO,CAACQ,IAAD,EAAOC,YAAP,EAAqB,UAAAE,IAAI,EAAI;EAC1E,IACEC,KADF,GAmBID,IAnBJ,CACEC,KADF;EAAA,IAEEC,OAFF,GAmBIF,IAnBJ,CAEEE,OAFF;EAAA,IAGEC,MAHF,GAmBIH,IAnBJ,CAGEG,MAHF;EAAA,IAIEC,YAJF,GAmBIJ,IAnBJ,CAIEI,YAJF;EAAA,IAKEC,SALF,GAmBIL,IAnBJ,CAKEK,SALF;EAAA,IAMEC,cANF,GAmBIN,IAnBJ,CAMEM,cANF;EAAA,IAOEC,SAPF,GAmBIP,IAnBJ,CAOEO,SAPF;EAAA,IAQEC,eARF,GAmBIR,IAnBJ,CAQEQ,eARF;EAAA,IASEC,YATF,GAmBIT,IAnBJ,CASES,YATF;EAAA,IAUEC,sBAVF,GAmBIV,IAnBJ,CAUEU,sBAVF;EAAA,IAWEC,YAXF,GAmBIX,IAnBJ,CAWEW,YAXF;EAAA,IAYEC,SAZF,GAmBIZ,IAnBJ,CAYEY,SAZF;EAAA,IAaEC,UAbF,GAmBIb,IAnBJ,CAaEa,UAbF;EAAA,IAcEC,YAdF,GAmBId,IAnBJ,CAcEc,YAdF;EAAA,IAeEC,eAfF,GAmBIf,IAnBJ,CAeEe,eAfF;EAAA,IAgBEC,SAhBF,GAmBIhB,IAnBJ,CAgBEgB,SAhBF;EAAA,IAiBEC,cAjBF,GAmBIjB,IAnBJ,CAiBEiB,cAjBF;EAAA,IAkBEC,UAlBF,GAmBIlB,IAnBJ,CAkBEkB,UAlBF;EAqBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,IAAIC,KAAK,GAAGlB,KAAK,CAACJ,IAAD,EAAO;IACtBuB,MAAM,EAAE,SAASA,MAAT,CAAgBC,UAAhB,EAA4B;MAClC,OAAOC,UAAU,CAACD,UAAD,EAAa,EAAb,CAAjB;IACD,CAHqB;IAItB,kBAAkB,SAASE,WAAT,CAAqBC,WAArB,EAAkC;MAClD,OAAOC,aAAa,CAACD,WAAD,EAAc,EAAd,CAApB;IACD,CANqB;IAOtB,kBAAkB,SAASE,YAAT,CAAsBL,UAAtB,EAAkCM,OAAlC,EAA2C;MAC3D,IAAIC,UAAU,GAAGD,OAAO,CAACE,KAAR,KAAkBC,SAAlB,GAA8BH,OAAO,CAACE,KAAtC,GAA8C,EAA/D;MACA,OAAOP,UAAU,CAACD,UAAD,EAAaO,UAAb,CAAjB;IACD,CAVqB;IAWtB,0BAA0BH;EAXJ,CAAP,CAAjB;;EAcA,SAASA,aAAT,CAAuBD,WAAvB,EAAoC;IAClC,IAAIG,OAAO,GAAGI,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBD,SAAzC,GAAqDC,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlF;IACA,IAAIH,UAAU,GAAGD,OAAO,CAACE,KAAR,KAAkBC,SAAlB,GAA8BH,OAAO,CAACE,KAAtC,GAA8C,EAA/D,CAFkC,CAEiC;;IAEnE,OAAOlC,OAAO,CAAC6B,WAAD,EAAc,UAAUS,IAAV,EAAgB;MAC1C,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B,MAAM,IAAIC,SAAJ,CAAc,iBAAd,CAAN;MAC9B,OAAOZ,UAAU,CAACW,IAAD,EAAOL,UAAP,CAAjB;IACD,CAHa,CAAd;EAID,CAnFyE,CAmFxE;;;EAGF,IAAIO,SAAS,GAAG;IACdC,IAAI,EAAE,CADQ;IAEdC,SAAS,EAAE,CAFG;IAGdC,MAAM,EAAE,CAHM;IAIdC,MAAM,EAAE,CAJM;IAKdC,OAAO,EAAE;EALK,CAAhB,CAtF0E,CA4FvE;;EAEH,IAAIC,UAAU,GAAG;IACf,KAAK,IADU;IAEf,KAAK,IAFU;IAGf,KAAK,IAHU;IAIf,KAAK,IAJU;IAKf,KAAK,IALU;IAMf,KAAK,IANU;IAOf,KAAK,IAPU;IAQf,KAAK,IARU;IASf,MAAM,IATS;IAUf,KAAK,IAVU;IAWf,KAAK,IAXU;IAYf,KAAK,IAZU;IAaf,KAAK,IAbU;IAcf,MAAM,IAdS;IAef,KAAK,IAfU;IAgBf,MAAM,IAhBS;IAiBf,KAAK,IAjBU;IAkBf,KAAK,IAlBU;IAmBf,MAAM,IAnBS;IAoBf,KAAK,IApBU;IAqBf,KAAK,IArBU;IAsBf,KAAK,IAtBU;IAuBf,KAAK,IAvBU;IAwBf,MAAM,IAxBS;IAyBf,KAAK,IAzBU;IA0Bf,KAAK,IA1BU;IA2Bf,KAAK,IA3BU;IA4Bf,MAAM,IA5BS;IA6Bf,MAAM,IA7BS;IA8Bf,KAAK,IA9BU;IA+Bf,KAAK,IA/BU;IAgCf,MAAM,IAhCS;IAiCf,MAAM,IAjCS;IAkCf,MAAM,IAlCS;IAmCf,MAAM,IAnCS;IAoCf,OAAO;EApCQ,CAAjB,CA9F0E,CAmIvE;;EAEH,IAAIC,gBAAgB,GAAG;IACrBC,GAAG,EAAE,IADgB;IAErBC,EAAE,EAAE,IAFiB;IAGrBC,EAAE,EAAE,IAHiB;IAIrBC,GAAG,EAAE,IAJgB;IAKrBC,GAAG,EAAE,IALgB;IAMrBC,EAAE,EAAE,IANiB;IAOrBC,GAAG,EAAE;EAPgB,CAAvB;EASA,IAAIC,SAAS,GAAG;IACdC,IAAI,EAAE,IADQ;IAEdC,KAAK,EAAE,KAFO;IAGdC,IAAI,EAAE,IAHQ;IAIdvB,SAAS,EAATA;EAJc,CAAhB;EAMA,IAAIwB,iBAAiB,GAAG,CAAC,KAAD,EAAQ,UAAR,CAAxB;;EAEA,SAASC,YAAT,GAAwB;IACtB,OAAO;MACL3B,UAAU,EAAE,EADP;MAEL;MACAP,UAAU,EAAE,EAHP;MAIL;MACAmC,OAAO,EAAE,EALJ;MAML;MACAC,KAAK,EAAE,CAPF;MAQL;MACAC,KAAK,EAAE,EATF;MAUL;MACAC,SAAS,EAAExB,SAAS,CAACC,IAXhB;MAYL;MACAwB,YAAY,EAAE,CAbT;MAcL;MACAC,gBAAgB,EAAE,IAfb,CAekB;;IAflB,CAAP;EAkBD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASC,aAAT,CAAuBC,KAAvB,EAA8B/B,MAA9B,EAAsC;IACpC,OAAO+B,KAAK,CAAC1C,UAAN,CAAiB2C,MAAjB,CAAwBD,KAAK,CAACN,KAA9B,EAAqCzB,MAArC,CAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASiC,gBAAT,CAA0BF,KAA1B,EAAiC;IAC/B,OAAOD,aAAa,CAACC,KAAD,EAAQ,CAAR,CAApB;EACD;EACD;AACF;AACA;AACA;AACA;AACA;;;EAGE,SAASG,IAAT,CAAcH,KAAd,EAAqB;IACnBA,KAAK,CAACN,KAAN;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASU,aAAT,CAAuBJ,KAAvB,EAA8B;IAC5B,OAAOA,KAAK,CAAC1C,UAAN,CAAiB+C,MAAjB,CAAwBL,KAAK,CAACN,KAAN,GAAc,CAAtC,CAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASY,aAAT,CAAuBN,KAAvB,EAA8B;IAC5B,OAAOA,KAAK,CAAC1C,UAAN,CAAiB+C,MAAjB,CAAwBL,KAAK,CAACN,KAAN,GAAc,CAAtC,CAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASa,QAAT,CAAkBP,KAAlB,EAAyB;IACvBA,KAAK,CAACJ,SAAN,GAAkBxB,SAAS,CAACC,IAA5B;IACA2B,KAAK,CAACL,KAAN,GAAc,EAAd;IACAK,KAAK,CAACP,OAAN,GAAgB,EAAhB,CAHuB,CAGH;;IAEpB,OAAO,IAAP,EAAa;MACX;MACA,IAAIS,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,GAAhC,EAAqC;QACnC,OAAOE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,IAA5B,IAAoCE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,EAAvE,EAA2E;UACzEA,KAAK,CAACP,OAAN,IAAiBS,gBAAgB,CAACF,KAAD,CAAjC;UACAG,IAAI,CAACH,KAAD,CAAJ;QACD;MACF,CAPU,CAOT;;;MAGF,IAAI5C,KAAK,CAACoD,YAAN,CAAmBN,gBAAgB,CAACF,KAAD,CAAnC,EAA4CA,KAAK,CAACH,YAAlD,CAAJ,EAAqE;QACnEM,IAAI,CAACH,KAAD,CAAJ;MACD,CAFD,MAEO;QACL;MACD;IACF,CApBsB,CAoBrB;;;IAGF,IAAIE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,EAAhC,EAAoC;MAClC;MACAA,KAAK,CAACJ,SAAN,GAAkBxB,SAAS,CAACE,SAA5B;MACA;IACD,CA3BsB,CA2BrB;;;IAGF,IAAI4B,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,IAA5B,IAAoC,CAACA,KAAK,CAACH,YAA/C,EAA6D;MAC3DG,KAAK,CAACJ,SAAN,GAAkBxB,SAAS,CAACE,SAA5B;MACA0B,KAAK,CAACL,KAAN,GAAcO,gBAAgB,CAACF,KAAD,CAA9B;MACAG,IAAI,CAACH,KAAD,CAAJ;MACA;IACD;;IAED,IAAIS,EAAE,GAAGP,gBAAgB,CAACF,KAAD,CAAzB;IACA,IAAIU,EAAE,GAAGX,aAAa,CAACC,KAAD,EAAQ,CAAR,CAAtB;IACA,IAAIW,EAAE,GAAGZ,aAAa,CAACC,KAAD,EAAQ,CAAR,CAAtB;;IAEA,IAAIW,EAAE,CAAC1C,MAAH,KAAc,CAAd,IAAmBS,UAAU,CAACiC,EAAD,CAAjC,EAAuC;MACrCX,KAAK,CAACJ,SAAN,GAAkBxB,SAAS,CAACE,SAA5B;MACA0B,KAAK,CAACL,KAAN,GAAcgB,EAAd;MACAR,IAAI,CAACH,KAAD,CAAJ;MACAG,IAAI,CAACH,KAAD,CAAJ;MACAG,IAAI,CAACH,KAAD,CAAJ;MACA;IACD,CAhDsB,CAgDrB;;;IAGF,IAAIU,EAAE,CAACzC,MAAH,KAAc,CAAd,IAAmBS,UAAU,CAACgC,EAAD,CAAjC,EAAuC;MACrCV,KAAK,CAACJ,SAAN,GAAkBxB,SAAS,CAACE,SAA5B;MACA0B,KAAK,CAACL,KAAN,GAAce,EAAd;MACAP,IAAI,CAACH,KAAD,CAAJ;MACAG,IAAI,CAACH,KAAD,CAAJ;MACA;IACD,CAzDsB,CAyDrB;;;IAGF,IAAItB,UAAU,CAAC+B,EAAD,CAAd,EAAoB;MAClBT,KAAK,CAACJ,SAAN,GAAkBxB,SAAS,CAACE,SAA5B;MACA0B,KAAK,CAACL,KAAN,GAAcc,EAAd;MACAN,IAAI,CAACH,KAAD,CAAJ;MACA;IACD,CAjEsB,CAiErB;;;IAGF,IAAI5C,KAAK,CAACwD,UAAN,CAAiBH,EAAjB,CAAJ,EAA0B;MACxBT,KAAK,CAACJ,SAAN,GAAkBxB,SAAS,CAACG,MAA5B,CADwB,CACY;;MAEpC,IAAIsC,EAAE,GAAGd,aAAa,CAACC,KAAD,EAAQ,CAAR,CAAtB;;MAEA,IAAIa,EAAE,KAAK,IAAP,IAAeA,EAAE,KAAK,IAAtB,IAA8BA,EAAE,KAAK,IAAzC,EAA+C;QAC7Cb,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;QACAG,IAAI,CAACH,KAAD,CAAJ;QACAA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;QACAG,IAAI,CAACH,KAAD,CAAJ;;QAEA,OAAO5C,KAAK,CAAC0D,UAAN,CAAiBZ,gBAAgB,CAACF,KAAD,CAAjC,CAAP,EAAkD;UAChDA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;UACAG,IAAI,CAACH,KAAD,CAAJ;QACD;;QAED,IAAIE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,GAAhC,EAAqC;UACnC;UACAA,KAAK,CAACL,KAAN,IAAe,GAAf;UACAQ,IAAI,CAACH,KAAD,CAAJ,CAHmC,CAGtB;;UAEb,OAAO5C,KAAK,CAAC0D,UAAN,CAAiBZ,gBAAgB,CAACF,KAAD,CAAjC,CAAP,EAAkD;YAChDA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;YACAG,IAAI,CAACH,KAAD,CAAJ;UACD;QACF,CATD,MASO,IAAIE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,GAAhC,EAAqC;UAC1C;UACAA,KAAK,CAACL,KAAN,IAAe,GAAf;UACAQ,IAAI,CAACH,KAAD,CAAJ,CAH0C,CAG7B;;UAEb,OAAO5C,KAAK,CAAC2D,OAAN,CAAcb,gBAAgB,CAACF,KAAD,CAA9B,CAAP,EAA+C;YAC7CA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;YACAG,IAAI,CAACH,KAAD,CAAJ;UACD;QACF;;QAED;MACD,CArCuB,CAqCtB;;;MAGF,IAAIE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,GAAhC,EAAqC;QACnCA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;QACAG,IAAI,CAACH,KAAD,CAAJ;;QAEA,IAAI,CAAC5C,KAAK,CAAC2D,OAAN,CAAcb,gBAAgB,CAACF,KAAD,CAA9B,CAAL,EAA6C;UAC3C;UACAA,KAAK,CAACJ,SAAN,GAAkBxB,SAAS,CAACE,SAA5B;UACA;QACD;MACF,CATD,MASO;QACL,OAAOlB,KAAK,CAAC2D,OAAN,CAAcb,gBAAgB,CAACF,KAAD,CAA9B,CAAP,EAA+C;UAC7CA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;UACAG,IAAI,CAACH,KAAD,CAAJ;QACD;;QAED,IAAI5C,KAAK,CAAC4D,aAAN,CAAoBd,gBAAgB,CAACF,KAAD,CAApC,EAA6CM,aAAa,CAACN,KAAD,CAA1D,CAAJ,EAAwE;UACtEA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;UACAG,IAAI,CAACH,KAAD,CAAJ;QACD;MACF;;MAED,OAAO5C,KAAK,CAAC2D,OAAN,CAAcb,gBAAgB,CAACF,KAAD,CAA9B,CAAP,EAA+C;QAC7CA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;QACAG,IAAI,CAACH,KAAD,CAAJ;MACD,CAhEuB,CAgEtB;;;MAGF,IAAIE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,GAA5B,IAAmCE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,GAAnE,EAAwE;QACtE,IAAI5C,KAAK,CAAC2D,OAAN,CAAcT,aAAa,CAACN,KAAD,CAA3B,KAAuCM,aAAa,CAACN,KAAD,CAAb,KAAyB,GAAhE,IAAuEM,aAAa,CAACN,KAAD,CAAb,KAAyB,GAApG,EAAyG;UACvGA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;UACAG,IAAI,CAACH,KAAD,CAAJ;;UAEA,IAAIE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,GAA5B,IAAmCE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,GAAnE,EAAwE;YACtEA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;YACAG,IAAI,CAACH,KAAD,CAAJ;UACD,CAPsG,CAOrG;;;UAGF,IAAI,CAAC5C,KAAK,CAAC2D,OAAN,CAAcb,gBAAgB,CAACF,KAAD,CAA9B,CAAL,EAA6C;YAC3C,MAAMiB,iBAAiB,CAACjB,KAAD,EAAQ,0BAA0BE,gBAAgB,CAACF,KAAD,CAA1C,GAAoD,GAA5D,CAAvB;UACD;;UAED,OAAO5C,KAAK,CAAC2D,OAAN,CAAcb,gBAAgB,CAACF,KAAD,CAA9B,CAAP,EAA+C;YAC7CA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;YACAG,IAAI,CAACH,KAAD,CAAJ;UACD;;UAED,IAAI5C,KAAK,CAAC4D,aAAN,CAAoBd,gBAAgB,CAACF,KAAD,CAApC,EAA6CM,aAAa,CAACN,KAAD,CAA1D,CAAJ,EAAwE;YACtE,MAAMiB,iBAAiB,CAACjB,KAAD,EAAQ,0BAA0BE,gBAAgB,CAACF,KAAD,CAA1C,GAAoD,GAA5D,CAAvB;UACD;QACF,CAtBD,MAsBO,IAAIM,aAAa,CAACN,KAAD,CAAb,KAAyB,GAA7B,EAAkC;UACvCG,IAAI,CAACH,KAAD,CAAJ;UACA,MAAMiB,iBAAiB,CAACjB,KAAD,EAAQ,0BAA0BE,gBAAgB,CAACF,KAAD,CAA1C,GAAoD,GAA5D,CAAvB;QACD;MACF;;MAED;IACD,CArKsB,CAqKrB;;;IAGF,IAAI5C,KAAK,CAAC8D,OAAN,CAAchB,gBAAgB,CAACF,KAAD,CAA9B,EAAuCI,aAAa,CAACJ,KAAD,CAApD,EAA6DM,aAAa,CAACN,KAAD,CAA1E,CAAJ,EAAwF;MACtF,OAAO5C,KAAK,CAAC8D,OAAN,CAAchB,gBAAgB,CAACF,KAAD,CAA9B,EAAuCI,aAAa,CAACJ,KAAD,CAApD,EAA6DM,aAAa,CAACN,KAAD,CAA1E,KAAsF5C,KAAK,CAAC2D,OAAN,CAAcb,gBAAgB,CAACF,KAAD,CAA9B,CAA7F,EAAqI;QACnIA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;QACAG,IAAI,CAACH,KAAD,CAAJ;MACD;;MAED,IAAInE,cAAc,CAAC8C,gBAAD,EAAmBqB,KAAK,CAACL,KAAzB,CAAlB,EAAmD;QACjDK,KAAK,CAACJ,SAAN,GAAkBxB,SAAS,CAACE,SAA5B;MACD,CAFD,MAEO;QACL0B,KAAK,CAACJ,SAAN,GAAkBxB,SAAS,CAACI,MAA5B;MACD;;MAED;IACD,CArLsB,CAqLrB;;;IAGFwB,KAAK,CAACJ,SAAN,GAAkBxB,SAAS,CAACK,OAA5B;;IAEA,OAAOyB,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,EAAnC,EAAuC;MACrCA,KAAK,CAACL,KAAN,IAAeO,gBAAgB,CAACF,KAAD,CAA/B;MACAG,IAAI,CAACH,KAAD,CAAJ;IACD;;IAED,MAAMiB,iBAAiB,CAACjB,KAAD,EAAQ,2BAA2BA,KAAK,CAACL,KAAjC,GAAyC,GAAjD,CAAvB;EACD;EACD;AACF;AACA;;;EAGE,SAASwB,mBAAT,CAA6BnB,KAA7B,EAAoC;IAClC,GAAG;MACDO,QAAQ,CAACP,KAAD,CAAR;IACD,CAFD,QAESA,KAAK,CAACL,KAAN,KAAgB,IAFzB,EADkC,CAGF;;EAEjC;EACD;AACF;AACA;AACA;;;EAGE,SAASyB,UAAT,CAAoBpB,KAApB,EAA2B;IACzBA,KAAK,CAACH,YAAN;EACD;EACD;AACF;AACA;AACA;;;EAGE,SAASwB,WAAT,CAAqBrB,KAArB,EAA4B;IAC1BA,KAAK,CAACH,YAAN;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGEzC,KAAK,CAAC8D,OAAN,GAAgB,SAASA,OAAT,CAAiBI,CAAjB,EAAoBC,KAApB,EAA2BC,KAA3B,EAAkC;IAChD,OAAOpE,KAAK,CAACqE,mBAAN,CAA0BH,CAA1B,KAAgClE,KAAK,CAACsE,iBAAN,CAAwBJ,CAAxB,EAA2BE,KAA3B,CAAhC,IAAqEpE,KAAK,CAACsE,iBAAN,CAAwBH,KAAxB,EAA+BD,CAA/B,CAA5E;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;;;EAGElE,KAAK,CAACqE,mBAAN,GAA4B,SAASA,mBAAT,CAA6BH,CAA7B,EAAgC;IAC1D,OAAO,sDAAsDK,IAAtD,CAA2DL,CAA3D,CAAP;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGElE,KAAK,CAACsE,iBAAN,GAA0B,SAASA,iBAAT,CAA2BE,IAA3B,EAAiCC,GAAjC,EAAsC;IAC9D,OAAO,aAAaF,IAAb,CAAkBC,IAAlB,KAA2B,oBAAoBD,IAApB,CAAyBE,GAAzB,CAA3B,IAA4D,2KAA2KF,IAA3K,CAAgLE,GAAhL,CAAnE;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;AACA;;;EAGEzE,KAAK,CAACoD,YAAN,GAAqB,SAASA,YAAT,CAAsBc,CAAtB,EAAyBzB,YAAzB,EAAuC;IAC1D;IACA,OAAOyB,CAAC,KAAK,GAAN,IAAaA,CAAC,KAAK,IAAnB,IAA2BA,CAAC,KAAK,IAAN,IAAczB,YAAY,GAAG,CAA/D;EACD,CAHD;EAIA;AACF;AACA;AACA;AACA;AACA;AACA;;;EAGEzC,KAAK,CAAC4D,aAAN,GAAsB,SAASA,aAAT,CAAuBM,CAAvB,EAA0BE,KAA1B,EAAiC;IACrD,OAAOF,CAAC,KAAK,GAAN,IAAaE,KAAK,KAAK,GAAvB,IAA8BA,KAAK,KAAK,GAAxC,IAA+CA,KAAK,KAAK,GAAhE;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;;;EAGEpE,KAAK,CAACwD,UAAN,GAAmB,SAASA,UAAT,CAAoBU,CAApB,EAAuB;IACxC,OAAOA,CAAC,IAAI,GAAL,IAAYA,CAAC,IAAI,GAAjB,IAAwBA,CAAC,KAAK,GAArC;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;;;EAGElE,KAAK,CAAC2D,OAAN,GAAgB,SAASA,OAAT,CAAiBO,CAAjB,EAAoB;IAClC,OAAOA,CAAC,IAAI,GAAL,IAAYA,CAAC,IAAI,GAAxB;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;;;EAGElE,KAAK,CAAC0D,UAAN,GAAmB,SAASA,UAAT,CAAoBQ,CAApB,EAAuB;IACxC,OAAOA,CAAC,IAAI,GAAL,IAAYA,CAAC,IAAI,GAAjB,IAAwBA,CAAC,IAAI,GAAL,IAAYA,CAAC,IAAI,GAAzC,IAAgDA,CAAC,IAAI,GAAL,IAAYA,CAAC,IAAI,GAAxE;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;;;EAGE,SAAS/D,UAAT,CAAoBD,UAApB,EAAgCO,UAAhC,EAA4C;IAC1C,IAAImC,KAAK,GAAGR,YAAY,EAAxB;;IAEAnE,QAAQ,CAAC2E,KAAD,EAAQ;MACd1C,UAAU,EAAVA,UADc;MAEdO,UAAU,EAAVA;IAFc,CAAR,CAAR;;IAKA0C,QAAQ,CAACP,KAAD,CAAR;IACA,IAAI8B,IAAI,GAAGC,UAAU,CAAC/B,KAAD,CAArB,CAT0C,CASZ;IAC9B;;IAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,EAApB,EAAwB;MACtB,IAAIK,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACE,SAAlC,EAA6C;QAC3C;QACA;QACA,MAAM0D,WAAW,CAAChC,KAAD,EAAQ,yBAAyBA,KAAK,CAACL,KAAvC,CAAjB;MACD,CAJD,MAIO;QACL,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,sBAAsBA,KAAK,CAACL,KAA5B,GAAoC,GAA5C,CAAvB;MACD;IACF;;IAED,OAAOmC,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASC,UAAT,CAAoB/B,KAApB,EAA2B;IACzB,IAAI8B,IAAJ;IACA,IAAIG,MAAM,GAAG,EAAb;IACA,IAAIC,OAAJ;;IAEA,IAAIlC,KAAK,CAACL,KAAN,KAAgB,EAAhB,IAAsBK,KAAK,CAACL,KAAN,KAAgB,IAAtC,IAA8CK,KAAK,CAACL,KAAN,KAAgB,GAAlE,EAAuE;MACrEmC,IAAI,GAAGK,eAAe,CAACnC,KAAD,CAAtB;MACA8B,IAAI,CAACrC,OAAL,GAAeO,KAAK,CAACP,OAArB;IACD,CARwB,CAQvB;;;IAGF,OAAOO,KAAK,CAACL,KAAN,KAAgB,IAAhB,IAAwBK,KAAK,CAACL,KAAN,KAAgB,GAA/C,EAAoD;MAClD;MACA,IAAIsC,MAAM,CAAChE,MAAP,KAAkB,CAAlB,IAAuB6D,IAA3B,EAAiC;QAC/BI,OAAO,GAAGlC,KAAK,CAACL,KAAN,KAAgB,GAA1B;QACAsC,MAAM,CAACG,IAAP,CAAY;UACVN,IAAI,EAAJA,IADU;UAEVI,OAAO,EAAPA;QAFU,CAAZ;MAID;;MAED3B,QAAQ,CAACP,KAAD,CAAR;;MAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,IAAhB,IAAwBK,KAAK,CAACL,KAAN,KAAgB,GAAxC,IAA+CK,KAAK,CAACL,KAAN,KAAgB,EAAnE,EAAuE;QACrEmC,IAAI,GAAGK,eAAe,CAACnC,KAAD,CAAtB;QACA8B,IAAI,CAACrC,OAAL,GAAeO,KAAK,CAACP,OAArB;QACAyC,OAAO,GAAGlC,KAAK,CAACL,KAAN,KAAgB,GAA1B;QACAsC,MAAM,CAACG,IAAP,CAAY;UACVN,IAAI,EAAJA,IADU;UAEVI,OAAO,EAAPA;QAFU,CAAZ;MAID;IACF;;IAED,IAAID,MAAM,CAAChE,MAAP,GAAgB,CAApB,EAAuB;MACrB,OAAO,IAAIzB,SAAJ,CAAcyF,MAAd,CAAP;IACD,CAFD,MAEO;MACL,IAAI,CAACH,IAAL,EAAW;QACTA,IAAI,GAAG,IAAIpF,YAAJ,CAAiBqB,SAAjB,CAAP;QACA+D,IAAI,CAACrC,OAAL,GAAeO,KAAK,CAACP,OAArB;MACD;;MAED,OAAOqC,IAAP;IACD;EACF;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASK,eAAT,CAAyBnC,KAAzB,EAAgC;IAC9B,IAAIlE,IAAJ,EAAUuG,IAAV,EAAgBC,KAAhB,EAAuBC,KAAvB;IACA,IAAIT,IAAI,GAAGU,gBAAgB,CAACxC,KAAD,CAA3B;;IAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;MACvB,IAAIhE,YAAY,CAACmG,IAAD,CAAhB,EAAwB;QACtB;QACAhG,IAAI,GAAGgG,IAAI,CAAChG,IAAZ;QACAqF,mBAAmB,CAACnB,KAAD,CAAnB;QACAsC,KAAK,GAAGH,eAAe,CAACnC,KAAD,CAAvB;QACA,OAAO,IAAIzD,cAAJ,CAAmB,IAAIY,UAAJ,CAAerB,IAAf,CAAnB,EAAyCwG,KAAzC,CAAP;MACD,CAND,MAMO,IAAI/G,cAAc,CAACuG,IAAD,CAAlB,EAA0B;QAC/B;QACAX,mBAAmB,CAACnB,KAAD,CAAnB;QACAsC,KAAK,GAAGH,eAAe,CAACnC,KAAD,CAAvB;QACA,OAAO,IAAIzD,cAAJ,CAAmBuF,IAAI,CAACW,MAAxB,EAAgCX,IAAI,CAACpC,KAArC,EAA4C4C,KAA5C,CAAP;MACD,CALM,MAKA,IAAI7G,cAAc,CAACqG,IAAD,CAAd,IAAwBnG,YAAY,CAACmG,IAAI,CAACY,EAAN,CAAxC,EAAmD;QACxD;QACAH,KAAK,GAAG,IAAR;QACAF,IAAI,GAAG,EAAP;QACAvG,IAAI,GAAGgG,IAAI,CAAChG,IAAZ;QACAgG,IAAI,CAACO,IAAL,CAAUM,OAAV,CAAkB,UAAUC,GAAV,EAAelD,KAAf,EAAsB;UACtC,IAAI/D,YAAY,CAACiH,GAAD,CAAhB,EAAuB;YACrBP,IAAI,CAAC3C,KAAD,CAAJ,GAAckD,GAAG,CAAC9G,IAAlB;UACD,CAFD,MAEO;YACLyG,KAAK,GAAG,KAAR;UACD;QACF,CAND;;QAQA,IAAIA,KAAJ,EAAW;UACTpB,mBAAmB,CAACnB,KAAD,CAAnB;UACAsC,KAAK,GAAGH,eAAe,CAACnC,KAAD,CAAvB;UACA,OAAO,IAAIrD,sBAAJ,CAA2Bb,IAA3B,EAAiCuG,IAAjC,EAAuCC,KAAvC,CAAP;QACD;MACF;;MAED,MAAMrB,iBAAiB,CAACjB,KAAD,EAAQ,iDAAR,CAAvB;IACD;;IAED,OAAO8B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASU,gBAAT,CAA0BxC,KAA1B,EAAiC;IAC/B,IAAI8B,IAAI,GAAGe,cAAc,CAAC7C,KAAD,CAAzB;;IAEA,OAAOA,KAAK,CAACL,KAAN,KAAgB,GAAvB,EAA4B;MAC1B;MACA;MACA;MACA,IAAImD,IAAI,GAAG9C,KAAK,CAACF,gBAAjB;MACAE,KAAK,CAACF,gBAAN,GAAyBE,KAAK,CAACH,YAA/B;MACAsB,mBAAmB,CAACnB,KAAD,CAAnB;MACA,IAAI+C,SAAS,GAAGjB,IAAhB;MACA,IAAIkB,QAAQ,GAAGb,eAAe,CAACnC,KAAD,CAA9B;MACA,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,+CAAR,CAAvB;MACzBA,KAAK,CAACF,gBAAN,GAAyB,IAAzB;MACAqB,mBAAmB,CAACnB,KAAD,CAAnB;MACA,IAAIiD,SAAS,GAAGd,eAAe,CAACnC,KAAD,CAA/B,CAZ0B,CAYc;;MAExC8B,IAAI,GAAG,IAAIrF,eAAJ,CAAoBsG,SAApB,EAA+BC,QAA/B,EAAyCC,SAAzC,CAAP,CAd0B,CAckC;;MAE5DjD,KAAK,CAACF,gBAAN,GAAyBgD,IAAzB;IACD;;IAED,OAAOhB,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASe,cAAT,CAAwB7C,KAAxB,EAA+B;IAC7B,IAAI8B,IAAI,GAAGoB,eAAe,CAAClD,KAAD,CAA1B;;IAEA,OAAOA,KAAK,CAACL,KAAN,KAAgB,IAAvB,EAA6B;MAC3B;MACAwB,mBAAmB,CAACnB,KAAD,CAAnB;MACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiB,IAAjB,EAAuB,IAAvB,EAA6B,CAAC+E,IAAD,EAAOoB,eAAe,CAAClD,KAAD,CAAtB,CAA7B,CAAP;IACD;;IAED,OAAO8B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASoB,eAAT,CAAyBlD,KAAzB,EAAgC;IAC9B,IAAI8B,IAAI,GAAGqB,eAAe,CAACnD,KAAD,CAA1B;;IAEA,OAAOA,KAAK,CAACL,KAAN,KAAgB,KAAvB,EAA8B;MAC5B;MACAwB,mBAAmB,CAACnB,KAAD,CAAnB;MACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiB,KAAjB,EAAwB,KAAxB,EAA+B,CAAC+E,IAAD,EAAOqB,eAAe,CAACnD,KAAD,CAAtB,CAA/B,CAAP;IACD;;IAED,OAAO8B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASqB,eAAT,CAAyBnD,KAAzB,EAAgC;IAC9B,IAAI8B,IAAI,GAAGsB,cAAc,CAACpD,KAAD,CAAzB;;IAEA,OAAOA,KAAK,CAACL,KAAN,KAAgB,KAAvB,EAA8B;MAC5B;MACAwB,mBAAmB,CAACnB,KAAD,CAAnB;MACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiB,KAAjB,EAAwB,KAAxB,EAA+B,CAAC+E,IAAD,EAAOsB,cAAc,CAACpD,KAAD,CAArB,CAA/B,CAAP;IACD;;IAED,OAAO8B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASsB,cAAT,CAAwBpD,KAAxB,EAA+B;IAC7B,IAAI8B,IAAI,GAAGuB,eAAe,CAACrD,KAAD,CAA1B;;IAEA,OAAOA,KAAK,CAACL,KAAN,KAAgB,GAAvB,EAA4B;MAC1B;MACAwB,mBAAmB,CAACnB,KAAD,CAAnB;MACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiB,GAAjB,EAAsB,OAAtB,EAA+B,CAAC+E,IAAD,EAAOuB,eAAe,CAACrD,KAAD,CAAtB,CAA/B,CAAP;IACD;;IAED,OAAO8B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASuB,eAAT,CAAyBrD,KAAzB,EAAgC;IAC9B,IAAI8B,IAAI,GAAGwB,eAAe,CAACtD,KAAD,CAA1B;;IAEA,OAAOA,KAAK,CAACL,KAAN,KAAgB,IAAvB,EAA6B;MAC3B;MACAwB,mBAAmB,CAACnB,KAAD,CAAnB;MACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiB,IAAjB,EAAuB,QAAvB,EAAiC,CAAC+E,IAAD,EAAOwB,eAAe,CAACtD,KAAD,CAAtB,CAAjC,CAAP;IACD;;IAED,OAAO8B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASwB,eAAT,CAAyBtD,KAAzB,EAAgC;IAC9B,IAAI8B,IAAI,GAAGyB,eAAe,CAACvD,KAAD,CAA1B;;IAEA,OAAOA,KAAK,CAACL,KAAN,KAAgB,GAAvB,EAA4B;MAC1B;MACAwB,mBAAmB,CAACnB,KAAD,CAAnB;MACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiB,GAAjB,EAAsB,QAAtB,EAAgC,CAAC+E,IAAD,EAAOyB,eAAe,CAACvD,KAAD,CAAtB,CAAhC,CAAP;IACD;;IAED,OAAO8B,IAAP;EACD;EACD;AACF;AACA;AACA;;;EAGE,SAASyB,eAAT,CAAyBvD,KAAzB,EAAgC;IAC9B,IAAIwD,MAAM,GAAG,CAACC,UAAU,CAACzD,KAAD,CAAX,CAAb;IACA,IAAI0D,YAAY,GAAG,EAAnB;IACA,IAAIC,SAAS,GAAG;MACd,MAAM,OADQ;MAEd,MAAM,SAFQ;MAGd,KAAK,SAHS;MAId,KAAK,QAJS;MAKd,MAAM,WALQ;MAMd,MAAM;IANQ,CAAhB;;IASA,OAAO9H,cAAc,CAAC8H,SAAD,EAAY3D,KAAK,CAACL,KAAlB,CAArB,EAA+C;MAC7C;MACA,IAAIiE,IAAI,GAAG;QACT9H,IAAI,EAAEkE,KAAK,CAACL,KADH;QAET+C,EAAE,EAAEiB,SAAS,CAAC3D,KAAK,CAACL,KAAP;MAFJ,CAAX;MAIA+D,YAAY,CAACtB,IAAb,CAAkBwB,IAAlB;MACAzC,mBAAmB,CAACnB,KAAD,CAAnB;MACAwD,MAAM,CAACpB,IAAP,CAAYqB,UAAU,CAACzD,KAAD,CAAtB;IACD;;IAED,IAAIwD,MAAM,CAACvF,MAAP,KAAkB,CAAtB,EAAyB;MACvB,OAAOuF,MAAM,CAAC,CAAD,CAAb;IACD,CAFD,MAEO,IAAIA,MAAM,CAACvF,MAAP,KAAkB,CAAtB,EAAyB;MAC9B,OAAO,IAAIlB,YAAJ,CAAiB2G,YAAY,CAAC,CAAD,CAAZ,CAAgB5H,IAAjC,EAAuC4H,YAAY,CAAC,CAAD,CAAZ,CAAgBhB,EAAvD,EAA2Dc,MAA3D,CAAP;IACD,CAFM,MAEA;MACL,OAAO,IAAItG,cAAJ,CAAmBwG,YAAY,CAACG,GAAb,CAAiB,UAAAvC,CAAC;QAAA,OAAIA,CAAC,CAACoB,EAAN;MAAA,CAAlB,CAAnB,EAAgDc,MAAhD,CAAP;IACD;EACF;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASC,UAAT,CAAoBzD,KAApB,EAA2B;IACzB,IAAI8B,IAAJ,EAAUhG,IAAV,EAAgB4G,EAAhB,EAAoBc,MAApB;IACA1B,IAAI,GAAGgC,eAAe,CAAC9D,KAAD,CAAtB;IACA,IAAI2D,SAAS,GAAG;MACd,MAAM,WADQ;MAEd,MAAM,iBAFQ;MAGd,OAAO;IAHO,CAAhB;;IAMA,OAAO9H,cAAc,CAAC8H,SAAD,EAAY3D,KAAK,CAACL,KAAlB,CAArB,EAA+C;MAC7C7D,IAAI,GAAGkE,KAAK,CAACL,KAAb;MACA+C,EAAE,GAAGiB,SAAS,CAAC7H,IAAD,CAAd;MACAqF,mBAAmB,CAACnB,KAAD,CAAnB;MACAwD,MAAM,GAAG,CAAC1B,IAAD,EAAOgC,eAAe,CAAC9D,KAAD,CAAtB,CAAT;MACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiBjB,IAAjB,EAAuB4G,EAAvB,EAA2Bc,MAA3B,CAAP;IACD;;IAED,OAAO1B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASgC,eAAT,CAAyB9D,KAAzB,EAAgC;IAC9B,IAAI8B,IAAJ,EAAUhG,IAAV,EAAgB4G,EAAhB,EAAoBc,MAApB;IACA1B,IAAI,GAAGiC,UAAU,CAAC/D,KAAD,CAAjB;IACA,IAAI2D,SAAS,GAAG;MACd9E,EAAE,EAAE,IADU;MAEdC,EAAE,EAAE,IAFU,CAEL;;IAFK,CAAhB;;IAMA,OAAOjD,cAAc,CAAC8H,SAAD,EAAY3D,KAAK,CAACL,KAAlB,CAArB,EAA+C;MAC7C7D,IAAI,GAAGkE,KAAK,CAACL,KAAb;MACA+C,EAAE,GAAGiB,SAAS,CAAC7H,IAAD,CAAd;MACAqF,mBAAmB,CAACnB,KAAD,CAAnB;;MAEA,IAAIlE,IAAI,KAAK,IAAT,IAAiBkE,KAAK,CAACL,KAAN,KAAgB,EAArC,EAAyC;QACvC;QACAmC,IAAI,GAAG,IAAI/E,YAAJ,CAAiB,GAAjB,EAAsB,UAAtB,EAAkC,CAAC+E,IAAD,EAAO,IAAI3E,UAAJ,CAAe,IAAf,CAAP,CAAlC,EAAgE,IAAhE,CAAP;MACD,CAHD,MAGO;QACL;QACAqG,MAAM,GAAG,CAAC1B,IAAD,EAAOiC,UAAU,CAAC/D,KAAD,CAAjB,CAAT;QACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiBjB,IAAjB,EAAuB4G,EAAvB,EAA2Bc,MAA3B,CAAP;MACD;IACF;;IAED,OAAO1B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASiC,UAAT,CAAoB/D,KAApB,EAA2B;IACzB,IAAI8B,IAAJ;IACA,IAAI0B,MAAM,GAAG,EAAb;;IAEA,IAAIxD,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;MACvB;MACAmC,IAAI,GAAG,IAAIpF,YAAJ,CAAiB,CAAjB,CAAP;IACD,CAHD,MAGO;MACL;MACAoF,IAAI,GAAGkC,gBAAgB,CAAChE,KAAD,CAAvB;IACD;;IAED,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAAhB,IAAuBK,KAAK,CAACF,gBAAN,KAA2BE,KAAK,CAACH,YAA5D,EAA0E;MACxE;MACA2D,MAAM,CAACpB,IAAP,CAAYN,IAAZ,EAFwE,CAErD;;MAEnB,OAAO9B,KAAK,CAACL,KAAN,KAAgB,GAAhB,IAAuB6D,MAAM,CAACvF,MAAP,GAAgB,CAA9C,EAAiD;QAC/C;QACAkD,mBAAmB,CAACnB,KAAD,CAAnB;;QAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAAhB,IAAuBK,KAAK,CAACL,KAAN,KAAgB,GAAvC,IAA8CK,KAAK,CAACL,KAAN,KAAgB,GAA9D,IAAqEK,KAAK,CAACL,KAAN,KAAgB,EAAzF,EAA6F;UAC3F;UACA6D,MAAM,CAACpB,IAAP,CAAY,IAAIjF,UAAJ,CAAe,KAAf,CAAZ;QACD,CAHD,MAGO;UACL;UACAqG,MAAM,CAACpB,IAAP,CAAY4B,gBAAgB,CAAChE,KAAD,CAA5B;QACD;MACF;;MAED,IAAIwD,MAAM,CAACvF,MAAP,KAAkB,CAAtB,EAAyB;QACvB;QACA6D,IAAI,GAAG,IAAI7E,SAAJ,CAAcuG,MAAM,CAAC,CAAD,CAApB,EAAyBA,MAAM,CAAC,CAAD,CAA/B,EAAoCA,MAAM,CAAC,CAAD,CAA1C,CAAP,CAFuB,CAEgC;MACxD,CAHD,MAGO;QACL;QACA;QACA1B,IAAI,GAAG,IAAI7E,SAAJ,CAAcuG,MAAM,CAAC,CAAD,CAApB,EAAyBA,MAAM,CAAC,CAAD,CAA/B,CAAP,CAHK,CAGuC;MAC7C;IACF;;IAED,OAAO1B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASkC,gBAAT,CAA0BhE,KAA1B,EAAiC;IAC/B,IAAI8B,IAAJ,EAAUhG,IAAV,EAAgB4G,EAAhB,EAAoBc,MAApB;IACA1B,IAAI,GAAGmC,mBAAmB,CAACjE,KAAD,CAA1B;IACA,IAAI2D,SAAS,GAAG;MACd,KAAK,KADS;MAEd,KAAK;IAFS,CAAhB;;IAKA,OAAO9H,cAAc,CAAC8H,SAAD,EAAY3D,KAAK,CAACL,KAAlB,CAArB,EAA+C;MAC7C7D,IAAI,GAAGkE,KAAK,CAACL,KAAb;MACA+C,EAAE,GAAGiB,SAAS,CAAC7H,IAAD,CAAd;MACAqF,mBAAmB,CAACnB,KAAD,CAAnB;MACA,IAAIkE,SAAS,GAAGD,mBAAmB,CAACjE,KAAD,CAAnC;;MAEA,IAAIkE,SAAS,CAACC,YAAd,EAA4B;QAC1BX,MAAM,GAAG,CAAC1B,IAAD,EAAO,IAAI/E,YAAJ,CAAiB,GAAjB,EAAsB,UAAtB,EAAkC,CAAC+E,IAAD,EAAOoC,SAAP,CAAlC,CAAP,CAAT;MACD,CAFD,MAEO;QACLV,MAAM,GAAG,CAAC1B,IAAD,EAAOoC,SAAP,CAAT;MACD;;MAEDpC,IAAI,GAAG,IAAI/E,YAAJ,CAAiBjB,IAAjB,EAAuB4G,EAAvB,EAA2Bc,MAA3B,CAAP;IACD;;IAED,OAAO1B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASmC,mBAAT,CAA6BjE,KAA7B,EAAoC;IAClC,IAAI8B,IAAJ,EAAUsC,IAAV,EAAgBtI,IAAhB,EAAsB4G,EAAtB;IACAZ,IAAI,GAAGuC,2BAA2B,CAACrE,KAAD,CAAlC;IACAoE,IAAI,GAAGtC,IAAP;IACA,IAAI6B,SAAS,GAAG;MACd,KAAK,UADS;MAEd,MAAM,aAFQ;MAGd,KAAK,QAHS;MAId,MAAM;IAJQ,CAAhB;;IAOA,OAAO,IAAP,EAAa;MACX,IAAI9H,cAAc,CAAC8H,SAAD,EAAY3D,KAAK,CAACL,KAAlB,CAAlB,EAA4C;QAC1C;QACA7D,IAAI,GAAGkE,KAAK,CAACL,KAAb;QACA+C,EAAE,GAAGiB,SAAS,CAAC7H,IAAD,CAAd;QACAqF,mBAAmB,CAACnB,KAAD,CAAnB;QACAoE,IAAI,GAAGC,2BAA2B,CAACrE,KAAD,CAAlC;QACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiBjB,IAAjB,EAAuB4G,EAAvB,EAA2B,CAACZ,IAAD,EAAOsC,IAAP,CAA3B,CAAP;MACD,CAPD,MAOO;QACL;MACD;IACF;;IAED,OAAOtC,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASuC,2BAAT,CAAqCrE,KAArC,EAA4C;IAC1C,IAAI8B,IAAJ,EAAUsC,IAAV;IACAtC,IAAI,GAAGwC,UAAU,CAACtE,KAAD,CAAjB;IACAoE,IAAI,GAAGtC,IAAP;;IAEA,OAAO,IAAP,EAAa;MACX,IAAI9B,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACI,MAA9B,IAAwCwB,KAAK,CAACL,KAAN,KAAgB,IAAhB,IAAwBnE,cAAc,CAACsG,IAAD,CAA9E,IAAwF9B,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACG,MAA9B,IAAwC,CAAC/C,cAAc,CAAC4I,IAAD,CAAvD,KAAkE,CAAC1I,cAAc,CAAC0I,IAAD,CAAf,IAAyBA,IAAI,CAACG,EAAL,KAAY,GAAvG,CAAxF,IAAuMvE,KAAK,CAACL,KAAN,KAAgB,GAA3N,EAAgO;QAC9N;QACA;QACA;QACA;QACA;QACAyE,IAAI,GAAGE,UAAU,CAACtE,KAAD,CAAjB;QACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiB,GAAjB,EAAsB,UAAtB,EAAkC,CAAC+E,IAAD,EAAOsC,IAAP,CAAlC,EAAgD;QACvD;QADO,CAAP;MAGD,CAVD,MAUO;QACL;MACD;IACF;;IAED,OAAOtC,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASwC,UAAT,CAAoBtE,KAApB,EAA2B;IACzB,IAAI8B,IAAI,GAAG0C,eAAe,CAACxE,KAAD,CAA1B;IACA,IAAIoE,IAAI,GAAGtC,IAAX;IACA,IAAI2C,WAAW,GAAG,EAAlB;;IAEA,OAAO,IAAP,EAAa;MACX;MACA,IAAIzE,KAAK,CAACL,KAAN,KAAgB,GAAhB,IAAuBnE,cAAc,CAAC4I,IAAD,CAAzC,EAAiD;QAC/C;QACAK,WAAW,CAACrC,IAAZ,CAAiB/G,QAAQ,CAAC,EAAD,EAAK2E,KAAL,CAAzB;QACAmB,mBAAmB,CAACnB,KAAD,CAAnB,CAH+C,CAGnB;;QAE5B,IAAIA,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACG,MAAlC,EAA0C;UACxC;UACAkG,WAAW,CAACrC,IAAZ,CAAiB/G,QAAQ,CAAC,EAAD,EAAK2E,KAAL,CAAzB;UACAmB,mBAAmB,CAACnB,KAAD,CAAnB,CAHwC,CAGZ;;UAE5B,IAAIA,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACI,MAA9B,IAAwCwB,KAAK,CAACL,KAAN,KAAgB,GAA5D,EAAiE;YAC/D;YACA;YACAtE,QAAQ,CAAC2E,KAAD,EAAQyE,WAAW,CAACC,GAAZ,EAAR,CAAR;;YAEAD,WAAW,CAACC,GAAZ;YACAN,IAAI,GAAGI,eAAe,CAACxE,KAAD,CAAtB;YACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiB,GAAjB,EAAsB,QAAtB,EAAgC,CAAC+E,IAAD,EAAOsC,IAAP,CAAhC,CAAP;UACD,CARD,MAQO;YACL;YACAK,WAAW,CAACC,GAAZ;;YAEArJ,QAAQ,CAAC2E,KAAD,EAAQyE,WAAW,CAACC,GAAZ,EAAR,CAAR;;YAEA;UACD;QACF,CArBD,MAqBO;UACL;UACArJ,QAAQ,CAAC2E,KAAD,EAAQyE,WAAW,CAACC,GAAZ,EAAR,CAAR;;UAEA;QACD;MACF,CAhCD,MAgCO;QACL;MACD;IACF;;IAED,OAAO5C,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAAS0C,eAAT,CAAyBxE,KAAzB,EAAgC;IAC9B,IAAI8B,IAAJ,EAAUhG,IAAV,EAAgB4G,EAAhB,EAAoBc,MAApB;IACA1B,IAAI,GAAG6C,UAAU,CAAC3E,KAAD,CAAjB;IACA,IAAI2D,SAAS,GAAG;MACd,KAAK,KADS;MAEd/E,GAAG,EAAE;IAFS,CAAhB;;IAKA,OAAO/C,cAAc,CAAC8H,SAAD,EAAY3D,KAAK,CAACL,KAAlB,CAArB,EAA+C;MAC7C7D,IAAI,GAAGkE,KAAK,CAACL,KAAb;MACA+C,EAAE,GAAGiB,SAAS,CAAC7H,IAAD,CAAd;MACAqF,mBAAmB,CAACnB,KAAD,CAAnB;;MAEA,IAAIlE,IAAI,KAAK,GAAT,IAAgBkE,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACE,SAA9C,IAA2D0B,KAAK,CAACL,KAAN,KAAgB,GAA/E,EAAoF;QAClF;QACAmC,IAAI,GAAG,IAAI/E,YAAJ,CAAiB,GAAjB,EAAsB,QAAtB,EAAgC,CAAC+E,IAAD,EAAO,IAAIpF,YAAJ,CAAiB,GAAjB,CAAP,CAAhC,EAA+D,KAA/D,EAAsE,IAAtE,CAAP;MACD,CAHD,MAGO;QACL8G,MAAM,GAAG,CAAC1B,IAAD,EAAO6C,UAAU,CAAC3E,KAAD,CAAjB,CAAT;QACA8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiBjB,IAAjB,EAAuB4G,EAAvB,EAA2Bc,MAA3B,CAAP;MACD;IACF;;IAED,OAAO1B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAAS6C,UAAT,CAAoB3E,KAApB,EAA2B;IACzB,IAAIlE,IAAJ,EAAU0H,MAAV,EAAkBd,EAAlB;IACA,IAAIiB,SAAS,GAAG;MACd,KAAK,YADS;MAEd,KAAK,WAFS;MAGd,KAAK,QAHS;MAIdzE,GAAG,EAAE;IAJS,CAAhB;;IAOA,IAAIrD,cAAc,CAAC8H,SAAD,EAAY3D,KAAK,CAACL,KAAlB,CAAlB,EAA4C;MAC1C+C,EAAE,GAAGiB,SAAS,CAAC3D,KAAK,CAACL,KAAP,CAAd;MACA7D,IAAI,GAAGkE,KAAK,CAACL,KAAb;MACAwB,mBAAmB,CAACnB,KAAD,CAAnB;MACAwD,MAAM,GAAG,CAACmB,UAAU,CAAC3E,KAAD,CAAX,CAAT;MACA,OAAO,IAAIjD,YAAJ,CAAiBjB,IAAjB,EAAuB4G,EAAvB,EAA2Bc,MAA3B,CAAP;IACD;;IAED,OAAOoB,QAAQ,CAAC5E,KAAD,CAAf;EACD;EACD;AACF;AACA;AACA;AACA;AACA;;;EAGE,SAAS4E,QAAT,CAAkB5E,KAAlB,EAAyB;IACvB,IAAI8B,IAAJ,EAAUhG,IAAV,EAAgB4G,EAAhB,EAAoBc,MAApB;IACA1B,IAAI,GAAG+C,sBAAsB,CAAC7E,KAAD,CAA7B;;IAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAAhB,IAAuBK,KAAK,CAACL,KAAN,KAAgB,IAA3C,EAAiD;MAC/C7D,IAAI,GAAGkE,KAAK,CAACL,KAAb;MACA+C,EAAE,GAAG5G,IAAI,KAAK,GAAT,GAAe,KAAf,GAAuB,QAA5B;MACAqF,mBAAmB,CAACnB,KAAD,CAAnB;MACAwD,MAAM,GAAG,CAAC1B,IAAD,EAAO6C,UAAU,CAAC3E,KAAD,CAAjB,CAAT,CAJ+C,CAIX;;MAEpC8B,IAAI,GAAG,IAAI/E,YAAJ,CAAiBjB,IAAjB,EAAuB4G,EAAvB,EAA2Bc,MAA3B,CAAP;IACD;;IAED,OAAO1B,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAAS+C,sBAAT,CAAgC7E,KAAhC,EAAuC;IACrC,IAAI8B,IAAJ,EAAUhG,IAAV,EAAgB4G,EAAhB,EAAoBc,MAApB;IACA1B,IAAI,GAAGgD,gBAAgB,CAAC9E,KAAD,CAAvB;IACA,IAAI2D,SAAS,GAAG;MACd,KAAK,WADS;MAEd,MAAM;IAFQ,CAAhB;;IAKA,OAAO9H,cAAc,CAAC8H,SAAD,EAAY3D,KAAK,CAACL,KAAlB,CAArB,EAA+C;MAC7C7D,IAAI,GAAGkE,KAAK,CAACL,KAAb;MACA+C,EAAE,GAAGiB,SAAS,CAAC7H,IAAD,CAAd;MACAyE,QAAQ,CAACP,KAAD,CAAR;MACAwD,MAAM,GAAG,CAAC1B,IAAD,CAAT;MACAA,IAAI,GAAG,IAAI/E,YAAJ,CAAiBjB,IAAjB,EAAuB4G,EAAvB,EAA2Bc,MAA3B,CAAP;MACA1B,IAAI,GAAGiD,cAAc,CAAC/E,KAAD,EAAQ8B,IAAR,CAArB;IACD;;IAED,OAAOA,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASgD,gBAAT,CAA0B9E,KAA1B,EAAiC;IAC/B,IAAIwD,MAAM,GAAG,EAAb;;IAEA,IAAIxD,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACI,MAA9B,IAAwC3C,cAAc,CAACmE,KAAK,CAACnC,UAAP,EAAmBmC,KAAK,CAACL,KAAzB,CAA1D,EAA2F;MACzF,IAAIqF,UAAU,GAAGhF,KAAK,CAACnC,UAAN,CAAiBmC,KAAK,CAACL,KAAvB,CAAjB;MACAY,QAAQ,CAACP,KAAD,CAAR,CAFyF,CAExE;;MAEjB,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;QACvB6D,MAAM,GAAG,EAAT;QACApC,UAAU,CAACpB,KAAD,CAAV;QACAO,QAAQ,CAACP,KAAD,CAAR;;QAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;UACvB6D,MAAM,CAACpB,IAAP,CAAYD,eAAe,CAACnC,KAAD,CAA3B,EADuB,CACc;;UAErC,OAAOA,KAAK,CAACL,KAAN,KAAgB,GAAvB,EAA4B;YAC1B;YACAY,QAAQ,CAACP,KAAD,CAAR;YACAwD,MAAM,CAACpB,IAAP,CAAYD,eAAe,CAACnC,KAAD,CAA3B;UACD;QACF;;QAED,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;UACvB,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,wBAAR,CAAvB;QACD;;QAEDqB,WAAW,CAACrB,KAAD,CAAX;QACAO,QAAQ,CAACP,KAAD,CAAR;MACD,CAzBwF,CAyBvF;MACF;;;MAGA,OAAO,IAAIgF,UAAJ,CAAexB,MAAf,CAAP;IACD;;IAED,OAAOyB,WAAW,CAACjF,KAAD,CAAlB;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASiF,WAAT,CAAqBjF,KAArB,EAA4B;IAC1B,IAAI8B,IAAJ,EAAUhG,IAAV;;IAEA,IAAIkE,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACI,MAA9B,IAAwCwB,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACE,SAA9B,IAA2C0B,KAAK,CAACL,KAAN,IAAehB,gBAAtG,EAAwH;MACtH7C,IAAI,GAAGkE,KAAK,CAACL,KAAb;MACAY,QAAQ,CAACP,KAAD,CAAR;;MAEA,IAAInE,cAAc,CAACsD,SAAD,EAAYrD,IAAZ,CAAlB,EAAqC;QACnC;QACAgG,IAAI,GAAG,IAAIpF,YAAJ,CAAiByC,SAAS,CAACrD,IAAD,CAA1B,CAAP;MACD,CAHD,MAGO,IAAIyD,iBAAiB,CAAC2F,OAAlB,CAA0BpJ,IAA1B,MAAoC,CAAC,CAAzC,EAA4C;QACjD;QACAgG,IAAI,GAAG,IAAIpF,YAAJ,CAAiBP,OAAO,CAACL,IAAD,EAAO,QAAP,CAAxB,CAAP;MACD,CAHM,MAGA;QACLgG,IAAI,GAAG,IAAI3E,UAAJ,CAAerB,IAAf,CAAP;MACD,CAZqH,CAYpH;;;MAGFgG,IAAI,GAAGiD,cAAc,CAAC/E,KAAD,EAAQ8B,IAAR,CAArB;MACA,OAAOA,IAAP;IACD;;IAED,OAAOqD,uBAAuB,CAACnF,KAAD,CAA9B;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAAS+E,cAAT,CAAwB/E,KAAxB,EAA+B8B,IAA/B,EAAqCsD,KAArC,EAA4C;IAC1C,IAAI5B,MAAJ;;IAEA,OAAO,CAACxD,KAAK,CAACL,KAAN,KAAgB,GAAhB,IAAuBK,KAAK,CAACL,KAAN,KAAgB,GAAvC,IAA8CK,KAAK,CAACL,KAAN,KAAgB,GAA/D,MAAwE,CAACyF,KAAD,IAAUA,KAAK,CAACF,OAAN,CAAclF,KAAK,CAACL,KAApB,MAA+B,CAAC,CAAlH,CAAP,EAA6H;MAC3H;MACA6D,MAAM,GAAG,EAAT;;MAEA,IAAIxD,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;QACvB,IAAIhE,YAAY,CAACmG,IAAD,CAAZ,IAAsBvG,cAAc,CAACuG,IAAD,CAAxC,EAAgD;UAC9C;UACAV,UAAU,CAACpB,KAAD,CAAV;UACAO,QAAQ,CAACP,KAAD,CAAR;;UAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;YACvB6D,MAAM,CAACpB,IAAP,CAAYD,eAAe,CAACnC,KAAD,CAA3B,EADuB,CACc;;YAErC,OAAOA,KAAK,CAACL,KAAN,KAAgB,GAAvB,EAA4B;cAC1B;cACAY,QAAQ,CAACP,KAAD,CAAR;cACAwD,MAAM,CAACpB,IAAP,CAAYD,eAAe,CAACnC,KAAD,CAA3B;YACD;UACF;;UAED,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;YACvB,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,wBAAR,CAAvB;UACD;;UAEDqB,WAAW,CAACrB,KAAD,CAAX;UACAO,QAAQ,CAACP,KAAD,CAAR;UACA8B,IAAI,GAAG,IAAIlF,YAAJ,CAAiBkF,IAAjB,EAAuB0B,MAAvB,CAAP;QACD,CAtBD,MAsBO;UACL;UACA;UACA;UACA,OAAO1B,IAAP;QACD;MACF,CA7BD,MA6BO,IAAI9B,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;QAC9B;QACAyB,UAAU,CAACpB,KAAD,CAAV;QACAO,QAAQ,CAACP,KAAD,CAAR;;QAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;UACvB6D,MAAM,CAACpB,IAAP,CAAYD,eAAe,CAACnC,KAAD,CAA3B,EADuB,CACc;;UAErC,OAAOA,KAAK,CAACL,KAAN,KAAgB,GAAvB,EAA4B;YAC1B;YACAY,QAAQ,CAACP,KAAD,CAAR;YACAwD,MAAM,CAACpB,IAAP,CAAYD,eAAe,CAACnC,KAAD,CAA3B;UACD;QACF;;QAED,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;UACvB,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,wBAAR,CAAvB;QACD;;QAEDqB,WAAW,CAACrB,KAAD,CAAX;QACAO,QAAQ,CAACP,KAAD,CAAR;QACA8B,IAAI,GAAG,IAAIzF,YAAJ,CAAiByF,IAAjB,EAAuB,IAAIjF,SAAJ,CAAc2G,MAAd,CAAvB,CAAP;MACD,CAtBM,MAsBA;QACL;QACAjD,QAAQ,CAACP,KAAD,CAAR;;QAEA,IAAIA,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACI,MAAlC,EAA0C;UACxC,MAAMyC,iBAAiB,CAACjB,KAAD,EAAQ,kCAAR,CAAvB;QACD;;QAEDwD,MAAM,CAACpB,IAAP,CAAY,IAAI1F,YAAJ,CAAiBsD,KAAK,CAACL,KAAvB,CAAZ;QACAY,QAAQ,CAACP,KAAD,CAAR;QACA,IAAIqF,WAAW,GAAG,IAAlB;QACAvD,IAAI,GAAG,IAAIzF,YAAJ,CAAiByF,IAAjB,EAAuB,IAAIjF,SAAJ,CAAc2G,MAAd,EAAsB6B,WAAtB,CAAvB,CAAP;MACD;IACF;;IAED,OAAOvD,IAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASqD,uBAAT,CAAiCnF,KAAjC,EAAwC;IACtC,IAAI8B,IAAJ,EAAUwD,GAAV;;IAEA,IAAItF,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;MACvB2F,GAAG,GAAGC,4BAA4B,CAACvF,KAAD,CAAlC,CADuB,CACoB;;MAE3C8B,IAAI,GAAG,IAAIpF,YAAJ,CAAiB4I,GAAjB,CAAP,CAHuB,CAGO;;MAE9BxD,IAAI,GAAGiD,cAAc,CAAC/E,KAAD,EAAQ8B,IAAR,CAArB;MACA,OAAOA,IAAP;IACD;;IAED,OAAO0D,uBAAuB,CAACxF,KAAD,CAA9B;EACD;EACD;AACF;AACA;AACA;;;EAGE,SAASuF,4BAAT,CAAsCvF,KAAtC,EAA6C;IAC3C,IAAIsF,GAAG,GAAG,EAAV;;IAEA,OAAOpF,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,EAA5B,IAAkCE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,GAArE,EAA0E;MACxE,IAAIE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,IAAhC,EAAsC;QACpC;QACA;QACAsF,GAAG,IAAIpF,gBAAgB,CAACF,KAAD,CAAvB;QACAG,IAAI,CAACH,KAAD,CAAJ;MACD;;MAEDsF,GAAG,IAAIpF,gBAAgB,CAACF,KAAD,CAAvB;MACAG,IAAI,CAACH,KAAD,CAAJ;IACD;;IAEDO,QAAQ,CAACP,KAAD,CAAR;;IAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;MACvB,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,0BAAR,CAAvB;IACD;;IAEDO,QAAQ,CAACP,KAAD,CAAR;IACA,OAAOyF,IAAI,CAACrI,KAAL,CAAW,MAAMkI,GAAN,GAAY,GAAvB,CAAP,CAtB2C,CAsBP;EACrC;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASE,uBAAT,CAAiCxF,KAAjC,EAAwC;IACtC,IAAI8B,IAAJ,EAAUwD,GAAV;;IAEA,IAAItF,KAAK,CAACL,KAAN,KAAgB,IAApB,EAA0B;MACxB2F,GAAG,GAAGI,4BAA4B,CAAC1F,KAAD,CAAlC,CADwB,CACmB;;MAE3C8B,IAAI,GAAG,IAAIpF,YAAJ,CAAiB4I,GAAjB,CAAP,CAHwB,CAGM;;MAE9BxD,IAAI,GAAGiD,cAAc,CAAC/E,KAAD,EAAQ8B,IAAR,CAArB;MACA,OAAOA,IAAP;IACD;;IAED,OAAO6D,WAAW,CAAC3F,KAAD,CAAlB;EACD;EACD;AACF;AACA;AACA;;;EAGE,SAAS0F,4BAAT,CAAsC1F,KAAtC,EAA6C;IAC3C,IAAIsF,GAAG,GAAG,EAAV;;IAEA,OAAOpF,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,EAA5B,IAAkCE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,IAArE,EAA2E;MACzE,IAAIE,gBAAgB,CAACF,KAAD,CAAhB,KAA4B,IAAhC,EAAsC;QACpC;QACA;QACAsF,GAAG,IAAIpF,gBAAgB,CAACF,KAAD,CAAvB;QACAG,IAAI,CAACH,KAAD,CAAJ;MACD;;MAEDsF,GAAG,IAAIpF,gBAAgB,CAACF,KAAD,CAAvB;MACAG,IAAI,CAACH,KAAD,CAAJ;IACD;;IAEDO,QAAQ,CAACP,KAAD,CAAR;;IAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,IAApB,EAA0B;MACxB,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,2BAAR,CAAvB;IACD;;IAEDO,QAAQ,CAACP,KAAD,CAAR;IACA,OAAOyF,IAAI,CAACrI,KAAL,CAAW,MAAMkI,GAAN,GAAY,GAAvB,CAAP,CAtB2C,CAsBP;EACrC;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASK,WAAT,CAAqB3F,KAArB,EAA4B;IAC1B,IAAI4F,KAAJ,EAAWpC,MAAX,EAAmBqC,IAAnB,EAAyBC,IAAzB;;IAEA,IAAI9F,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;MACvB;MACAyB,UAAU,CAACpB,KAAD,CAAV;MACAO,QAAQ,CAACP,KAAD,CAAR;;MAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;QACvB;QACA,IAAIoG,GAAG,GAAGC,QAAQ,CAAChG,KAAD,CAAlB;;QAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;UACvB;UACAkG,IAAI,GAAG,CAAP;UACArC,MAAM,GAAG,CAACuC,GAAD,CAAT,CAHuB,CAGP;;UAEhB,OAAO/F,KAAK,CAACL,KAAN,KAAgB,GAAvB,EAA4B;YAC1B;YACAY,QAAQ,CAACP,KAAD,CAAR;YACAwD,MAAM,CAACqC,IAAD,CAAN,GAAeG,QAAQ,CAAChG,KAAD,CAAvB;YACA6F,IAAI;UACL;;UAED,IAAI7F,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;YACvB,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,0BAAR,CAAvB;UACD;;UAEDqB,WAAW,CAACrB,KAAD,CAAX;UACAO,QAAQ,CAACP,KAAD,CAAR,CAjBuB,CAiBN;;UAEjB8F,IAAI,GAAGtC,MAAM,CAAC,CAAD,CAAN,CAAUyC,KAAV,CAAgBhI,MAAvB;;UAEA,KAAK,IAAIiI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,IAApB,EAA0BK,CAAC,EAA3B,EAA+B;YAC7B,IAAI1C,MAAM,CAAC0C,CAAD,CAAN,CAAUD,KAAV,CAAgBhI,MAAhB,KAA2B6H,IAA/B,EAAqC;cACnC,MAAM9D,WAAW,CAAChC,KAAD,EAAQ,gCAAgC,GAAhC,GAAsCwD,MAAM,CAAC0C,CAAD,CAAN,CAAUD,KAAV,CAAgBhI,MAAtD,GAA+D,OAA/D,GAAyE6H,IAAzE,GAAgF,GAAxF,CAAjB;YACD;UACF;;UAEDF,KAAK,GAAG,IAAItJ,SAAJ,CAAckH,MAAd,CAAR;QACD,CA5BD,MA4BO;UACL;UACA,IAAIxD,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;YACvB,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,0BAAR,CAAvB;UACD;;UAEDqB,WAAW,CAACrB,KAAD,CAAX;UACAO,QAAQ,CAACP,KAAD,CAAR;UACA4F,KAAK,GAAGG,GAAR;QACD;MACF,CA1CD,MA0CO;QACL;QACA1E,WAAW,CAACrB,KAAD,CAAX;QACAO,QAAQ,CAACP,KAAD,CAAR;QACA4F,KAAK,GAAG,IAAItJ,SAAJ,CAAc,EAAd,CAAR;MACD;;MAED,OAAOyI,cAAc,CAAC/E,KAAD,EAAQ4F,KAAR,CAArB;IACD;;IAED,OAAOO,WAAW,CAACnG,KAAD,CAAlB;EACD;EACD;AACF;AACA;AACA;;;EAGE,SAASgG,QAAT,CAAkBhG,KAAlB,EAAyB;IACvB,IAAIwD,MAAM,GAAG,CAACrB,eAAe,CAACnC,KAAD,CAAhB,CAAb;IACA,IAAIoG,GAAG,GAAG,CAAV;;IAEA,OAAOpG,KAAK,CAACL,KAAN,KAAgB,GAAvB,EAA4B;MAC1B;MACAY,QAAQ,CAACP,KAAD,CAAR,CAF0B,CAET;;MAEjBwD,MAAM,CAAC4C,GAAD,CAAN,GAAcjE,eAAe,CAACnC,KAAD,CAA7B;MACAoG,GAAG;IACJ;;IAED,OAAO,IAAI9J,SAAJ,CAAckH,MAAd,CAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAAS2C,WAAT,CAAqBnG,KAArB,EAA4B;IAC1B,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;MACvByB,UAAU,CAACpB,KAAD,CAAV;MACA,IAAIqG,GAAJ;MACA,IAAIC,UAAU,GAAG,EAAjB;;MAEA,GAAG;QACD/F,QAAQ,CAACP,KAAD,CAAR;;QAEA,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;UACvB;UACA,IAAIK,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;YACvB0G,GAAG,GAAGd,4BAA4B,CAACvF,KAAD,CAAlC;UACD,CAFD,MAEO,IAAIA,KAAK,CAACL,KAAN,KAAgB,IAApB,EAA0B;YAC/B0G,GAAG,GAAGX,4BAA4B,CAAC1F,KAAD,CAAlC;UACD,CAFM,MAEA,IAAIA,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACI,MAA9B,IAAwCwB,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACE,SAA9B,IAA2C0B,KAAK,CAACL,KAAN,IAAehB,gBAAtG,EAAwH;YAC7H0H,GAAG,GAAGrG,KAAK,CAACL,KAAZ;YACAY,QAAQ,CAACP,KAAD,CAAR;UACD,CAHM,MAGA;YACL,MAAMiB,iBAAiB,CAACjB,KAAD,EAAQ,yCAAR,CAAvB;UACD,CAXsB,CAWrB;;;UAGF,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;YACvB,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,mCAAR,CAAvB;UACD;;UAEDO,QAAQ,CAACP,KAAD,CAAR,CAlBuB,CAkBN;;UAEjBsG,UAAU,CAACD,GAAD,CAAV,GAAkBlE,eAAe,CAACnC,KAAD,CAAjC;QACD;MACF,CAzBD,QAyBSA,KAAK,CAACL,KAAN,KAAgB,GAzBzB,EALuB,CA8BQ;;;MAG/B,IAAIK,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;QACvB,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,kDAAR,CAAvB;MACD;;MAEDqB,WAAW,CAACrB,KAAD,CAAX;MACAO,QAAQ,CAACP,KAAD,CAAR;MACA,IAAI8B,IAAI,GAAG,IAAIhF,UAAJ,CAAewJ,UAAf,CAAX,CAvCuB,CAuCgB;;MAEvCxE,IAAI,GAAGiD,cAAc,CAAC/E,KAAD,EAAQ8B,IAAR,CAArB;MACA,OAAOA,IAAP;IACD;;IAED,OAAOyE,WAAW,CAACvG,KAAD,CAAlB;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASuG,WAAT,CAAqBvG,KAArB,EAA4B;IAC1B,IAAIwG,SAAJ;;IAEA,IAAIxG,KAAK,CAACJ,SAAN,KAAoBxB,SAAS,CAACG,MAAlC,EAA0C;MACxC;MACAiI,SAAS,GAAGxG,KAAK,CAACL,KAAlB;MACAY,QAAQ,CAACP,KAAD,CAAR;MACA,OAAO,IAAItD,YAAJ,CAAiBP,OAAO,CAACqK,SAAD,EAAYpK,MAAM,CAACqK,MAAnB,CAAxB,CAAP;IACD;;IAED,OAAOC,gBAAgB,CAAC1G,KAAD,CAAvB;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAAS0G,gBAAT,CAA0B1G,KAA1B,EAAiC;IAC/B,IAAI8B,IAAJ,CAD+B,CACrB;;IAEV,IAAI9B,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;MACvB;MACAyB,UAAU,CAACpB,KAAD,CAAV;MACAO,QAAQ,CAACP,KAAD,CAAR;MACA8B,IAAI,GAAGK,eAAe,CAACnC,KAAD,CAAtB,CAJuB,CAIQ;;MAE/B,IAAIA,KAAK,CAACL,KAAN,KAAgB,GAApB,EAAyB;QACvB,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,wBAAR,CAAvB;MACD;;MAEDqB,WAAW,CAACrB,KAAD,CAAX;MACAO,QAAQ,CAACP,KAAD,CAAR;MACA8B,IAAI,GAAG,IAAI9E,eAAJ,CAAoB8E,IAApB,CAAP;MACAA,IAAI,GAAGiD,cAAc,CAAC/E,KAAD,EAAQ8B,IAAR,CAArB;MACA,OAAOA,IAAP;IACD;;IAED,OAAO6E,QAAQ,CAAC3G,KAAD,CAAf;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAAS2G,QAAT,CAAkB3G,KAAlB,EAAyB;IACvB,IAAIA,KAAK,CAACL,KAAN,KAAgB,EAApB,EAAwB;MACtB;MACA,MAAMsB,iBAAiB,CAACjB,KAAD,EAAQ,8BAAR,CAAvB;IACD,CAHD,MAGO;MACL,MAAMiB,iBAAiB,CAACjB,KAAD,EAAQ,gBAAR,CAAvB;IACD;EACF;EACD;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;;EAGE,SAAS4G,GAAT,CAAa5G,KAAb,EAAoB;IAClB,OAAOA,KAAK,CAACN,KAAN,GAAcM,KAAK,CAACL,KAAN,CAAY1B,MAA1B,GAAmC,CAA1C;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASgD,iBAAT,CAA2BjB,KAA3B,EAAkC6G,OAAlC,EAA2C;IACzC,IAAIvF,CAAC,GAAGsF,GAAG,CAAC5G,KAAD,CAAX;IACA,IAAI8G,KAAK,GAAG,IAAIC,WAAJ,CAAgBF,OAAO,GAAG,SAAV,GAAsBvF,CAAtB,GAA0B,GAA1C,CAAZ;IACAwF,KAAK,CAACE,IAAN,GAAa1F,CAAb;IACA,OAAOwF,KAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAAS9E,WAAT,CAAqBhC,KAArB,EAA4B6G,OAA5B,EAAqC;IACnC,IAAIvF,CAAC,GAAGsF,GAAG,CAAC5G,KAAD,CAAX;IACA,IAAI8G,KAAK,GAAG,IAAIC,WAAJ,CAAgBF,OAAO,GAAG,SAAV,GAAsBvF,CAAtB,GAA0B,GAA1C,CAAZ;IACAwF,KAAK,CAACE,IAAN,GAAa1F,CAAb;IACA,OAAOwF,KAAP;EACD;;EAED,OAAO1J,KAAP;AACD,CAlwD8C,CAAxC"},"metadata":{},"sourceType":"module"}