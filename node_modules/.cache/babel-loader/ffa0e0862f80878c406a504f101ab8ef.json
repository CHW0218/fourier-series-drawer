{"ast":null,"code":"import { clone } from '../../../utils/object.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'lup';\nvar dependencies = ['typed', 'matrix', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'larger', 'equalScalar', 'unaryMinus', 'DenseMatrix', 'SparseMatrix', 'Spa'];\nexport var createLup = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      abs = _ref.abs,\n      addScalar = _ref.addScalar,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      equalScalar = _ref.equalScalar,\n      unaryMinus = _ref.unaryMinus,\n      DenseMatrix = _ref.DenseMatrix,\n      SparseMatrix = _ref.SparseMatrix,\n      Spa = _ref.Spa;\n  /**\n   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a\n   * row permutation vector `p` where `A[p,:] = L * U`\n   *\n   * Syntax:\n   *\n   *    math.lup(A)\n   *\n   * Example:\n   *\n   *    const m = [[2, 1], [1, 4]]\n   *    const r = math.lup(m)\n   *    // r = {\n   *    //   L: [[1, 0], [0.5, 1]],\n   *    //   U: [[2, 1], [0, 3.5]],\n   *    //   P: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    slu, lsolve, lusolve, usolve\n   *\n   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.\n   *\n   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.\n   */\n\n  return typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseLUP(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseLUP(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a); // lup, use matrix implementation\n\n      var r = _denseLUP(m); // result\n\n\n      return {\n        L: r.L.valueOf(),\n        U: r.U.valueOf(),\n        p: r.p\n      };\n    }\n  });\n\n  function _denseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix array, clone original data\n\n    var data = clone(m._data); // l matrix arrays\n\n    var ldata = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var udata = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vector\n\n    var p = [];\n\n    for (i = 0; i < rows; i++) {\n      p[i] = i;\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // skip first column in upper triangular matrix\n      if (j > 0) {\n        // loop rows\n        for (i = 0; i < rows; i++) {\n          // min i,j\n          var min = Math.min(i, j); // v[i, j]\n\n          var s = 0; // loop up to min\n\n          for (k = 0; k < min; k++) {\n            // s = l[i, k] - data[k, j]\n            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));\n          }\n\n          data[i][j] = subtract(data[i][j], s);\n        }\n      } // row with larger value in cvector, row >= j\n\n\n      var pi = j;\n      var pabsv = 0;\n      var vjj = 0; // loop rows\n\n      for (i = j; i < rows; i++) {\n        // data @ i, j\n        var v = data[i][j]; // absolute value\n\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = i; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      } // swap rows (j <-> pi)\n\n\n      if (j !== pi) {\n        // swap values j <-> pi in p\n        p[j] = [p[pi], p[pi] = p[j]][0]; // swap j <-> pi in data\n\n        DenseMatrix._swapRows(j, pi, data);\n      } // check column is in lower triangular matrix\n\n\n      if (j < rows) {\n        // loop rows (lower triangular matrix)\n        for (i = j + 1; i < rows; i++) {\n          // value @ i, j\n          var vij = data[i][j];\n\n          if (!equalScalar(vij, 0)) {\n            // update data\n            data[i][j] = divideScalar(data[i][j], vjj);\n          }\n        }\n      }\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // loop rows\n      for (i = 0; i < rows; i++) {\n        // initialize row in arrays\n        if (j === 0) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i] = [];\n          } // L\n\n\n          ldata[i] = [];\n        } // check we are in the upper triangular matrix\n\n\n        if (i < j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 0;\n          }\n\n          continue;\n        } // diagonal value\n\n\n        if (i === j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 1;\n          }\n\n          continue;\n        } // check row exists in upper triangular matrix\n\n\n        if (i < columns) {\n          // U\n          udata[i][j] = 0;\n        } // check column exists in lower triangular matrix\n\n\n        if (j < rows) {\n          // L\n          ldata[i][j] = data[i][j];\n        }\n      }\n    } // l matrix\n\n\n    var l = new DenseMatrix({\n      data: ldata,\n      size: lsize\n    }); // u matrix\n\n    var u = new DenseMatrix({\n      data: udata,\n      size: usize\n    }); // p vector\n\n    var pv = [];\n\n    for (i = 0, n = p.length; i < n; i++) {\n      pv[p[i]] = i;\n    } // return matrices\n\n\n    return {\n      L: l,\n      U: u,\n      p: pv,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n\n  function _sparseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix arrays (will not be modified, thanks to permutation vector)\n\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // l matrix arrays\n\n    var lvalues = [];\n    var lindex = [];\n    var lptr = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var uvalues = [];\n    var uindex = [];\n    var uptr = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vectors, (current index -> original index) and (original index -> current index)\n\n    var pvCo = [];\n    var pvOc = [];\n\n    for (i = 0; i < rows; i++) {\n      pvCo[i] = i;\n      pvOc[i] = i;\n    } // swap indices in permutation vectors (condition x < y)!\n\n\n    var swapIndeces = function swapIndeces(x, y) {\n      // find pv indeces getting data from x and y\n      var kx = pvOc[x];\n      var ky = pvOc[y]; // update permutation vector current -> original\n\n      pvCo[kx] = y;\n      pvCo[ky] = x; // update permutation vector original -> current\n\n      pvOc[x] = ky;\n      pvOc[y] = kx;\n    }; // loop columns\n\n\n    var _loop = function _loop() {\n      // sparse accumulator\n      var spa = new Spa(); // check lower triangular matrix has a value @ column j\n\n      if (j < rows) {\n        // update ptr\n        lptr.push(lvalues.length); // first value in j column for lower triangular matrix\n\n        lvalues.push(1);\n        lindex.push(j);\n      } // update ptr\n\n\n      uptr.push(uvalues.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // copy column j into sparse accumulator\n\n      for (k = k0; k < k1; k++) {\n        // row\n        i = index[k]; // copy column values into sparse accumulator (use permutation vector)\n\n        spa.set(pvCo[i], values[k]);\n      } // skip first column in upper triangular matrix\n\n\n      if (j > 0) {\n        // loop rows in column j (above diagonal)\n        spa.forEach(0, j - 1, function (k, vkj) {\n          // loop rows in column k (L)\n          SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {\n            // check row is below k\n            if (i > k) {\n              // update spa value\n              spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));\n            }\n          });\n        });\n      } // row with larger value in spa, row >= j\n\n\n      var pi = j;\n      var vjj = spa.get(j);\n      var pabsv = abs(vjj); // loop values in spa (order by row, below diagonal)\n\n      spa.forEach(j + 1, rows - 1, function (x, v) {\n        // absolute value\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = x; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      }); // swap rows (j <-> pi)\n\n      if (j !== pi) {\n        // swap values j <-> pi in L\n        SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr); // swap values j <-> pi in U\n\n\n        SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr); // swap values in spa\n\n\n        spa.swap(j, pi); // update permutation vector (swap values @ j, pi)\n\n        swapIndeces(j, pi);\n      } // loop values in spa (order by row)\n\n\n      spa.forEach(0, rows - 1, function (x, v) {\n        // check we are above diagonal\n        if (x <= j) {\n          // update upper triangular matrix\n          uvalues.push(v);\n          uindex.push(x);\n        } else {\n          // update value\n          v = divideScalar(v, vjj); // check value is non zero\n\n          if (!equalScalar(v, 0)) {\n            // update lower triangular matrix\n            lvalues.push(v);\n            lindex.push(x);\n          }\n        }\n      });\n    };\n\n    for (j = 0; j < columns; j++) {\n      _loop();\n    } // update ptrs\n\n\n    uptr.push(uvalues.length);\n    lptr.push(lvalues.length); // return matrices\n\n    return {\n      L: new SparseMatrix({\n        values: lvalues,\n        index: lindex,\n        ptr: lptr,\n        size: lsize\n      }),\n      U: new SparseMatrix({\n        values: uvalues,\n        index: uindex,\n        ptr: uptr,\n        size: usize\n      }),\n      p: pvCo,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n});","map":{"version":3,"names":["clone","factory","name","dependencies","createLup","_ref","typed","matrix","abs","addScalar","divideScalar","multiplyScalar","subtract","larger","equalScalar","unaryMinus","DenseMatrix","SparseMatrix","Spa","m","_denseLUP","_sparseLUP","Array","a","r","L","valueOf","U","p","rows","_size","columns","n","Math","min","data","_data","ldata","lsize","udata","usize","i","j","k","s","pi","pabsv","vjj","v","absv","_swapRows","vij","l","size","u","pv","length","toString","values","_values","index","_index","ptr","_ptr","lvalues","lindex","lptr","uvalues","uindex","uptr","pvCo","pvOc","swapIndeces","x","y","kx","ky","_loop","spa","push","k0","k1","set","forEach","vkj","_forEachRow","vik","accumulate","get","swap"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js"],"sourcesContent":["import { clone } from '../../../utils/object.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'lup';\nvar dependencies = ['typed', 'matrix', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'larger', 'equalScalar', 'unaryMinus', 'DenseMatrix', 'SparseMatrix', 'Spa'];\nexport var createLup = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    abs,\n    addScalar,\n    divideScalar,\n    multiplyScalar,\n    subtract,\n    larger,\n    equalScalar,\n    unaryMinus,\n    DenseMatrix,\n    SparseMatrix,\n    Spa\n  } = _ref;\n\n  /**\n   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a\n   * row permutation vector `p` where `A[p,:] = L * U`\n   *\n   * Syntax:\n   *\n   *    math.lup(A)\n   *\n   * Example:\n   *\n   *    const m = [[2, 1], [1, 4]]\n   *    const r = math.lup(m)\n   *    // r = {\n   *    //   L: [[1, 0], [0.5, 1]],\n   *    //   U: [[2, 1], [0, 3.5]],\n   *    //   P: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    slu, lsolve, lusolve, usolve\n   *\n   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.\n   *\n   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.\n   */\n  return typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseLUP(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseLUP(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a); // lup, use matrix implementation\n\n      var r = _denseLUP(m); // result\n\n\n      return {\n        L: r.L.valueOf(),\n        U: r.U.valueOf(),\n        p: r.p\n      };\n    }\n  });\n\n  function _denseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix array, clone original data\n\n    var data = clone(m._data); // l matrix arrays\n\n    var ldata = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var udata = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vector\n\n    var p = [];\n\n    for (i = 0; i < rows; i++) {\n      p[i] = i;\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // skip first column in upper triangular matrix\n      if (j > 0) {\n        // loop rows\n        for (i = 0; i < rows; i++) {\n          // min i,j\n          var min = Math.min(i, j); // v[i, j]\n\n          var s = 0; // loop up to min\n\n          for (k = 0; k < min; k++) {\n            // s = l[i, k] - data[k, j]\n            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));\n          }\n\n          data[i][j] = subtract(data[i][j], s);\n        }\n      } // row with larger value in cvector, row >= j\n\n\n      var pi = j;\n      var pabsv = 0;\n      var vjj = 0; // loop rows\n\n      for (i = j; i < rows; i++) {\n        // data @ i, j\n        var v = data[i][j]; // absolute value\n\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = i; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      } // swap rows (j <-> pi)\n\n\n      if (j !== pi) {\n        // swap values j <-> pi in p\n        p[j] = [p[pi], p[pi] = p[j]][0]; // swap j <-> pi in data\n\n        DenseMatrix._swapRows(j, pi, data);\n      } // check column is in lower triangular matrix\n\n\n      if (j < rows) {\n        // loop rows (lower triangular matrix)\n        for (i = j + 1; i < rows; i++) {\n          // value @ i, j\n          var vij = data[i][j];\n\n          if (!equalScalar(vij, 0)) {\n            // update data\n            data[i][j] = divideScalar(data[i][j], vjj);\n          }\n        }\n      }\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // loop rows\n      for (i = 0; i < rows; i++) {\n        // initialize row in arrays\n        if (j === 0) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i] = [];\n          } // L\n\n\n          ldata[i] = [];\n        } // check we are in the upper triangular matrix\n\n\n        if (i < j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 0;\n          }\n\n          continue;\n        } // diagonal value\n\n\n        if (i === j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 1;\n          }\n\n          continue;\n        } // check row exists in upper triangular matrix\n\n\n        if (i < columns) {\n          // U\n          udata[i][j] = 0;\n        } // check column exists in lower triangular matrix\n\n\n        if (j < rows) {\n          // L\n          ldata[i][j] = data[i][j];\n        }\n      }\n    } // l matrix\n\n\n    var l = new DenseMatrix({\n      data: ldata,\n      size: lsize\n    }); // u matrix\n\n    var u = new DenseMatrix({\n      data: udata,\n      size: usize\n    }); // p vector\n\n    var pv = [];\n\n    for (i = 0, n = p.length; i < n; i++) {\n      pv[p[i]] = i;\n    } // return matrices\n\n\n    return {\n      L: l,\n      U: u,\n      p: pv,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n\n  function _sparseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix arrays (will not be modified, thanks to permutation vector)\n\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // l matrix arrays\n\n    var lvalues = [];\n    var lindex = [];\n    var lptr = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var uvalues = [];\n    var uindex = [];\n    var uptr = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vectors, (current index -> original index) and (original index -> current index)\n\n    var pvCo = [];\n    var pvOc = [];\n\n    for (i = 0; i < rows; i++) {\n      pvCo[i] = i;\n      pvOc[i] = i;\n    } // swap indices in permutation vectors (condition x < y)!\n\n\n    var swapIndeces = function swapIndeces(x, y) {\n      // find pv indeces getting data from x and y\n      var kx = pvOc[x];\n      var ky = pvOc[y]; // update permutation vector current -> original\n\n      pvCo[kx] = y;\n      pvCo[ky] = x; // update permutation vector original -> current\n\n      pvOc[x] = ky;\n      pvOc[y] = kx;\n    }; // loop columns\n\n\n    var _loop = function _loop() {\n      // sparse accumulator\n      var spa = new Spa(); // check lower triangular matrix has a value @ column j\n\n      if (j < rows) {\n        // update ptr\n        lptr.push(lvalues.length); // first value in j column for lower triangular matrix\n\n        lvalues.push(1);\n        lindex.push(j);\n      } // update ptr\n\n\n      uptr.push(uvalues.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // copy column j into sparse accumulator\n\n      for (k = k0; k < k1; k++) {\n        // row\n        i = index[k]; // copy column values into sparse accumulator (use permutation vector)\n\n        spa.set(pvCo[i], values[k]);\n      } // skip first column in upper triangular matrix\n\n\n      if (j > 0) {\n        // loop rows in column j (above diagonal)\n        spa.forEach(0, j - 1, function (k, vkj) {\n          // loop rows in column k (L)\n          SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {\n            // check row is below k\n            if (i > k) {\n              // update spa value\n              spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));\n            }\n          });\n        });\n      } // row with larger value in spa, row >= j\n\n\n      var pi = j;\n      var vjj = spa.get(j);\n      var pabsv = abs(vjj); // loop values in spa (order by row, below diagonal)\n\n      spa.forEach(j + 1, rows - 1, function (x, v) {\n        // absolute value\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = x; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      }); // swap rows (j <-> pi)\n\n      if (j !== pi) {\n        // swap values j <-> pi in L\n        SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr); // swap values j <-> pi in U\n\n\n        SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr); // swap values in spa\n\n\n        spa.swap(j, pi); // update permutation vector (swap values @ j, pi)\n\n        swapIndeces(j, pi);\n      } // loop values in spa (order by row)\n\n\n      spa.forEach(0, rows - 1, function (x, v) {\n        // check we are above diagonal\n        if (x <= j) {\n          // update upper triangular matrix\n          uvalues.push(v);\n          uindex.push(x);\n        } else {\n          // update value\n          v = divideScalar(v, vjj); // check value is non zero\n\n          if (!equalScalar(v, 0)) {\n            // update lower triangular matrix\n            lvalues.push(v);\n            lindex.push(x);\n          }\n        }\n      });\n    };\n\n    for (j = 0; j < columns; j++) {\n      _loop();\n    } // update ptrs\n\n\n    uptr.push(uvalues.length);\n    lptr.push(lvalues.length); // return matrices\n\n    return {\n      L: new SparseMatrix({\n        values: lvalues,\n        index: lindex,\n        ptr: lptr,\n        size: lsize\n      }),\n      U: new SparseMatrix({\n        values: uvalues,\n        index: uindex,\n        ptr: uptr,\n        size: usize\n      }),\n      p: pvCo,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n});"],"mappings":"AAAA,SAASA,KAAT,QAAsB,0BAAtB;AACA,SAASC,OAAT,QAAwB,2BAAxB;AACA,IAAIC,IAAI,GAAG,KAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,QAAV,EAAoB,KAApB,EAA2B,WAA3B,EAAwC,cAAxC,EAAwD,gBAAxD,EAA0E,UAA1E,EAAsF,QAAtF,EAAgG,aAAhG,EAA+G,YAA/G,EAA6H,aAA7H,EAA4I,cAA5I,EAA4J,KAA5J,CAAnB;AACA,OAAO,IAAIC,SAAS,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqB,UAAAE,IAAI,EAAI;EACxE,IACEC,KADF,GAcID,IAdJ,CACEC,KADF;EAAA,IAEEC,MAFF,GAcIF,IAdJ,CAEEE,MAFF;EAAA,IAGEC,GAHF,GAcIH,IAdJ,CAGEG,GAHF;EAAA,IAIEC,SAJF,GAcIJ,IAdJ,CAIEI,SAJF;EAAA,IAKEC,YALF,GAcIL,IAdJ,CAKEK,YALF;EAAA,IAMEC,cANF,GAcIN,IAdJ,CAMEM,cANF;EAAA,IAOEC,QAPF,GAcIP,IAdJ,CAOEO,QAPF;EAAA,IAQEC,MARF,GAcIR,IAdJ,CAQEQ,MARF;EAAA,IASEC,WATF,GAcIT,IAdJ,CASES,WATF;EAAA,IAUEC,UAVF,GAcIV,IAdJ,CAUEU,UAVF;EAAA,IAWEC,WAXF,GAcIX,IAdJ,CAWEW,WAXF;EAAA,IAYEC,YAZF,GAcIZ,IAdJ,CAYEY,YAZF;EAAA,IAaEC,GAbF,GAcIb,IAdJ,CAaEa,GAbF;EAgBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,OAAOZ,KAAK,CAACJ,IAAD,EAAO;IACjBc,WAAW,EAAE,SAASA,WAAT,CAAqBG,CAArB,EAAwB;MACnC,OAAOC,SAAS,CAACD,CAAD,CAAhB;IACD,CAHgB;IAIjBF,YAAY,EAAE,SAASA,YAAT,CAAsBE,CAAtB,EAAyB;MACrC,OAAOE,UAAU,CAACF,CAAD,CAAjB;IACD,CANgB;IAOjBG,KAAK,EAAE,SAASA,KAAT,CAAeC,CAAf,EAAkB;MACvB;MACA,IAAIJ,CAAC,GAAGZ,MAAM,CAACgB,CAAD,CAAd,CAFuB,CAEJ;;MAEnB,IAAIC,CAAC,GAAGJ,SAAS,CAACD,CAAD,CAAjB,CAJuB,CAID;;;MAGtB,OAAO;QACLM,CAAC,EAAED,CAAC,CAACC,CAAF,CAAIC,OAAJ,EADE;QAELC,CAAC,EAAEH,CAAC,CAACG,CAAF,CAAID,OAAJ,EAFE;QAGLE,CAAC,EAAEJ,CAAC,CAACI;MAHA,CAAP;IAKD;EAnBgB,CAAP,CAAZ;;EAsBA,SAASR,SAAT,CAAmBD,CAAnB,EAAsB;IACpB;IACA,IAAIU,IAAI,GAAGV,CAAC,CAACW,KAAF,CAAQ,CAAR,CAAX;IACA,IAAIC,OAAO,GAAGZ,CAAC,CAACW,KAAF,CAAQ,CAAR,CAAd,CAHoB,CAGM;;IAE1B,IAAIE,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASL,IAAT,EAAeE,OAAf,CAAR,CALoB,CAKa;;IAEjC,IAAII,IAAI,GAAGnC,KAAK,CAACmB,CAAC,CAACiB,KAAH,CAAhB,CAPoB,CAOO;;IAE3B,IAAIC,KAAK,GAAG,EAAZ;IACA,IAAIC,KAAK,GAAG,CAACT,IAAD,EAAOG,CAAP,CAAZ,CAVoB,CAUG;;IAEvB,IAAIO,KAAK,GAAG,EAAZ;IACA,IAAIC,KAAK,GAAG,CAACR,CAAD,EAAID,OAAJ,CAAZ,CAboB,CAaM;;IAE1B,IAAIU,CAAJ,EAAOC,CAAP,EAAUC,CAAV,CAfoB,CAeP;;IAEb,IAAIf,CAAC,GAAG,EAAR;;IAEA,KAAKa,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGZ,IAAhB,EAAsBY,CAAC,EAAvB,EAA2B;MACzBb,CAAC,CAACa,CAAD,CAAD,GAAOA,CAAP;IACD,CArBmB,CAqBlB;;;IAGF,KAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGX,OAAhB,EAAyBW,CAAC,EAA1B,EAA8B;MAC5B;MACA,IAAIA,CAAC,GAAG,CAAR,EAAW;QACT;QACA,KAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGZ,IAAhB,EAAsBY,CAAC,EAAvB,EAA2B;UACzB;UACA,IAAIP,GAAG,GAAGD,IAAI,CAACC,GAAL,CAASO,CAAT,EAAYC,CAAZ,CAAV,CAFyB,CAEC;;UAE1B,IAAIE,CAAC,GAAG,CAAR,CAJyB,CAId;;UAEX,KAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGT,GAAhB,EAAqBS,CAAC,EAAtB,EAA0B;YACxB;YACAC,CAAC,GAAGnC,SAAS,CAACmC,CAAD,EAAIjC,cAAc,CAACwB,IAAI,CAACM,CAAD,CAAJ,CAAQE,CAAR,CAAD,EAAaR,IAAI,CAACQ,CAAD,CAAJ,CAAQD,CAAR,CAAb,CAAlB,CAAb;UACD;;UAEDP,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,IAAa9B,QAAQ,CAACuB,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,CAAD,EAAaE,CAAb,CAArB;QACD;MACF,CAjB2B,CAiB1B;;;MAGF,IAAIC,EAAE,GAAGH,CAAT;MACA,IAAII,KAAK,GAAG,CAAZ;MACA,IAAIC,GAAG,GAAG,CAAV,CAtB4B,CAsBf;;MAEb,KAAKN,CAAC,GAAGC,CAAT,EAAYD,CAAC,GAAGZ,IAAhB,EAAsBY,CAAC,EAAvB,EAA2B;QACzB;QACA,IAAIO,CAAC,GAAGb,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,CAAR,CAFyB,CAEL;;QAEpB,IAAIO,IAAI,GAAGzC,GAAG,CAACwC,CAAD,CAAd,CAJyB,CAIN;;QAEnB,IAAInC,MAAM,CAACoC,IAAD,EAAOH,KAAP,CAAV,EAAyB;UACvB;UACAD,EAAE,GAAGJ,CAAL,CAFuB,CAEf;;UAERK,KAAK,GAAGG,IAAR,CAJuB,CAIT;;UAEdF,GAAG,GAAGC,CAAN;QACD;MACF,CAtC2B,CAsC1B;;;MAGF,IAAIN,CAAC,KAAKG,EAAV,EAAc;QACZ;QACAjB,CAAC,CAACc,CAAD,CAAD,GAAO,CAACd,CAAC,CAACiB,EAAD,CAAF,EAAQjB,CAAC,CAACiB,EAAD,CAAD,GAAQjB,CAAC,CAACc,CAAD,CAAjB,EAAsB,CAAtB,CAAP,CAFY,CAEqB;;QAEjC1B,WAAW,CAACkC,SAAZ,CAAsBR,CAAtB,EAAyBG,EAAzB,EAA6BV,IAA7B;MACD,CA9C2B,CA8C1B;;;MAGF,IAAIO,CAAC,GAAGb,IAAR,EAAc;QACZ;QACA,KAAKY,CAAC,GAAGC,CAAC,GAAG,CAAb,EAAgBD,CAAC,GAAGZ,IAApB,EAA0BY,CAAC,EAA3B,EAA+B;UAC7B;UACA,IAAIU,GAAG,GAAGhB,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,CAAV;;UAEA,IAAI,CAAC5B,WAAW,CAACqC,GAAD,EAAM,CAAN,CAAhB,EAA0B;YACxB;YACAhB,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,IAAahC,YAAY,CAACyB,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,CAAD,EAAaK,GAAb,CAAzB;UACD;QACF;MACF;IACF,CArFmB,CAqFlB;;;IAGF,KAAKL,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGX,OAAhB,EAAyBW,CAAC,EAA1B,EAA8B;MAC5B;MACA,KAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGZ,IAAhB,EAAsBY,CAAC,EAAvB,EAA2B;QACzB;QACA,IAAIC,CAAC,KAAK,CAAV,EAAa;UACX;UACA,IAAID,CAAC,GAAGV,OAAR,EAAiB;YACf;YACAQ,KAAK,CAACE,CAAD,CAAL,GAAW,EAAX;UACD,CALU,CAKT;;;UAGFJ,KAAK,CAACI,CAAD,CAAL,GAAW,EAAX;QACD,CAXwB,CAWvB;;;QAGF,IAAIA,CAAC,GAAGC,CAAR,EAAW;UACT;UACA,IAAID,CAAC,GAAGV,OAAR,EAAiB;YACf;YACAQ,KAAK,CAACE,CAAD,CAAL,CAASC,CAAT,IAAcP,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,CAAd;UACD,CALQ,CAKP;;;UAGF,IAAIA,CAAC,GAAGb,IAAR,EAAc;YACZ;YACAQ,KAAK,CAACI,CAAD,CAAL,CAASC,CAAT,IAAc,CAAd;UACD;;UAED;QACD,CA5BwB,CA4BvB;;;QAGF,IAAID,CAAC,KAAKC,CAAV,EAAa;UACX;UACA,IAAID,CAAC,GAAGV,OAAR,EAAiB;YACf;YACAQ,KAAK,CAACE,CAAD,CAAL,CAASC,CAAT,IAAcP,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,CAAd;UACD,CALU,CAKT;;;UAGF,IAAIA,CAAC,GAAGb,IAAR,EAAc;YACZ;YACAQ,KAAK,CAACI,CAAD,CAAL,CAASC,CAAT,IAAc,CAAd;UACD;;UAED;QACD,CA7CwB,CA6CvB;;;QAGF,IAAID,CAAC,GAAGV,OAAR,EAAiB;UACf;UACAQ,KAAK,CAACE,CAAD,CAAL,CAASC,CAAT,IAAc,CAAd;QACD,CAnDwB,CAmDvB;;;QAGF,IAAIA,CAAC,GAAGb,IAAR,EAAc;UACZ;UACAQ,KAAK,CAACI,CAAD,CAAL,CAASC,CAAT,IAAcP,IAAI,CAACM,CAAD,CAAJ,CAAQC,CAAR,CAAd;QACD;MACF;IACF,CArJmB,CAqJlB;;;IAGF,IAAIU,CAAC,GAAG,IAAIpC,WAAJ,CAAgB;MACtBmB,IAAI,EAAEE,KADgB;MAEtBgB,IAAI,EAAEf;IAFgB,CAAhB,CAAR,CAxJoB,CA2JhB;;IAEJ,IAAIgB,CAAC,GAAG,IAAItC,WAAJ,CAAgB;MACtBmB,IAAI,EAAEI,KADgB;MAEtBc,IAAI,EAAEb;IAFgB,CAAhB,CAAR,CA7JoB,CAgKhB;;IAEJ,IAAIe,EAAE,GAAG,EAAT;;IAEA,KAAKd,CAAC,GAAG,CAAJ,EAAOT,CAAC,GAAGJ,CAAC,CAAC4B,MAAlB,EAA0Bf,CAAC,GAAGT,CAA9B,EAAiCS,CAAC,EAAlC,EAAsC;MACpCc,EAAE,CAAC3B,CAAC,CAACa,CAAD,CAAF,CAAF,GAAWA,CAAX;IACD,CAtKmB,CAsKlB;;;IAGF,OAAO;MACLhB,CAAC,EAAE2B,CADE;MAELzB,CAAC,EAAE2B,CAFE;MAGL1B,CAAC,EAAE2B,EAHE;MAILE,QAAQ,EAAE,SAASA,QAAT,GAAoB;QAC5B,OAAO,QAAQ,KAAKhC,CAAL,CAAOgC,QAAP,EAAR,GAA4B,OAA5B,GAAsC,KAAK9B,CAAL,CAAO8B,QAAP,EAAtC,GAA0D,OAA1D,GAAoE,KAAK7B,CAAhF;MACD;IANI,CAAP;EAQD;;EAED,SAASP,UAAT,CAAoBF,CAApB,EAAuB;IACrB;IACA,IAAIU,IAAI,GAAGV,CAAC,CAACW,KAAF,CAAQ,CAAR,CAAX;IACA,IAAIC,OAAO,GAAGZ,CAAC,CAACW,KAAF,CAAQ,CAAR,CAAd,CAHqB,CAGK;;IAE1B,IAAIE,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASL,IAAT,EAAeE,OAAf,CAAR,CALqB,CAKY;;IAEjC,IAAI2B,MAAM,GAAGvC,CAAC,CAACwC,OAAf;IACA,IAAIC,KAAK,GAAGzC,CAAC,CAAC0C,MAAd;IACA,IAAIC,GAAG,GAAG3C,CAAC,CAAC4C,IAAZ,CATqB,CASH;;IAElB,IAAIC,OAAO,GAAG,EAAd;IACA,IAAIC,MAAM,GAAG,EAAb;IACA,IAAIC,IAAI,GAAG,EAAX;IACA,IAAI5B,KAAK,GAAG,CAACT,IAAD,EAAOG,CAAP,CAAZ,CAdqB,CAcE;;IAEvB,IAAImC,OAAO,GAAG,EAAd;IACA,IAAIC,MAAM,GAAG,EAAb;IACA,IAAIC,IAAI,GAAG,EAAX;IACA,IAAI7B,KAAK,GAAG,CAACR,CAAD,EAAID,OAAJ,CAAZ,CAnBqB,CAmBK;;IAE1B,IAAIU,CAAJ,EAAOC,CAAP,EAAUC,CAAV,CArBqB,CAqBR;;IAEb,IAAI2B,IAAI,GAAG,EAAX;IACA,IAAIC,IAAI,GAAG,EAAX;;IAEA,KAAK9B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGZ,IAAhB,EAAsBY,CAAC,EAAvB,EAA2B;MACzB6B,IAAI,CAAC7B,CAAD,CAAJ,GAAUA,CAAV;MACA8B,IAAI,CAAC9B,CAAD,CAAJ,GAAUA,CAAV;IACD,CA7BoB,CA6BnB;;;IAGF,IAAI+B,WAAW,GAAG,SAASA,WAAT,CAAqBC,CAArB,EAAwBC,CAAxB,EAA2B;MAC3C;MACA,IAAIC,EAAE,GAAGJ,IAAI,CAACE,CAAD,CAAb;MACA,IAAIG,EAAE,GAAGL,IAAI,CAACG,CAAD,CAAb,CAH2C,CAGzB;;MAElBJ,IAAI,CAACK,EAAD,CAAJ,GAAWD,CAAX;MACAJ,IAAI,CAACM,EAAD,CAAJ,GAAWH,CAAX,CAN2C,CAM7B;;MAEdF,IAAI,CAACE,CAAD,CAAJ,GAAUG,EAAV;MACAL,IAAI,CAACG,CAAD,CAAJ,GAAUC,EAAV;IACD,CAVD,CAhCqB,CA0ClB;;;IAGH,IAAIE,KAAK,GAAG,SAASA,KAAT,GAAiB;MAC3B;MACA,IAAIC,GAAG,GAAG,IAAI5D,GAAJ,EAAV,CAF2B,CAEN;;MAErB,IAAIwB,CAAC,GAAGb,IAAR,EAAc;QACZ;QACAqC,IAAI,CAACa,IAAL,CAAUf,OAAO,CAACR,MAAlB,EAFY,CAEe;;QAE3BQ,OAAO,CAACe,IAAR,CAAa,CAAb;QACAd,MAAM,CAACc,IAAP,CAAYrC,CAAZ;MACD,CAV0B,CAUzB;;;MAGF2B,IAAI,CAACU,IAAL,CAAUZ,OAAO,CAACX,MAAlB,EAb2B,CAaA;;MAE3B,IAAIwB,EAAE,GAAGlB,GAAG,CAACpB,CAAD,CAAZ;MACA,IAAIuC,EAAE,GAAGnB,GAAG,CAACpB,CAAC,GAAG,CAAL,CAAZ,CAhB2B,CAgBN;;MAErB,KAAKC,CAAC,GAAGqC,EAAT,EAAarC,CAAC,GAAGsC,EAAjB,EAAqBtC,CAAC,EAAtB,EAA0B;QACxB;QACAF,CAAC,GAAGmB,KAAK,CAACjB,CAAD,CAAT,CAFwB,CAEV;;QAEdmC,GAAG,CAACI,GAAJ,CAAQZ,IAAI,CAAC7B,CAAD,CAAZ,EAAiBiB,MAAM,CAACf,CAAD,CAAvB;MACD,CAvB0B,CAuBzB;;;MAGF,IAAID,CAAC,GAAG,CAAR,EAAW;QACT;QACAoC,GAAG,CAACK,OAAJ,CAAY,CAAZ,EAAezC,CAAC,GAAG,CAAnB,EAAsB,UAAUC,CAAV,EAAayC,GAAb,EAAkB;UACtC;UACAnE,YAAY,CAACoE,WAAb,CAAyB1C,CAAzB,EAA4BqB,OAA5B,EAAqCC,MAArC,EAA6CC,IAA7C,EAAmD,UAAUzB,CAAV,EAAa6C,GAAb,EAAkB;YACnE;YACA,IAAI7C,CAAC,GAAGE,CAAR,EAAW;cACT;cACAmC,GAAG,CAACS,UAAJ,CAAe9C,CAAf,EAAkB1B,UAAU,CAACJ,cAAc,CAAC2E,GAAD,EAAMF,GAAN,CAAf,CAA5B;YACD;UACF,CAND;QAOD,CATD;MAUD,CAtC0B,CAsCzB;;;MAGF,IAAIvC,EAAE,GAAGH,CAAT;MACA,IAAIK,GAAG,GAAG+B,GAAG,CAACU,GAAJ,CAAQ9C,CAAR,CAAV;MACA,IAAII,KAAK,GAAGtC,GAAG,CAACuC,GAAD,CAAf,CA3C2B,CA2CL;;MAEtB+B,GAAG,CAACK,OAAJ,CAAYzC,CAAC,GAAG,CAAhB,EAAmBb,IAAI,GAAG,CAA1B,EAA6B,UAAU4C,CAAV,EAAazB,CAAb,EAAgB;QAC3C;QACA,IAAIC,IAAI,GAAGzC,GAAG,CAACwC,CAAD,CAAd,CAF2C,CAExB;;QAEnB,IAAInC,MAAM,CAACoC,IAAD,EAAOH,KAAP,CAAV,EAAyB;UACvB;UACAD,EAAE,GAAG4B,CAAL,CAFuB,CAEf;;UAER3B,KAAK,GAAGG,IAAR,CAJuB,CAIT;;UAEdF,GAAG,GAAGC,CAAN;QACD;MACF,CAZD,EA7C2B,CAyDvB;;MAEJ,IAAIN,CAAC,KAAKG,EAAV,EAAc;QACZ;QACA5B,YAAY,CAACiC,SAAb,CAAuBR,CAAvB,EAA0BG,EAA1B,EAA8BP,KAAK,CAAC,CAAD,CAAnC,EAAwC0B,OAAxC,EAAiDC,MAAjD,EAAyDC,IAAzD,EAFY,CAEoD;;;QAGhEjD,YAAY,CAACiC,SAAb,CAAuBR,CAAvB,EAA0BG,EAA1B,EAA8BL,KAAK,CAAC,CAAD,CAAnC,EAAwC2B,OAAxC,EAAiDC,MAAjD,EAAyDC,IAAzD,EALY,CAKoD;;;QAGhES,GAAG,CAACW,IAAJ,CAAS/C,CAAT,EAAYG,EAAZ,EARY,CAQK;;QAEjB2B,WAAW,CAAC9B,CAAD,EAAIG,EAAJ,CAAX;MACD,CAtE0B,CAsEzB;;;MAGFiC,GAAG,CAACK,OAAJ,CAAY,CAAZ,EAAetD,IAAI,GAAG,CAAtB,EAAyB,UAAU4C,CAAV,EAAazB,CAAb,EAAgB;QACvC;QACA,IAAIyB,CAAC,IAAI/B,CAAT,EAAY;UACV;UACAyB,OAAO,CAACY,IAAR,CAAa/B,CAAb;UACAoB,MAAM,CAACW,IAAP,CAAYN,CAAZ;QACD,CAJD,MAIO;UACL;UACAzB,CAAC,GAAGtC,YAAY,CAACsC,CAAD,EAAID,GAAJ,CAAhB,CAFK,CAEqB;;UAE1B,IAAI,CAACjC,WAAW,CAACkC,CAAD,EAAI,CAAJ,CAAhB,EAAwB;YACtB;YACAgB,OAAO,CAACe,IAAR,CAAa/B,CAAb;YACAiB,MAAM,CAACc,IAAP,CAAYN,CAAZ;UACD;QACF;MACF,CAhBD;IAiBD,CA1FD;;IA4FA,KAAK/B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGX,OAAhB,EAAyBW,CAAC,EAA1B,EAA8B;MAC5BmC,KAAK;IACN,CA3IoB,CA2InB;;;IAGFR,IAAI,CAACU,IAAL,CAAUZ,OAAO,CAACX,MAAlB;IACAU,IAAI,CAACa,IAAL,CAAUf,OAAO,CAACR,MAAlB,EA/IqB,CA+IM;;IAE3B,OAAO;MACL/B,CAAC,EAAE,IAAIR,YAAJ,CAAiB;QAClByC,MAAM,EAAEM,OADU;QAElBJ,KAAK,EAAEK,MAFW;QAGlBH,GAAG,EAAEI,IAHa;QAIlBb,IAAI,EAAEf;MAJY,CAAjB,CADE;MAOLX,CAAC,EAAE,IAAIV,YAAJ,CAAiB;QAClByC,MAAM,EAAES,OADU;QAElBP,KAAK,EAAEQ,MAFW;QAGlBN,GAAG,EAAEO,IAHa;QAIlBhB,IAAI,EAAEb;MAJY,CAAjB,CAPE;MAaLZ,CAAC,EAAE0C,IAbE;MAcLb,QAAQ,EAAE,SAASA,QAAT,GAAoB;QAC5B,OAAO,QAAQ,KAAKhC,CAAL,CAAOgC,QAAP,EAAR,GAA4B,OAA5B,GAAsC,KAAK9B,CAAL,CAAO8B,QAAP,EAAtC,GAA0D,OAA1D,GAAoE,KAAK7B,CAAhF;MACD;IAhBI,CAAP;EAkBD;AACF,CAxZ4C,CAAtC"},"metadata":{},"sourceType":"module"}