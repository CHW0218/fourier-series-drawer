{"ast":null,"code":"import _toConsumableArray from \"/Users/ayao/vscode/fourier-series-drawer/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { deepStrictEqual } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nimport { createMap } from '../../utils/map.js';\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nexport var createNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var mathWithTransform = _ref.mathWithTransform;\n  /**\n   * Node\n   */\n\n  function Node() {\n    if (!(this instanceof Node)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n  }\n  /**\n   * Evaluate the node\n   * @param {Object} [scope]  Scope to read/write variables\n   * @return {*}              Returns the result\n   */\n\n\n  Node.prototype.evaluate = function (scope) {\n    return this.compile().evaluate(scope);\n  };\n\n  Node.prototype.type = 'Node';\n  Node.prototype.isNode = true;\n  Node.prototype.comment = '';\n  /**\n   * Compile the node into an optimized, evauatable JavaScript function\n   * @return {{evaluate: function([Object])}} object\n   *                Returns an object with a function 'evaluate',\n   *                which can be invoked as expr.evaluate([scope: Object]),\n   *                where scope is an optional object with\n   *                variables.\n   */\n\n  Node.prototype.compile = function () {\n    var expr = this._compile(mathWithTransform, {});\n\n    var args = {};\n    var context = null;\n\n    function evaluate(scope) {\n      var s = createMap(scope);\n\n      _validateScope(s);\n\n      return expr(s, args, context);\n    }\n\n    return {\n      evaluate: evaluate\n    };\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  Node.prototype._compile = function (math, argNames) {\n    throw new Error('Method _compile should be implemented by type ' + this.type);\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  Node.prototype.forEach = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run forEach on a Node interface');\n  };\n  /**\n   * Create a new Node having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n\n  Node.prototype.map = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run map on a Node interface');\n  };\n  /**\n   * Validate whether an object is a Node, for use with map\n   * @param {Node} node\n   * @returns {Node} Returns the input if it's a node, else throws an Error\n   * @protected\n   */\n\n\n  Node.prototype._ifNode = function (node) {\n    if (!isNode(node)) {\n      throw new TypeError('Callback function must return a Node');\n    }\n\n    return node;\n  };\n  /**\n   * Recursively traverse all nodes in a node tree. Executes given callback for\n   * this node and each of its child nodes.\n   * @param {function(node: Node, path: string, parent: Node)} callback\n   *          A callback called for every node in the node tree.\n   */\n\n\n  Node.prototype.traverse = function (callback) {\n    // execute callback for itself\n    // eslint-disable-next-line\n    callback(this, null, null); // recursively traverse over all childs of a node\n\n    function _traverse(node, callback) {\n      node.forEach(function (child, path, parent) {\n        callback(child, path, parent);\n\n        _traverse(child, callback);\n      });\n    }\n\n    _traverse(this, callback);\n  };\n  /**\n   * Recursively transform a node tree via a transform function.\n   *\n   * For example, to replace all nodes of type SymbolNode having name 'x' with a\n   * ConstantNode with value 2:\n   *\n   *     const res = Node.transform(function (node, path, parent) {\n   *       if (node && node.isSymbolNode) && (node.name === 'x')) {\n   *         return new ConstantNode(2)\n   *       }\n   *       else {\n   *         return node\n   *       }\n   *     })\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *          A mapping function accepting a node, and returning\n   *          a replacement for the node or the original node.\n   *          Signature: callback(node: Node, index: string, parent: Node) : Node\n   * @return {Node} Returns the original node or its replacement\n   */\n\n\n  Node.prototype.transform = function (callback) {\n    function _transform(child, path, parent) {\n      var replacement = callback(child, path, parent);\n\n      if (replacement !== child) {\n        // stop iterating when the node is replaced\n        return replacement;\n      }\n\n      return child.map(_transform);\n    }\n\n    return _transform(this, null, null);\n  };\n  /**\n   * Find any node in the node tree matching given filter function. For example, to\n   * find all nodes of type SymbolNode having name 'x':\n   *\n   *     const results = Node.filter(function (node) {\n   *       return (node && node.isSymbolNode) && (node.name === 'x')\n   *     })\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *            A test function returning true when a node matches, and false\n   *            otherwise. Function signature:\n   *            callback(node: Node, index: string, parent: Node) : boolean\n   * @return {Node[]} nodes       An array with nodes matching given filter criteria\n   */\n\n\n  Node.prototype.filter = function (callback) {\n    var nodes = [];\n    this.traverse(function (node, path, parent) {\n      if (callback(node, path, parent)) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  };\n  /**\n   * Create a shallow clone of this node\n   * @return {Node}\n   */\n\n\n  Node.prototype.clone = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot clone a Node interface');\n  };\n  /**\n   * Create a deep clone of this node\n   * @return {Node}\n   */\n\n\n  Node.prototype.cloneDeep = function () {\n    return this.map(function (node) {\n      return node.cloneDeep();\n    });\n  };\n  /**\n   * Deep compare this node with another node.\n   * @param {Node} other\n   * @return {boolean} Returns true when both nodes are of the same type and\n   *                   contain the same values (as do their childs)\n   */\n\n\n  Node.prototype.equals = function (other) {\n    return other ? deepStrictEqual(this, other) : false;\n  };\n  /**\n   * Get string representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toString = function (options) {\n    var customString = this._getCustomString(options);\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this._toString(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * Both .toJSON() and the static .fromJSON(json) should be implemented by all\n   * implementations of Node\n   * @returns {Object}\n   */\n\n\n  Node.prototype.toJSON = function () {\n    throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n  };\n  /**\n   * Get HTML representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\" or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toHTML = function (options) {\n    var customString = this._getCustomString(options);\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this.toHTML(options);\n  };\n  /**\n   * Internal function to generate the string output.\n   * This has to be implemented by every Node\n   *\n   * @throws {Error}\n   */\n\n\n  Node.prototype._toString = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toString not implemented for ' + this.type);\n  };\n  /**\n   * Get LaTeX representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toTex = function (options) {\n    var customString = this._getCustomString(options);\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this._toTex(options);\n  };\n  /**\n   * Internal function to generate the LaTeX output.\n   * This has to be implemented by every Node\n   *\n   * @param {Object} [options]\n   * @throws {Error}\n   */\n\n\n  Node.prototype._toTex = function (options) {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toTex not implemented for ' + this.type);\n  };\n  /**\n   * Helper used by `to...` functions.\n   */\n\n\n  Node.prototype._getCustomString = function (options) {\n    if (options && typeof options === 'object') {\n      switch (typeof options.handler) {\n        case 'object':\n        case 'undefined':\n          return;\n\n        case 'function':\n          return options.handler(this, options);\n\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  Node.prototype.getIdentifier = function () {\n    return this.type;\n  };\n  /**\n   * Get the content of the current Node.\n   * @return {Node} node\n   **/\n\n\n  Node.prototype.getContent = function () {\n    return this;\n  };\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n\n\n  function _validateScope(scope) {\n    for (var _i = 0, _arr = _toConsumableArray(keywords); _i < _arr.length; _i++) {\n      var symbol = _arr[_i];\n\n      if (scope.has(symbol)) {\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n      }\n    }\n  }\n\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isNode","keywords","deepStrictEqual","factory","createMap","name","dependencies","createNode","_ref","mathWithTransform","Node","SyntaxError","prototype","evaluate","scope","compile","type","comment","expr","_compile","args","context","s","_validateScope","math","argNames","Error","forEach","callback","map","_ifNode","node","TypeError","traverse","_traverse","child","path","parent","transform","_transform","replacement","filter","nodes","push","clone","cloneDeep","equals","other","toString","options","customString","_getCustomString","_toString","toJSON","toHTML","toTex","_toTex","handler","getIdentifier","getContent","symbol","has","isClass"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/expression/node/Node.js"],"sourcesContent":["import { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { deepStrictEqual } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nimport { createMap } from '../../utils/map.js';\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nexport var createNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    mathWithTransform\n  } = _ref;\n\n  /**\n   * Node\n   */\n  function Node() {\n    if (!(this instanceof Node)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n  }\n  /**\n   * Evaluate the node\n   * @param {Object} [scope]  Scope to read/write variables\n   * @return {*}              Returns the result\n   */\n\n\n  Node.prototype.evaluate = function (scope) {\n    return this.compile().evaluate(scope);\n  };\n\n  Node.prototype.type = 'Node';\n  Node.prototype.isNode = true;\n  Node.prototype.comment = '';\n  /**\n   * Compile the node into an optimized, evauatable JavaScript function\n   * @return {{evaluate: function([Object])}} object\n   *                Returns an object with a function 'evaluate',\n   *                which can be invoked as expr.evaluate([scope: Object]),\n   *                where scope is an optional object with\n   *                variables.\n   */\n\n  Node.prototype.compile = function () {\n    var expr = this._compile(mathWithTransform, {});\n\n    var args = {};\n    var context = null;\n\n    function evaluate(scope) {\n      var s = createMap(scope);\n\n      _validateScope(s);\n\n      return expr(s, args, context);\n    }\n\n    return {\n      evaluate\n    };\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  Node.prototype._compile = function (math, argNames) {\n    throw new Error('Method _compile should be implemented by type ' + this.type);\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  Node.prototype.forEach = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run forEach on a Node interface');\n  };\n  /**\n   * Create a new Node having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n\n  Node.prototype.map = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run map on a Node interface');\n  };\n  /**\n   * Validate whether an object is a Node, for use with map\n   * @param {Node} node\n   * @returns {Node} Returns the input if it's a node, else throws an Error\n   * @protected\n   */\n\n\n  Node.prototype._ifNode = function (node) {\n    if (!isNode(node)) {\n      throw new TypeError('Callback function must return a Node');\n    }\n\n    return node;\n  };\n  /**\n   * Recursively traverse all nodes in a node tree. Executes given callback for\n   * this node and each of its child nodes.\n   * @param {function(node: Node, path: string, parent: Node)} callback\n   *          A callback called for every node in the node tree.\n   */\n\n\n  Node.prototype.traverse = function (callback) {\n    // execute callback for itself\n    // eslint-disable-next-line\n    callback(this, null, null); // recursively traverse over all childs of a node\n\n    function _traverse(node, callback) {\n      node.forEach(function (child, path, parent) {\n        callback(child, path, parent);\n\n        _traverse(child, callback);\n      });\n    }\n\n    _traverse(this, callback);\n  };\n  /**\n   * Recursively transform a node tree via a transform function.\n   *\n   * For example, to replace all nodes of type SymbolNode having name 'x' with a\n   * ConstantNode with value 2:\n   *\n   *     const res = Node.transform(function (node, path, parent) {\n   *       if (node && node.isSymbolNode) && (node.name === 'x')) {\n   *         return new ConstantNode(2)\n   *       }\n   *       else {\n   *         return node\n   *       }\n   *     })\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *          A mapping function accepting a node, and returning\n   *          a replacement for the node or the original node.\n   *          Signature: callback(node: Node, index: string, parent: Node) : Node\n   * @return {Node} Returns the original node or its replacement\n   */\n\n\n  Node.prototype.transform = function (callback) {\n    function _transform(child, path, parent) {\n      var replacement = callback(child, path, parent);\n\n      if (replacement !== child) {\n        // stop iterating when the node is replaced\n        return replacement;\n      }\n\n      return child.map(_transform);\n    }\n\n    return _transform(this, null, null);\n  };\n  /**\n   * Find any node in the node tree matching given filter function. For example, to\n   * find all nodes of type SymbolNode having name 'x':\n   *\n   *     const results = Node.filter(function (node) {\n   *       return (node && node.isSymbolNode) && (node.name === 'x')\n   *     })\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *            A test function returning true when a node matches, and false\n   *            otherwise. Function signature:\n   *            callback(node: Node, index: string, parent: Node) : boolean\n   * @return {Node[]} nodes       An array with nodes matching given filter criteria\n   */\n\n\n  Node.prototype.filter = function (callback) {\n    var nodes = [];\n    this.traverse(function (node, path, parent) {\n      if (callback(node, path, parent)) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  };\n  /**\n   * Create a shallow clone of this node\n   * @return {Node}\n   */\n\n\n  Node.prototype.clone = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot clone a Node interface');\n  };\n  /**\n   * Create a deep clone of this node\n   * @return {Node}\n   */\n\n\n  Node.prototype.cloneDeep = function () {\n    return this.map(function (node) {\n      return node.cloneDeep();\n    });\n  };\n  /**\n   * Deep compare this node with another node.\n   * @param {Node} other\n   * @return {boolean} Returns true when both nodes are of the same type and\n   *                   contain the same values (as do their childs)\n   */\n\n\n  Node.prototype.equals = function (other) {\n    return other ? deepStrictEqual(this, other) : false;\n  };\n  /**\n   * Get string representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toString = function (options) {\n    var customString = this._getCustomString(options);\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this._toString(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * Both .toJSON() and the static .fromJSON(json) should be implemented by all\n   * implementations of Node\n   * @returns {Object}\n   */\n\n\n  Node.prototype.toJSON = function () {\n    throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n  };\n  /**\n   * Get HTML representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\" or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toHTML = function (options) {\n    var customString = this._getCustomString(options);\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this.toHTML(options);\n  };\n  /**\n   * Internal function to generate the string output.\n   * This has to be implemented by every Node\n   *\n   * @throws {Error}\n   */\n\n\n  Node.prototype._toString = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toString not implemented for ' + this.type);\n  };\n  /**\n   * Get LaTeX representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toTex = function (options) {\n    var customString = this._getCustomString(options);\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this._toTex(options);\n  };\n  /**\n   * Internal function to generate the LaTeX output.\n   * This has to be implemented by every Node\n   *\n   * @param {Object} [options]\n   * @throws {Error}\n   */\n\n\n  Node.prototype._toTex = function (options) {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toTex not implemented for ' + this.type);\n  };\n  /**\n   * Helper used by `to...` functions.\n   */\n\n\n  Node.prototype._getCustomString = function (options) {\n    if (options && typeof options === 'object') {\n      switch (typeof options.handler) {\n        case 'object':\n        case 'undefined':\n          return;\n\n        case 'function':\n          return options.handler(this, options);\n\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  Node.prototype.getIdentifier = function () {\n    return this.type;\n  };\n  /**\n   * Get the content of the current Node.\n   * @return {Node} node\n   **/\n\n\n  Node.prototype.getContent = function () {\n    return this;\n  };\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n\n\n  function _validateScope(scope) {\n    for (var symbol of [...keywords]) {\n      if (scope.has(symbol)) {\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n      }\n    }\n  }\n\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}