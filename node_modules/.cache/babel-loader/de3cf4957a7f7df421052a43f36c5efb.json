{"ast":null,"code":"import { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!isNode(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!isNode(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!isNode(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isBigNumber","isComplex","isNode","isUnit","typeOf","factory","getPrecedence","name","dependencies","createConditionalNode","_ref","Node","ConditionalNode","condition","trueExpr","falseExpr","SyntaxError","TypeError","prototype","type","isConditionalNode","_compile","math","argNames","evalCondition","evalTrueExpr","evalFalseExpr","evalConditionalNode","scope","args","context","testCondition","forEach","callback","map","_ifNode","clone","_toString","options","parenthesis","precedence","toString","conditionPrecedence","truePrecedence","falsePrecedence","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isZero","re","im","value","undefined","isClass"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js"],"sourcesContent":["import { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!isNode(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!isNode(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!isNode(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}