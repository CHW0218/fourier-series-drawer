{"ast":null,"code":"import { csReach } from './csReach.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'csSpsolve';\nvar dependencies = ['divideScalar', 'multiply', 'subtract'];\nexport var createCsSpsolve = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var divideScalar = _ref.divideScalar,\n      multiply = _ref.multiply,\n      subtract = _ref.subtract;\n  /**\n   * The function csSpsolve() computes the solution to G * x = bk, where bk is the\n   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the\n   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U\n   * is upper triangular with the diagonal entry as the last entry in each column.\n   *\n   * @param {Matrix}  g               The G matrix\n   * @param {Matrix}  b               The B matrix\n   * @param {Number}  k               The kth column in B\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n   * @param {Array}   x               The soluton to the linear system G * x = b\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n   * @param {boolean} lo              The lower (true) upper triangular (false) flag\n   *\n   * @return {Number}                 The index for the nonzero pattern\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csSpsolve(g, b, k, xi, x, pinv, lo) {\n    // g arrays\n    var gvalues = g._values;\n    var gindex = g._index;\n    var gptr = g._ptr;\n    var gsize = g._size; // columns\n\n    var n = gsize[1]; // b arrays\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr; // vars\n\n    var p, p0, p1, q; // xi[top..n-1] = csReach(B(:,k))\n\n    var top = csReach(g, b, k, xi, pinv); // clear x\n\n    for (p = top; p < n; p++) {\n      x[xi[p]] = 0;\n    } // scatter b\n\n\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n      x[bindex[p]] = bvalues[p];\n    } // loop columns\n\n\n    for (var px = top; px < n; px++) {\n      // x array index for px\n      var j = xi[px]; // apply permutation vector (U x = b), j maps to column J of G\n\n      var J = pinv ? pinv[j] : j; // check column J is empty\n\n      if (J < 0) {\n        continue;\n      } // column value indeces in G, p0 <= p < p1\n\n\n      p0 = gptr[J];\n      p1 = gptr[J + 1]; // x(j) /= G(j,j)\n\n      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]); // first entry L(j,j)\n\n      p = lo ? p0 + 1 : p0;\n      q = lo ? p1 : p1 - 1; // loop\n\n      for (; p < q; p++) {\n        // row\n        var i = gindex[p]; // x(i) -= G(i,j) * x(j)\n\n        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));\n      }\n    } // return top of stack\n\n\n    return top;\n  };\n});","map":{"version":3,"names":["csReach","factory","name","dependencies","createCsSpsolve","_ref","divideScalar","multiply","subtract","csSpsolve","g","b","k","xi","x","pinv","lo","gvalues","_values","gindex","_index","gptr","_ptr","gsize","_size","n","bvalues","bindex","bptr","p","p0","p1","q","top","px","j","J","i"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js"],"sourcesContent":["import { csReach } from './csReach.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'csSpsolve';\nvar dependencies = ['divideScalar', 'multiply', 'subtract'];\nexport var createCsSpsolve = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    divideScalar,\n    multiply,\n    subtract\n  } = _ref;\n\n  /**\n   * The function csSpsolve() computes the solution to G * x = bk, where bk is the\n   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the\n   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U\n   * is upper triangular with the diagonal entry as the last entry in each column.\n   *\n   * @param {Matrix}  g               The G matrix\n   * @param {Matrix}  b               The B matrix\n   * @param {Number}  k               The kth column in B\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n   * @param {Array}   x               The soluton to the linear system G * x = b\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n   * @param {boolean} lo              The lower (true) upper triangular (false) flag\n   *\n   * @return {Number}                 The index for the nonzero pattern\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  return function csSpsolve(g, b, k, xi, x, pinv, lo) {\n    // g arrays\n    var gvalues = g._values;\n    var gindex = g._index;\n    var gptr = g._ptr;\n    var gsize = g._size; // columns\n\n    var n = gsize[1]; // b arrays\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr; // vars\n\n    var p, p0, p1, q; // xi[top..n-1] = csReach(B(:,k))\n\n    var top = csReach(g, b, k, xi, pinv); // clear x\n\n    for (p = top; p < n; p++) {\n      x[xi[p]] = 0;\n    } // scatter b\n\n\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n      x[bindex[p]] = bvalues[p];\n    } // loop columns\n\n\n    for (var px = top; px < n; px++) {\n      // x array index for px\n      var j = xi[px]; // apply permutation vector (U x = b), j maps to column J of G\n\n      var J = pinv ? pinv[j] : j; // check column J is empty\n\n      if (J < 0) {\n        continue;\n      } // column value indeces in G, p0 <= p < p1\n\n\n      p0 = gptr[J];\n      p1 = gptr[J + 1]; // x(j) /= G(j,j)\n\n      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]); // first entry L(j,j)\n\n      p = lo ? p0 + 1 : p0;\n      q = lo ? p1 : p1 - 1; // loop\n\n      for (; p < q; p++) {\n        // row\n        var i = gindex[p]; // x(i) -= G(i,j) * x(j)\n\n        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));\n      }\n    } // return top of stack\n\n\n    return top;\n  };\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}