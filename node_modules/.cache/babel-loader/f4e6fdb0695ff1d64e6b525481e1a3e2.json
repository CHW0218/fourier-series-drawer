{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/ayao/vscode/fourier-series-drawer/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n// TODO this could be improved by simplifying seperated constants under associative and commutative operators\nimport { isFraction, isMatrix, isNode, isArrayNode, isConstantNode, isIndexNode, isObjectNode, isOperatorNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { createUtil } from './util.js';\nimport { noBignumber, noFraction } from '../../../utils/noop.js';\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];\nexport var createSimplifyConstant = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      mathWithTransform = _ref.mathWithTransform,\n      matrix = _ref.matrix,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      AccessorNode = _ref.AccessorNode,\n      ArrayNode = _ref.ArrayNode,\n      ConstantNode = _ref.ConstantNode,\n      FunctionNode = _ref.FunctionNode,\n      IndexNode = _ref.IndexNode,\n      ObjectNode = _ref.ObjectNode,\n      OperatorNode = _ref.OperatorNode,\n      SymbolNode = _ref.SymbolNode;\n\n  var _createUtil = createUtil({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      allChildren = _createUtil.allChildren,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n\n  function simplifyConstant(expr, options) {\n    return _ensureNode(foldFraction(expr, options));\n  }\n\n  function _removeFractions(thing) {\n    if (isFraction(thing)) {\n      return thing.valueOf();\n    }\n\n    if (thing instanceof Array) {\n      return thing.map(_removeFractions);\n    }\n\n    if (isMatrix(thing)) {\n      return matrix(_removeFractions(thing.valueOf()));\n    }\n\n    return thing;\n  }\n\n  function _eval(fnname, args, options) {\n    try {\n      return mathWithTransform[fnname].apply(null, args);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(_removeFractions);\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    },\n    string: function string(s) {\n      return new ConstantNode(s);\n    },\n    Matrix: function Matrix(m) {\n      return new ArrayNode(m.valueOf().map(function (e) {\n        return _toNode(e);\n      }));\n    }\n  });\n\n  function _ensureNode(thing) {\n    if (isNode(thing)) {\n      return thing;\n    }\n\n    return _toNode(thing);\n  } // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          noBignumber();\n        }\n\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          noFraction();\n        }\n\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n\n      return _exactFraction(s.re, options);\n    },\n    'Matrix, Object': function MatrixObject(s, options) {\n      return matrix(_exactFraction(s.valueOf()));\n    },\n    'Array, Object': function ArrayObject(s, options) {\n      return s.map(_exactFraction);\n    }\n  });\n\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n\n    if (f.d === 1) {\n      return n;\n    }\n\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */\n\n\n  function _foldAccessor(obj, index, options) {\n    if (!isIndexNode(index)) {\n      // don't know what to do with that...\n      return new AccessorNode(_ensureNode(obj), _ensureNode(index));\n    }\n\n    if (isArrayNode(obj) || isMatrix(obj)) {\n      var remainingDims = Array.from(index.dimensions);\n      /* We will resolve constant indices one at a time, looking\n       * just in the first or second dimensions because (a) arrays\n       * of more than two dimensions are likely rare, and (b) pulling\n       * out the third or higher dimension would be pretty intricate.\n       * The price is that we miss simplifying [..3d array][x,y,1]\n       */\n\n      while (remainingDims.length > 0) {\n        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {\n          var first = _toNumber(remainingDims.shift().value, options);\n\n          if (isArrayNode(obj)) {\n            obj = obj.items[first - 1];\n          } else {\n            // matrix\n            obj = obj.valueOf()[first - 1];\n\n            if (obj instanceof Array) {\n              obj = matrix(obj);\n            }\n          }\n        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {\n          var second = _toNumber(remainingDims[1].value, options);\n\n          var tryItems = [];\n          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();\n\n          var _iterator = _createForOfIteratorHelper(fromItems),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var item = _step.value;\n\n              if (isArrayNode(item)) {\n                tryItems.push(item.items[second - 1]);\n              } else if (isMatrix(obj)) {\n                tryItems.push(item[second - 1]);\n              } else {\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          if (tryItems.length === fromItems.length) {\n            if (isArrayNode(obj)) {\n              obj = new ArrayNode(tryItems);\n            } else {\n              // matrix\n              obj = matrix(tryItems);\n            }\n\n            remainingDims.splice(1, 1);\n          } else {\n            // extracting slice along 2nd dimension failed, give up\n            break;\n          }\n        } else {\n          // neither 1st or 2nd dimension is constant, give up\n          break;\n        }\n      }\n\n      if (remainingDims.length === index.dimensions.length) {\n        /* No successful constant indexing */\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n\n      if (remainingDims.length > 0) {\n        /* Indexed some but not all dimensions */\n        index = new IndexNode(remainingDims);\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      /* All dimensions were constant, access completely resolved */\n\n\n      return obj;\n    }\n\n    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {\n      var key = index.dimensions[0].value;\n\n      if (key in obj.properties) {\n        return obj.properties[key];\n      }\n\n      return new ConstantNode(); // undefined\n    }\n    /* Don't know how to index this sort of obj, at least not with this index */\n\n\n    return new AccessorNode(_ensureNode(obj), index);\n  }\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n\n\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!isNode(a) && !isNode(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!isNode(a)) {\n        a = _toNode(a);\n      } else if (!isNode(b)) {\n        b = _toNode(b);\n      }\n\n      return makeNode([a, b]);\n    });\n  } // destroys the original node and returns a folded one\n\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n\n      case 'ConstantNode':\n        switch (typeof node.value) {\n          case 'number':\n            return _toNumber(node.value, options);\n\n          case 'string':\n            return node.value;\n\n          default:\n            if (!isNaN(node.value)) return _toNumber(node.value, options);\n        }\n\n        return node;\n\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            }); // If all args are numbers\n\n            if (!args.some(isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontinue) {}\n            } // Size of a matrix does not depend on entries\n\n\n            if (node.name === 'size' && args.length === 1 && isArrayNode(args[0])) {\n              var sz = [];\n              var section = args[0];\n\n              while (isArrayNode(section)) {\n                sz.push(section.items.length);\n                section = section.items[0];\n              }\n\n              return matrix(sz);\n            } // Convert all args to nodes and construct a symbolic function call\n\n\n            return new FunctionNode(node.name, args.map(_ensureNode));\n          } else {// treat as operator\n          }\n        }\n\n      /* falls through */\n\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n\n          var _args;\n\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n\n          if (isOperatorNode(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n\n            if (!isNode(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node, options.context)) {\n            _args = allChildren(node, options.context);\n            _args = _args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n\n            if (isCommutative(fn, options.context)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n\n              for (var i = 0; i < _args.length; i++) {\n                if (!isNode(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            res = foldOp(fn, _args, makeNode, options);\n          }\n\n          return res;\n        }\n\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n\n      case 'AccessorNode':\n        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);\n\n      case 'ArrayNode':\n        {\n          var foldItems = node.items.map(function (item) {\n            return foldFraction(item, options);\n          });\n\n          if (foldItems.some(isNode)) {\n            return new ArrayNode(foldItems.map(_ensureNode));\n          }\n          /* All literals -- return a Matrix so we can operate on it */\n\n\n          return matrix(foldItems);\n        }\n\n      case 'IndexNode':\n        {\n          return new IndexNode(node.dimensions.map(function (n) {\n            return simplifyConstant(n, options);\n          }));\n        }\n\n      case 'ObjectNode':\n        {\n          var foldProps = {};\n\n          for (var prop in node.properties) {\n            foldProps[prop] = simplifyConstant(node.properties[prop], options);\n          }\n\n          return new ObjectNode(foldProps);\n        }\n\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n\n  return simplifyConstant;\n});","map":{"version":3,"names":["isFraction","isMatrix","isNode","isArrayNode","isConstantNode","isIndexNode","isObjectNode","isOperatorNode","factory","createUtil","noBignumber","noFraction","name","dependencies","createSimplifyConstant","_ref","typed","config","mathWithTransform","matrix","fraction","bignumber","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","SymbolNode","isCommutative","isAssociative","allChildren","createMakeNodeFunction","simplifyConstant","expr","options","_ensureNode","foldFraction","_removeFractions","thing","valueOf","Array","map","_eval","fnname","args","apply","ignore","_toNumber","_toNode","Fraction","_fractionToNode","number","n","unaryMinusNode","BigNumber","Complex","s","Error","string","Matrix","m","e","_exactFraction","exactFractions","isFinite","f","fractionsLimit","Infinity","d","stringObject","undefined","parseFloat","FractionObject","BigNumberObject","numberObject","ComplexObject","im","re","MatrixObject","ArrayObject","vn","_foldAccessor","obj","index","remainingDims","from","dimensions","length","value","first","shift","items","second","tryItems","fromItems","item","push","splice","key","properties","foldOp","fn","makeNode","reduce","a","b","ignoreandcontinue","node","type","isNaN","rawArgs","operatorFunctions","indexOf","arg","some","sz","section","toString","_args","res","isUnary","context","consts","vars","i","unshift","content","object","foldItems","foldProps","prop","concat"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/algebra/simplify/simplifyConstant.js"],"sourcesContent":["// TODO this could be improved by simplifying seperated constants under associative and commutative operators\nimport { isFraction, isMatrix, isNode, isArrayNode, isConstantNode, isIndexNode, isObjectNode, isOperatorNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { createUtil } from './util.js';\nimport { noBignumber, noFraction } from '../../../utils/noop.js';\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];\nexport var createSimplifyConstant = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    mathWithTransform,\n    matrix,\n    fraction,\n    bignumber,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref;\n  var {\n    isCommutative,\n    isAssociative,\n    allChildren,\n    createMakeNodeFunction\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n\n  function simplifyConstant(expr, options) {\n    return _ensureNode(foldFraction(expr, options));\n  }\n\n  function _removeFractions(thing) {\n    if (isFraction(thing)) {\n      return thing.valueOf();\n    }\n\n    if (thing instanceof Array) {\n      return thing.map(_removeFractions);\n    }\n\n    if (isMatrix(thing)) {\n      return matrix(_removeFractions(thing.valueOf()));\n    }\n\n    return thing;\n  }\n\n  function _eval(fnname, args, options) {\n    try {\n      return mathWithTransform[fnname].apply(null, args);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(_removeFractions);\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    },\n    string: function string(s) {\n      return new ConstantNode(s);\n    },\n    Matrix: function Matrix(m) {\n      return new ArrayNode(m.valueOf().map(e => _toNode(e)));\n    }\n  });\n\n  function _ensureNode(thing) {\n    if (isNode(thing)) {\n      return thing;\n    }\n\n    return _toNode(thing);\n  } // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          noBignumber();\n        }\n\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          noFraction();\n        }\n\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n\n      return _exactFraction(s.re, options);\n    },\n    'Matrix, Object': function MatrixObject(s, options) {\n      return matrix(_exactFraction(s.valueOf()));\n    },\n    'Array, Object': function ArrayObject(s, options) {\n      return s.map(_exactFraction);\n    }\n  });\n\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n\n    if (f.d === 1) {\n      return n;\n    }\n\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */\n\n\n  function _foldAccessor(obj, index, options) {\n    if (!isIndexNode(index)) {\n      // don't know what to do with that...\n      return new AccessorNode(_ensureNode(obj), _ensureNode(index));\n    }\n\n    if (isArrayNode(obj) || isMatrix(obj)) {\n      var remainingDims = Array.from(index.dimensions);\n      /* We will resolve constant indices one at a time, looking\n       * just in the first or second dimensions because (a) arrays\n       * of more than two dimensions are likely rare, and (b) pulling\n       * out the third or higher dimension would be pretty intricate.\n       * The price is that we miss simplifying [..3d array][x,y,1]\n       */\n\n      while (remainingDims.length > 0) {\n        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {\n          var first = _toNumber(remainingDims.shift().value, options);\n\n          if (isArrayNode(obj)) {\n            obj = obj.items[first - 1];\n          } else {\n            // matrix\n            obj = obj.valueOf()[first - 1];\n\n            if (obj instanceof Array) {\n              obj = matrix(obj);\n            }\n          }\n        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {\n          var second = _toNumber(remainingDims[1].value, options);\n\n          var tryItems = [];\n          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();\n\n          for (var item of fromItems) {\n            if (isArrayNode(item)) {\n              tryItems.push(item.items[second - 1]);\n            } else if (isMatrix(obj)) {\n              tryItems.push(item[second - 1]);\n            } else {\n              break;\n            }\n          }\n\n          if (tryItems.length === fromItems.length) {\n            if (isArrayNode(obj)) {\n              obj = new ArrayNode(tryItems);\n            } else {\n              // matrix\n              obj = matrix(tryItems);\n            }\n\n            remainingDims.splice(1, 1);\n          } else {\n            // extracting slice along 2nd dimension failed, give up\n            break;\n          }\n        } else {\n          // neither 1st or 2nd dimension is constant, give up\n          break;\n        }\n      }\n\n      if (remainingDims.length === index.dimensions.length) {\n        /* No successful constant indexing */\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n\n      if (remainingDims.length > 0) {\n        /* Indexed some but not all dimensions */\n        index = new IndexNode(remainingDims);\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      /* All dimensions were constant, access completely resolved */\n\n\n      return obj;\n    }\n\n    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {\n      var key = index.dimensions[0].value;\n\n      if (key in obj.properties) {\n        return obj.properties[key];\n      }\n\n      return new ConstantNode(); // undefined\n    }\n    /* Don't know how to index this sort of obj, at least not with this index */\n\n\n    return new AccessorNode(_ensureNode(obj), index);\n  }\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n\n\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!isNode(a) && !isNode(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!isNode(a)) {\n        a = _toNode(a);\n      } else if (!isNode(b)) {\n        b = _toNode(b);\n      }\n\n      return makeNode([a, b]);\n    });\n  } // destroys the original node and returns a folded one\n\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n\n      case 'ConstantNode':\n        switch (typeof node.value) {\n          case 'number':\n            return _toNumber(node.value, options);\n\n          case 'string':\n            return node.value;\n\n          default:\n            if (!isNaN(node.value)) return _toNumber(node.value, options);\n        }\n\n        return node;\n\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(arg => foldFraction(arg, options)); // If all args are numbers\n\n            if (!args.some(isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontinue) {}\n            } // Size of a matrix does not depend on entries\n\n\n            if (node.name === 'size' && args.length === 1 && isArrayNode(args[0])) {\n              var sz = [];\n              var section = args[0];\n\n              while (isArrayNode(section)) {\n                sz.push(section.items.length);\n                section = section.items[0];\n              }\n\n              return matrix(sz);\n            } // Convert all args to nodes and construct a symbolic function call\n\n\n            return new FunctionNode(node.name, args.map(_ensureNode));\n          } else {// treat as operator\n          }\n        }\n\n      /* falls through */\n\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n\n          var _args;\n\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n\n          if (isOperatorNode(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n\n            if (!isNode(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node, options.context)) {\n            _args = allChildren(node, options.context);\n            _args = _args.map(arg => foldFraction(arg, options));\n\n            if (isCommutative(fn, options.context)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n\n              for (var i = 0; i < _args.length; i++) {\n                if (!isNode(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(arg => foldFraction(arg, options));\n            res = foldOp(fn, _args, makeNode, options);\n          }\n\n          return res;\n        }\n\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n\n      case 'AccessorNode':\n        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);\n\n      case 'ArrayNode':\n        {\n          var foldItems = node.items.map(item => foldFraction(item, options));\n\n          if (foldItems.some(isNode)) {\n            return new ArrayNode(foldItems.map(_ensureNode));\n          }\n          /* All literals -- return a Matrix so we can operate on it */\n\n\n          return matrix(foldItems);\n        }\n\n      case 'IndexNode':\n        {\n          return new IndexNode(node.dimensions.map(n => simplifyConstant(n, options)));\n        }\n\n      case 'ObjectNode':\n        {\n          var foldProps = {};\n\n          for (var prop in node.properties) {\n            foldProps[prop] = simplifyConstant(node.properties[prop], options);\n          }\n\n          return new ObjectNode(foldProps);\n        }\n\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n\n  return simplifyConstant;\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}