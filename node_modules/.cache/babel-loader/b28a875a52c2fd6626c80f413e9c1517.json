{"ast":null,"code":"import { isSparseMatrix } from '../../utils/is.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'expm';\nvar dependencies = ['typed', 'abs', 'add', 'identity', 'inv', 'multiply'];\nexport var createExpm = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      add = _ref.add,\n      identity = _ref.identity,\n      inv = _ref.inv,\n      multiply = _ref.multiply;\n  /**\n   * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.\n   * Not to be confused with exp(a), which performs element-wise\n   * exponentiation.\n   *\n   * The exponential is calculated using the Padé approximant with scaling and\n   * squaring; see \"Nineteen Dubious Ways to Compute the Exponential of a\n   * Matrix,\" by Moler and Van Loan.\n   *\n   * Syntax:\n   *\n   *     math.expm(x)\n   *\n   * Examples:\n   *\n   *     const A = [[0,2],[0,0]]\n   *     math.expm(A)        // returns [[1,2],[0,1]]\n   *\n   * See also:\n   *\n   *     exp\n   *\n   * @param {Matrix} x  A square Matrix\n   * @return {Matrix}   The exponential of x\n   */\n\n  return typed(name, {\n    Matrix: function Matrix(A) {\n      // Check matrix size\n      var size = A.size();\n\n      if (size.length !== 2 || size[0] !== size[1]) {\n        throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n      }\n\n      var n = size[0]; // Desired accuracy of the approximant (The actual accuracy\n      // will be affected by round-off error)\n\n      var eps = 1e-15; // The Padé approximant is not so accurate when the values of A\n      // are \"large\", so scale A by powers of two. Then compute the\n      // exponential, and square the result repeatedly according to\n      // the identity e^A = (e^(A/m))^m\n      // Compute infinity-norm of A, ||A||, to see how \"big\" it is\n\n      var infNorm = infinityNorm(A); // Find the optimal scaling factor and number of terms in the\n      // Padé approximant to reach the desired accuracy\n\n      var params = findParams(infNorm, eps);\n      var q = params.q;\n      var j = params.j; // The Pade approximation to e^A is:\n      // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)\n      // where\n      // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i\n      // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i\n      // Scale A by 1 / 2^j\n\n      var Apos = multiply(A, Math.pow(2, -j)); // The i=0 term is just the identity matrix\n\n      var N = identity(n);\n      var D = identity(n); // Initialization (i=0)\n\n      var factor = 1; // Initialization (i=1)\n\n      var AposToI = Apos; // Cloning not necessary\n\n      var alternate = -1;\n\n      for (var i = 1; i <= q; i++) {\n        if (i > 1) {\n          AposToI = multiply(AposToI, Apos);\n          alternate = -alternate;\n        }\n\n        factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);\n        N = add(N, multiply(factor, AposToI));\n        D = add(D, multiply(factor * alternate, AposToI));\n      }\n\n      var R = multiply(inv(D), N); // Square j times\n\n      for (var _i = 0; _i < j; _i++) {\n        R = multiply(R, R);\n      }\n\n      return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;\n    }\n  });\n\n  function infinityNorm(A) {\n    var n = A.size()[0];\n    var infNorm = 0;\n\n    for (var i = 0; i < n; i++) {\n      var rowSum = 0;\n\n      for (var j = 0; j < n; j++) {\n        rowSum += abs(A.get([i, j]));\n      }\n\n      infNorm = Math.max(rowSum, infNorm);\n    }\n\n    return infNorm;\n  }\n  /**\n   * Find the best parameters for the Pade approximant given\n   * the matrix norm and desired accuracy. Returns the first acceptable\n   * combination in order of increasing computational load.\n   */\n\n\n  function findParams(infNorm, eps) {\n    var maxSearchSize = 30;\n\n    for (var k = 0; k < maxSearchSize; k++) {\n      for (var q = 0; q <= k; q++) {\n        var j = k - q;\n\n        if (errorEstimate(infNorm, q, j) < eps) {\n          return {\n            q: q,\n            j: j\n          };\n        }\n      }\n    }\n\n    throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');\n  }\n  /**\n   * Returns the estimated error of the Pade approximant for the given\n   * parameters.\n   */\n\n\n  function errorEstimate(infNorm, q, j) {\n    var qfac = 1;\n\n    for (var i = 2; i <= q; i++) {\n      qfac *= i;\n    }\n\n    var twoqfac = qfac;\n\n    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {\n      twoqfac *= _i2;\n    }\n\n    var twoqp1fac = twoqfac * (2 * q + 1);\n    return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);\n  }\n});","map":{"version":3,"names":["isSparseMatrix","format","factory","name","dependencies","createExpm","_ref","typed","abs","add","identity","inv","multiply","Matrix","A","size","length","RangeError","n","eps","infNorm","infinityNorm","params","findParams","q","j","Apos","Math","pow","N","D","factor","AposToI","alternate","i","R","_i","createSparseMatrix","rowSum","get","max","maxSearchSize","k","errorEstimate","Error","qfac","twoqfac","_i2","twoqp1fac"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/matrix/expm.js"],"sourcesContent":["import { isSparseMatrix } from '../../utils/is.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'expm';\nvar dependencies = ['typed', 'abs', 'add', 'identity', 'inv', 'multiply'];\nexport var createExpm = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    abs,\n    add,\n    identity,\n    inv,\n    multiply\n  } = _ref;\n\n  /**\n   * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.\n   * Not to be confused with exp(a), which performs element-wise\n   * exponentiation.\n   *\n   * The exponential is calculated using the Padé approximant with scaling and\n   * squaring; see \"Nineteen Dubious Ways to Compute the Exponential of a\n   * Matrix,\" by Moler and Van Loan.\n   *\n   * Syntax:\n   *\n   *     math.expm(x)\n   *\n   * Examples:\n   *\n   *     const A = [[0,2],[0,0]]\n   *     math.expm(A)        // returns [[1,2],[0,1]]\n   *\n   * See also:\n   *\n   *     exp\n   *\n   * @param {Matrix} x  A square Matrix\n   * @return {Matrix}   The exponential of x\n   */\n  return typed(name, {\n    Matrix: function Matrix(A) {\n      // Check matrix size\n      var size = A.size();\n\n      if (size.length !== 2 || size[0] !== size[1]) {\n        throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n      }\n\n      var n = size[0]; // Desired accuracy of the approximant (The actual accuracy\n      // will be affected by round-off error)\n\n      var eps = 1e-15; // The Padé approximant is not so accurate when the values of A\n      // are \"large\", so scale A by powers of two. Then compute the\n      // exponential, and square the result repeatedly according to\n      // the identity e^A = (e^(A/m))^m\n      // Compute infinity-norm of A, ||A||, to see how \"big\" it is\n\n      var infNorm = infinityNorm(A); // Find the optimal scaling factor and number of terms in the\n      // Padé approximant to reach the desired accuracy\n\n      var params = findParams(infNorm, eps);\n      var q = params.q;\n      var j = params.j; // The Pade approximation to e^A is:\n      // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)\n      // where\n      // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i\n      // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i\n      // Scale A by 1 / 2^j\n\n      var Apos = multiply(A, Math.pow(2, -j)); // The i=0 term is just the identity matrix\n\n      var N = identity(n);\n      var D = identity(n); // Initialization (i=0)\n\n      var factor = 1; // Initialization (i=1)\n\n      var AposToI = Apos; // Cloning not necessary\n\n      var alternate = -1;\n\n      for (var i = 1; i <= q; i++) {\n        if (i > 1) {\n          AposToI = multiply(AposToI, Apos);\n          alternate = -alternate;\n        }\n\n        factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);\n        N = add(N, multiply(factor, AposToI));\n        D = add(D, multiply(factor * alternate, AposToI));\n      }\n\n      var R = multiply(inv(D), N); // Square j times\n\n      for (var _i = 0; _i < j; _i++) {\n        R = multiply(R, R);\n      }\n\n      return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;\n    }\n  });\n\n  function infinityNorm(A) {\n    var n = A.size()[0];\n    var infNorm = 0;\n\n    for (var i = 0; i < n; i++) {\n      var rowSum = 0;\n\n      for (var j = 0; j < n; j++) {\n        rowSum += abs(A.get([i, j]));\n      }\n\n      infNorm = Math.max(rowSum, infNorm);\n    }\n\n    return infNorm;\n  }\n  /**\n   * Find the best parameters for the Pade approximant given\n   * the matrix norm and desired accuracy. Returns the first acceptable\n   * combination in order of increasing computational load.\n   */\n\n\n  function findParams(infNorm, eps) {\n    var maxSearchSize = 30;\n\n    for (var k = 0; k < maxSearchSize; k++) {\n      for (var q = 0; q <= k; q++) {\n        var j = k - q;\n\n        if (errorEstimate(infNorm, q, j) < eps) {\n          return {\n            q,\n            j\n          };\n        }\n      }\n    }\n\n    throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');\n  }\n  /**\n   * Returns the estimated error of the Pade approximant for the given\n   * parameters.\n   */\n\n\n  function errorEstimate(infNorm, q, j) {\n    var qfac = 1;\n\n    for (var i = 2; i <= q; i++) {\n      qfac *= i;\n    }\n\n    var twoqfac = qfac;\n\n    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {\n      twoqfac *= _i2;\n    }\n\n    var twoqp1fac = twoqfac * (2 * q + 1);\n    return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);\n  }\n});"],"mappings":"AAAA,SAASA,cAAT,QAA+B,mBAA/B;AACA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,IAAIC,IAAI,GAAG,MAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,KAAV,EAAiB,KAAjB,EAAwB,UAAxB,EAAoC,KAApC,EAA2C,UAA3C,CAAnB;AACA,OAAO,IAAIC,UAAU,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqB,UAAAE,IAAI,EAAI;EACzE,IACEC,KADF,GAOID,IAPJ,CACEC,KADF;EAAA,IAEEC,GAFF,GAOIF,IAPJ,CAEEE,GAFF;EAAA,IAGEC,GAHF,GAOIH,IAPJ,CAGEG,GAHF;EAAA,IAIEC,QAJF,GAOIJ,IAPJ,CAIEI,QAJF;EAAA,IAKEC,GALF,GAOIL,IAPJ,CAKEK,GALF;EAAA,IAMEC,QANF,GAOIN,IAPJ,CAMEM,QANF;EASA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,OAAOL,KAAK,CAACJ,IAAD,EAAO;IACjBU,MAAM,EAAE,SAASA,MAAT,CAAgBC,CAAhB,EAAmB;MACzB;MACA,IAAIC,IAAI,GAAGD,CAAC,CAACC,IAAF,EAAX;;MAEA,IAAIA,IAAI,CAACC,MAAL,KAAgB,CAAhB,IAAqBD,IAAI,CAAC,CAAD,CAAJ,KAAYA,IAAI,CAAC,CAAD,CAAzC,EAA8C;QAC5C,MAAM,IAAIE,UAAJ,CAAe,2BAA2B,SAA3B,GAAuChB,MAAM,CAACc,IAAD,CAA7C,GAAsD,GAArE,CAAN;MACD;;MAED,IAAIG,CAAC,GAAGH,IAAI,CAAC,CAAD,CAAZ,CARyB,CAQR;MACjB;;MAEA,IAAII,GAAG,GAAG,KAAV,CAXyB,CAWR;MACjB;MACA;MACA;MACA;;MAEA,IAAIC,OAAO,GAAGC,YAAY,CAACP,CAAD,CAA1B,CAjByB,CAiBM;MAC/B;;MAEA,IAAIQ,MAAM,GAAGC,UAAU,CAACH,OAAD,EAAUD,GAAV,CAAvB;MACA,IAAIK,CAAC,GAAGF,MAAM,CAACE,CAAf;MACA,IAAIC,CAAC,GAAGH,MAAM,CAACG,CAAf,CAtByB,CAsBP;MAClB;MACA;MACA;MACA;MACA;;MAEA,IAAIC,IAAI,GAAGd,QAAQ,CAACE,CAAD,EAAIa,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,CAACH,CAAb,CAAJ,CAAnB,CA7ByB,CA6BgB;;MAEzC,IAAII,CAAC,GAAGnB,QAAQ,CAACQ,CAAD,CAAhB;MACA,IAAIY,CAAC,GAAGpB,QAAQ,CAACQ,CAAD,CAAhB,CAhCyB,CAgCJ;;MAErB,IAAIa,MAAM,GAAG,CAAb,CAlCyB,CAkCT;;MAEhB,IAAIC,OAAO,GAAGN,IAAd,CApCyB,CAoCL;;MAEpB,IAAIO,SAAS,GAAG,CAAC,CAAjB;;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIV,CAArB,EAAwBU,CAAC,EAAzB,EAA6B;QAC3B,IAAIA,CAAC,GAAG,CAAR,EAAW;UACTF,OAAO,GAAGpB,QAAQ,CAACoB,OAAD,EAAUN,IAAV,CAAlB;UACAO,SAAS,GAAG,CAACA,SAAb;QACD;;QAEDF,MAAM,GAAGA,MAAM,IAAIP,CAAC,GAAGU,CAAJ,GAAQ,CAAZ,CAAN,IAAwB,CAAC,IAAIV,CAAJ,GAAQU,CAAR,GAAY,CAAb,IAAkBA,CAA1C,CAAT;QACAL,CAAC,GAAGpB,GAAG,CAACoB,CAAD,EAAIjB,QAAQ,CAACmB,MAAD,EAASC,OAAT,CAAZ,CAAP;QACAF,CAAC,GAAGrB,GAAG,CAACqB,CAAD,EAAIlB,QAAQ,CAACmB,MAAM,GAAGE,SAAV,EAAqBD,OAArB,CAAZ,CAAP;MACD;;MAED,IAAIG,CAAC,GAAGvB,QAAQ,CAACD,GAAG,CAACmB,CAAD,CAAJ,EAASD,CAAT,CAAhB,CAnDyB,CAmDI;;MAE7B,KAAK,IAAIO,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGX,CAAtB,EAAyBW,EAAE,EAA3B,EAA+B;QAC7BD,CAAC,GAAGvB,QAAQ,CAACuB,CAAD,EAAIA,CAAJ,CAAZ;MACD;;MAED,OAAOnC,cAAc,CAACc,CAAD,CAAd,GAAoBA,CAAC,CAACuB,kBAAF,CAAqBF,CAArB,CAApB,GAA8CA,CAArD;IACD;EA3DgB,CAAP,CAAZ;;EA8DA,SAASd,YAAT,CAAsBP,CAAtB,EAAyB;IACvB,IAAII,CAAC,GAAGJ,CAAC,CAACC,IAAF,GAAS,CAAT,CAAR;IACA,IAAIK,OAAO,GAAG,CAAd;;IAEA,KAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,CAApB,EAAuBgB,CAAC,EAAxB,EAA4B;MAC1B,IAAII,MAAM,GAAG,CAAb;;MAEA,KAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,CAApB,EAAuBO,CAAC,EAAxB,EAA4B;QAC1Ba,MAAM,IAAI9B,GAAG,CAACM,CAAC,CAACyB,GAAF,CAAM,CAACL,CAAD,EAAIT,CAAJ,CAAN,CAAD,CAAb;MACD;;MAEDL,OAAO,GAAGO,IAAI,CAACa,GAAL,CAASF,MAAT,EAAiBlB,OAAjB,CAAV;IACD;;IAED,OAAOA,OAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAASG,UAAT,CAAoBH,OAApB,EAA6BD,GAA7B,EAAkC;IAChC,IAAIsB,aAAa,GAAG,EAApB;;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,aAApB,EAAmCC,CAAC,EAApC,EAAwC;MACtC,KAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIkB,CAArB,EAAwBlB,CAAC,EAAzB,EAA6B;QAC3B,IAAIC,CAAC,GAAGiB,CAAC,GAAGlB,CAAZ;;QAEA,IAAImB,aAAa,CAACvB,OAAD,EAAUI,CAAV,EAAaC,CAAb,CAAb,GAA+BN,GAAnC,EAAwC;UACtC,OAAO;YACLK,CAAC,EAADA,CADK;YAELC,CAAC,EAADA;UAFK,CAAP;QAID;MACF;IACF;;IAED,MAAM,IAAImB,KAAJ,CAAU,kHAAV,CAAN;EACD;EACD;AACF;AACA;AACA;;;EAGE,SAASD,aAAT,CAAuBvB,OAAvB,EAAgCI,CAAhC,EAAmCC,CAAnC,EAAsC;IACpC,IAAIoB,IAAI,GAAG,CAAX;;IAEA,KAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIV,CAArB,EAAwBU,CAAC,EAAzB,EAA6B;MAC3BW,IAAI,IAAIX,CAAR;IACD;;IAED,IAAIY,OAAO,GAAGD,IAAd;;IAEA,KAAK,IAAIE,GAAG,GAAGvB,CAAC,GAAG,CAAnB,EAAsBuB,GAAG,IAAI,IAAIvB,CAAjC,EAAoCuB,GAAG,EAAvC,EAA2C;MACzCD,OAAO,IAAIC,GAAX;IACD;;IAED,IAAIC,SAAS,GAAGF,OAAO,IAAI,IAAItB,CAAJ,GAAQ,CAAZ,CAAvB;IACA,OAAO,MAAMG,IAAI,CAACC,GAAL,CAASR,OAAO,GAAGO,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,CAAZ,CAAnB,EAAmC,IAAID,CAAvC,CAAN,GAAkDqB,IAAlD,GAAyDA,IAAzD,IAAiEC,OAAO,GAAGE,SAA3E,CAAP;EACD;AACF,CAhK6C,CAAvC"},"metadata":{},"sourceType":"module"}