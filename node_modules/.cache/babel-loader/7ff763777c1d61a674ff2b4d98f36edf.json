{"ast":null,"code":"import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'divideScalar', 'isZero', 'unaryMinus'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divideScalar = _ref.divideScalar,\n      isZero = _ref.isZero,\n      unaryMinus = _ref.unaryMinus;\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n\n        case 2:\n          {\n            // two dimensional array\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Bareiss algorithm\n      // this algorithm have same complexity as LUP decomposition (O(n^3))\n      // but it preserve precision of floating point more relative to the LUP decomposition\n      var negated = false;\n      var rowIndices = new Array(rows).fill(0).map(function (_, i) {\n        return i;\n      }); // matrix index of row i\n\n      for (var k = 0; k < rows; k++) {\n        var k_ = rowIndices[k];\n\n        if (isZero(matrix[k_][k])) {\n          var _k = void 0;\n\n          for (_k = k + 1; _k < rows; _k++) {\n            if (!isZero(matrix[rowIndices[_k]][k])) {\n              k_ = rowIndices[_k];\n              rowIndices[_k] = rowIndices[k];\n              rowIndices[k] = k_;\n              negated = !negated;\n              break;\n            }\n          }\n\n          if (_k === rows) return matrix[k_][k]; // some zero of the type\n        }\n\n        var piv = matrix[k_][k];\n        var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];\n\n        for (var i = k + 1; i < rows; i++) {\n          var i_ = rowIndices[i];\n\n          for (var j = k + 1; j < rows; j++) {\n            matrix[i_][j] = divideScalar(subtract(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);\n          }\n        }\n      }\n\n      var det = matrix[rowIndices[rows - 1]][rows - 1];\n      return negated ? unaryMinus(det) : det;\n    }\n  }\n});","map":{"version":3,"names":["isMatrix","clone","format","factory","name","dependencies","createDet","_ref","typed","matrix","subtract","multiply","divideScalar","isZero","unaryMinus","any","x","det","size","Array","isArray","length","valueOf","RangeError","rows","cols","_det","negated","rowIndices","fill","map","_","i","k","k_","_k","piv","piv_","i_","j"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/matrix/det.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'divideScalar', 'isZero', 'unaryMinus'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    multiply,\n    divideScalar,\n    isZero,\n    unaryMinus\n  } = _ref;\n\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n\n        case 2:\n          {\n            // two dimensional array\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Bareiss algorithm\n      // this algorithm have same complexity as LUP decomposition (O(n^3))\n      // but it preserve precision of floating point more relative to the LUP decomposition\n      var negated = false;\n      var rowIndices = new Array(rows).fill(0).map((_, i) => i); // matrix index of row i\n\n      for (var k = 0; k < rows; k++) {\n        var k_ = rowIndices[k];\n\n        if (isZero(matrix[k_][k])) {\n          var _k = void 0;\n\n          for (_k = k + 1; _k < rows; _k++) {\n            if (!isZero(matrix[rowIndices[_k]][k])) {\n              k_ = rowIndices[_k];\n              rowIndices[_k] = rowIndices[k];\n              rowIndices[k] = k_;\n              negated = !negated;\n              break;\n            }\n          }\n\n          if (_k === rows) return matrix[k_][k]; // some zero of the type\n        }\n\n        var piv = matrix[k_][k];\n        var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];\n\n        for (var i = k + 1; i < rows; i++) {\n          var i_ = rowIndices[i];\n\n          for (var j = k + 1; j < rows; j++) {\n            matrix[i_][j] = divideScalar(subtract(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);\n          }\n        }\n      }\n\n      var det = matrix[rowIndices[rows - 1]][rows - 1];\n      return negated ? unaryMinus(det) : det;\n    }\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}