{"ast":null,"code":"import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\nimport { createUtil } from './simplify/util.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var equal = _ref.equal,\n      isZero = _ref.isZero,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      AccessorNode = _ref.AccessorNode,\n      ArrayNode = _ref.ArrayNode,\n      ConstantNode = _ref.ConstantNode,\n      FunctionNode = _ref.FunctionNode,\n      IndexNode = _ref.IndexNode,\n      ObjectNode = _ref.ObjectNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      SymbolNode = _ref.SymbolNode;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n\n  var _createUtil = createUtil({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      hasProperty = _createUtil.hasProperty,\n      isCommutative = _createUtil.isCommutative;\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     simplify, resolve, derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with basic simplifications applied\n   */\n\n\n  function simplifyCore(node, options) {\n    var context = options ? options.context : undefined;\n\n    if (hasProperty(node, 'trivial', context)) {\n      // This node does nothing if it has only one argument, so if so,\n      // return that argument simplified\n      if (isFunctionNode(node) && node.args.length === 1) {\n        return simplifyCore(node.args[0], options);\n      } // For other node types, we try the generic methods\n\n\n      var simpChild = false;\n      var childCount = 0;\n      node.forEach(function (c) {\n        ++childCount;\n\n        if (childCount === 1) {\n          simpChild = simplifyCore(c, options);\n        }\n      });\n\n      if (childCount === 1) {\n        return simpChild;\n      }\n    }\n\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0], options);\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0], options);\n\n      var a1 = simplifyCore(node.args[1], options);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op && isCommutative(node, context)) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          if (isCommutative(node, context)) {\n            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n          } else {\n            return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n      }\n\n      return new OperatorNode(node.op, node.fn, [_a, a1]);\n    } else if (isFunctionNode(node)) {\n      return new FunctionNode(simplifyCore(node.fn), node.args.map(function (n) {\n        return simplifyCore(n, options);\n      }));\n    } else if (isArrayNode(node)) {\n      return new ArrayNode(node.items.map(function (n) {\n        return simplifyCore(n, options);\n      }));\n    } else if (isAccessorNode(node)) {\n      return new AccessorNode(simplifyCore(node.object, options), simplifyCore(node.index, options));\n    } else if (isIndexNode(node)) {\n      return new IndexNode(node.dimensions.map(function (n) {\n        return simplifyCore(n, options);\n      }));\n    } else if (isObjectNode(node)) {\n      var newProps = {};\n\n      for (var prop in node.properties) {\n        newProps[prop] = simplifyCore(node.properties[prop], options);\n      }\n\n      return new ObjectNode(newProps);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});","map":{"version":3,"names":["isAccessorNode","isArrayNode","isConstantNode","isFunctionNode","isIndexNode","isObjectNode","isOperatorNode","createUtil","factory","name","dependencies","createSimplifyCore","_ref","equal","isZero","add","subtract","multiply","divide","pow","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode","node0","node1","hasProperty","isCommutative","simplifyCore","node","options","context","undefined","args","length","simpChild","childCount","forEach","c","isUnary","a0","op","isBinary","fn","_a","a1","value","a00","a00a1","implicit","a01","map","n","items","object","index","dimensions","newProps","prop","properties"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js"],"sourcesContent":["import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\nimport { createUtil } from './simplify/util.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  var {\n    hasProperty,\n    isCommutative\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     simplify, resolve, derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with basic simplifications applied\n   */\n\n  function simplifyCore(node, options) {\n    var context = options ? options.context : undefined;\n\n    if (hasProperty(node, 'trivial', context)) {\n      // This node does nothing if it has only one argument, so if so,\n      // return that argument simplified\n      if (isFunctionNode(node) && node.args.length === 1) {\n        return simplifyCore(node.args[0], options);\n      } // For other node types, we try the generic methods\n\n\n      var simpChild = false;\n      var childCount = 0;\n      node.forEach(c => {\n        ++childCount;\n\n        if (childCount === 1) {\n          simpChild = simplifyCore(c, options);\n        }\n      });\n\n      if (childCount === 1) {\n        return simpChild;\n      }\n    }\n\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0], options);\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0], options);\n\n      var a1 = simplifyCore(node.args[1], options);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op && isCommutative(node, context)) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          if (isCommutative(node, context)) {\n            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n          } else {\n            return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n      }\n\n      return new OperatorNode(node.op, node.fn, [_a, a1]);\n    } else if (isFunctionNode(node)) {\n      return new FunctionNode(simplifyCore(node.fn), node.args.map(n => simplifyCore(n, options)));\n    } else if (isArrayNode(node)) {\n      return new ArrayNode(node.items.map(n => simplifyCore(n, options)));\n    } else if (isAccessorNode(node)) {\n      return new AccessorNode(simplifyCore(node.object, options), simplifyCore(node.index, options));\n    } else if (isIndexNode(node)) {\n      return new IndexNode(node.dimensions.map(n => simplifyCore(n, options)));\n    } else if (isObjectNode(node)) {\n      var newProps = {};\n\n      for (var prop in node.properties) {\n        newProps[prop] = simplifyCore(node.properties[prop], options);\n      }\n\n      return new ObjectNode(newProps);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}