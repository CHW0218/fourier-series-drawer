{"ast":null,"code":"import { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { toSymbol } from '../../utils/latex.js';\nvar name = 'SymbolNode';\nvar dependencies = ['math', '?Unit', 'Node'];\nexport var createSymbolNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var math = _ref.math,\n      Unit = _ref.Unit,\n      Node = _ref.Node;\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n\n  function isValuelessUnit(name) {\n    return Unit ? Unit.isValuelessUnit(name) : false;\n  }\n  /**\n   * @constructor SymbolNode\n   * @extends {Node}\n   * A symbol node can hold and resolve a symbol\n   * @param {string} name\n   * @extends {Node}\n   */\n\n\n  function SymbolNode(name) {\n    if (!(this instanceof SymbolNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    this.name = name;\n  }\n\n  SymbolNode.prototype = new Node();\n  SymbolNode.prototype.type = 'SymbolNode';\n  SymbolNode.prototype.isSymbolNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  SymbolNode.prototype._compile = function (math, argNames) {\n    var name = this.name;\n\n    if (argNames[name] === true) {\n      // this is a FunctionAssignment argument\n      // (like an x when inside the expression of a function assignment `f(x) = ...`)\n      return function (scope, args, context) {\n        return args[name];\n      };\n    } else if (name in math) {\n      return function (scope, args, context) {\n        return scope.has(name) ? scope.get(name) : getSafeProperty(math, name);\n      };\n    } else {\n      var isUnit = isValuelessUnit(name);\n      return function (scope, args, context) {\n        return scope.has(name) ? scope.get(name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  SymbolNode.prototype.forEach = function (callback) {// nothing to do, we don't have childs\n  };\n  /**\n   * Create a new SymbolNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {SymbolNode} Returns a clone of the node\n   */\n\n\n  SymbolNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n  /**\n   * Throws an error 'Undefined symbol {name}'\n   * @param {string} name\n   */\n\n\n  SymbolNode.onUndefinedSymbol = function (name) {\n    throw new Error('Undefined symbol ' + name);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {SymbolNode}\n   */\n\n\n  SymbolNode.prototype.clone = function () {\n    return new SymbolNode(this.name);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toString = function (options) {\n    return this.name;\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype.toHTML = function (options) {\n    var name = escape(this.name);\n\n    if (name === 'true' || name === 'false') {\n      return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n    } else if (name === 'i') {\n      return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n    } else if (name === 'Infinity') {\n      return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n    } else if (name === 'NaN') {\n      return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n    } else if (name === 'null') {\n      return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n    } else if (name === 'undefined') {\n      return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n    }\n\n    return '<span class=\"math-symbol\">' + name + '</span>';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  SymbolNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'SymbolNode',\n      name: this.name\n    };\n  };\n  /**\n   * Instantiate a SymbolNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\n   *                       where mathjs is optional\n   * @returns {SymbolNode}\n   */\n\n\n  SymbolNode.fromJSON = function (json) {\n    return new SymbolNode(json.name);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toTex = function (options) {\n    var isUnit = false;\n\n    if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n      isUnit = true;\n    }\n\n    var symbol = toSymbol(this.name, isUnit);\n\n    if (symbol[0] === '\\\\') {\n      // no space needed if the symbol starts with '\\'\n      return symbol;\n    } // the space prevents symbols from breaking stuff like '\\cdot' if it's written right before the symbol\n\n\n    return ' ' + symbol;\n  };\n\n  return SymbolNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["escape","getSafeProperty","factory","toSymbol","name","dependencies","createSymbolNode","_ref","math","Unit","Node","isValuelessUnit","SymbolNode","SyntaxError","TypeError","prototype","type","isSymbolNode","_compile","argNames","scope","args","context","has","get","isUnit","onUndefinedSymbol","forEach","callback","map","clone","Error","_toString","options","toHTML","toJSON","mathjs","fromJSON","json","_toTex","symbol","isClass","isNode"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/expression/node/SymbolNode.js"],"sourcesContent":["import { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { toSymbol } from '../../utils/latex.js';\nvar name = 'SymbolNode';\nvar dependencies = ['math', '?Unit', 'Node'];\nexport var createSymbolNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    math,\n    Unit,\n    Node\n  } = _ref;\n\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n  function isValuelessUnit(name) {\n    return Unit ? Unit.isValuelessUnit(name) : false;\n  }\n  /**\n   * @constructor SymbolNode\n   * @extends {Node}\n   * A symbol node can hold and resolve a symbol\n   * @param {string} name\n   * @extends {Node}\n   */\n\n\n  function SymbolNode(name) {\n    if (!(this instanceof SymbolNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    this.name = name;\n  }\n\n  SymbolNode.prototype = new Node();\n  SymbolNode.prototype.type = 'SymbolNode';\n  SymbolNode.prototype.isSymbolNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  SymbolNode.prototype._compile = function (math, argNames) {\n    var name = this.name;\n\n    if (argNames[name] === true) {\n      // this is a FunctionAssignment argument\n      // (like an x when inside the expression of a function assignment `f(x) = ...`)\n      return function (scope, args, context) {\n        return args[name];\n      };\n    } else if (name in math) {\n      return function (scope, args, context) {\n        return scope.has(name) ? scope.get(name) : getSafeProperty(math, name);\n      };\n    } else {\n      var isUnit = isValuelessUnit(name);\n      return function (scope, args, context) {\n        return scope.has(name) ? scope.get(name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  SymbolNode.prototype.forEach = function (callback) {// nothing to do, we don't have childs\n  };\n  /**\n   * Create a new SymbolNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {SymbolNode} Returns a clone of the node\n   */\n\n\n  SymbolNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n  /**\n   * Throws an error 'Undefined symbol {name}'\n   * @param {string} name\n   */\n\n\n  SymbolNode.onUndefinedSymbol = function (name) {\n    throw new Error('Undefined symbol ' + name);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {SymbolNode}\n   */\n\n\n  SymbolNode.prototype.clone = function () {\n    return new SymbolNode(this.name);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toString = function (options) {\n    return this.name;\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype.toHTML = function (options) {\n    var name = escape(this.name);\n\n    if (name === 'true' || name === 'false') {\n      return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n    } else if (name === 'i') {\n      return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n    } else if (name === 'Infinity') {\n      return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n    } else if (name === 'NaN') {\n      return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n    } else if (name === 'null') {\n      return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n    } else if (name === 'undefined') {\n      return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n    }\n\n    return '<span class=\"math-symbol\">' + name + '</span>';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  SymbolNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'SymbolNode',\n      name: this.name\n    };\n  };\n  /**\n   * Instantiate a SymbolNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\n   *                       where mathjs is optional\n   * @returns {SymbolNode}\n   */\n\n\n  SymbolNode.fromJSON = function (json) {\n    return new SymbolNode(json.name);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toTex = function (options) {\n    var isUnit = false;\n\n    if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n      isUnit = true;\n    }\n\n    var symbol = toSymbol(this.name, isUnit);\n\n    if (symbol[0] === '\\\\') {\n      // no space needed if the symbol starts with '\\'\n      return symbol;\n    } // the space prevents symbols from breaking stuff like '\\cdot' if it's written right before the symbol\n\n\n    return ' ' + symbol;\n  };\n\n  return SymbolNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}