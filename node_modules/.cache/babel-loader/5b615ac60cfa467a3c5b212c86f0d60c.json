{"ast":null,"code":"import { factory } from '../../../utils/factory.js';\nimport { csLeaf } from './csLeaf.js';\nvar name = 'csCounts';\nvar dependencies = ['transpose'];\nexport var createCsCounts = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var transpose = _ref.transpose;\n  /**\n   * Computes the column counts using the upper triangular part of A.\n   * It transposes A internally, none of the input parameters are modified.\n   *\n   * @param {Matrix} a           The sparse matrix A\n   *\n   * @param {Matrix} ata         Count the columns of A'A instead\n   *\n   * @return                     An array of size n of the column counts or null on error\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function (a, parent, post, ata) {\n    // check inputs\n    if (!a || !parent || !post) {\n      return null;\n    } // a matrix arrays\n\n\n    var asize = a._size; // rows and columns\n\n    var m = asize[0];\n    var n = asize[1]; // variables\n\n    var i, j, k, J, p, p0, p1; // workspace size\n\n    var s = 4 * n + (ata ? n + m + 1 : 0); // allocate workspace\n\n    var w = []; // (s)\n\n    var ancestor = 0; // first n entries\n\n    var maxfirst = n; // next n entries\n\n    var prevleaf = 2 * n; // next n entries\n\n    var first = 3 * n; // next n entries\n\n    var head = 4 * n; // next n + 1 entries (used when ata is true)\n\n    var next = 5 * n + 1; // last entries in workspace\n    // clear workspace w[0..s-1]\n\n    for (k = 0; k < s; k++) {\n      w[k] = -1;\n    } // allocate result\n\n\n    var colcount = []; // (n)\n    // AT = A'\n\n    var at = transpose(a); // at arrays\n\n    var tindex = at._index;\n    var tptr = at._ptr; // find w[first + j]\n\n    for (k = 0; k < n; k++) {\n      j = post[k]; // colcount[j]=1 if j is a leaf\n\n      colcount[j] = w[first + j] === -1 ? 1 : 0;\n\n      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {\n        w[first + j] = k;\n      }\n    } // initialize ata if needed\n\n\n    if (ata) {\n      // invert post\n      for (k = 0; k < n; k++) {\n        w[post[k]] = k;\n      } // loop rows (columns in AT)\n\n\n      for (i = 0; i < m; i++) {\n        // values in column i of AT\n        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {\n          k = Math.min(k, w[tindex[p]]);\n        } // place row i in linked list k\n\n\n        w[next + i] = w[head + k];\n        w[head + k] = i;\n      }\n    } // each node in its own set\n\n\n    for (i = 0; i < n; i++) {\n      w[ancestor + i] = i;\n    }\n\n    for (k = 0; k < n; k++) {\n      // j is the kth node in postordered etree\n      j = post[k]; // check j is not a root\n\n      if (parent[j] !== -1) {\n        colcount[parent[j]]--;\n      } // J=j for LL'=A case\n\n\n      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {\n        for (p = tptr[J]; p < tptr[J + 1]; p++) {\n          i = tindex[p];\n          var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor); // check A(i,j) is in skeleton\n\n          if (r.jleaf >= 1) {\n            colcount[j]++;\n          } // check account for overlap in q\n\n\n          if (r.jleaf === 2) {\n            colcount[r.q]--;\n          }\n        }\n      }\n\n      if (parent[j] !== -1) {\n        w[ancestor + j] = parent[j];\n      }\n    } // sum up colcount's of each child\n\n\n    for (j = 0; j < n; j++) {\n      if (parent[j] !== -1) {\n        colcount[parent[j]] += colcount[j];\n      }\n    }\n\n    return colcount;\n  };\n});","map":{"version":3,"names":["factory","csLeaf","name","dependencies","createCsCounts","_ref","transpose","a","parent","post","ata","asize","_size","m","n","i","j","k","J","p","p0","p1","s","w","ancestor","maxfirst","prevleaf","first","head","next","colcount","at","tindex","_index","tptr","_ptr","Math","min","r","jleaf","q"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js"],"sourcesContent":["import { factory } from '../../../utils/factory.js';\nimport { csLeaf } from './csLeaf.js';\nvar name = 'csCounts';\nvar dependencies = ['transpose'];\nexport var createCsCounts = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    transpose\n  } = _ref;\n\n  /**\n   * Computes the column counts using the upper triangular part of A.\n   * It transposes A internally, none of the input parameters are modified.\n   *\n   * @param {Matrix} a           The sparse matrix A\n   *\n   * @param {Matrix} ata         Count the columns of A'A instead\n   *\n   * @return                     An array of size n of the column counts or null on error\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  return function (a, parent, post, ata) {\n    // check inputs\n    if (!a || !parent || !post) {\n      return null;\n    } // a matrix arrays\n\n\n    var asize = a._size; // rows and columns\n\n    var m = asize[0];\n    var n = asize[1]; // variables\n\n    var i, j, k, J, p, p0, p1; // workspace size\n\n    var s = 4 * n + (ata ? n + m + 1 : 0); // allocate workspace\n\n    var w = []; // (s)\n\n    var ancestor = 0; // first n entries\n\n    var maxfirst = n; // next n entries\n\n    var prevleaf = 2 * n; // next n entries\n\n    var first = 3 * n; // next n entries\n\n    var head = 4 * n; // next n + 1 entries (used when ata is true)\n\n    var next = 5 * n + 1; // last entries in workspace\n    // clear workspace w[0..s-1]\n\n    for (k = 0; k < s; k++) {\n      w[k] = -1;\n    } // allocate result\n\n\n    var colcount = []; // (n)\n    // AT = A'\n\n    var at = transpose(a); // at arrays\n\n    var tindex = at._index;\n    var tptr = at._ptr; // find w[first + j]\n\n    for (k = 0; k < n; k++) {\n      j = post[k]; // colcount[j]=1 if j is a leaf\n\n      colcount[j] = w[first + j] === -1 ? 1 : 0;\n\n      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {\n        w[first + j] = k;\n      }\n    } // initialize ata if needed\n\n\n    if (ata) {\n      // invert post\n      for (k = 0; k < n; k++) {\n        w[post[k]] = k;\n      } // loop rows (columns in AT)\n\n\n      for (i = 0; i < m; i++) {\n        // values in column i of AT\n        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {\n          k = Math.min(k, w[tindex[p]]);\n        } // place row i in linked list k\n\n\n        w[next + i] = w[head + k];\n        w[head + k] = i;\n      }\n    } // each node in its own set\n\n\n    for (i = 0; i < n; i++) {\n      w[ancestor + i] = i;\n    }\n\n    for (k = 0; k < n; k++) {\n      // j is the kth node in postordered etree\n      j = post[k]; // check j is not a root\n\n      if (parent[j] !== -1) {\n        colcount[parent[j]]--;\n      } // J=j for LL'=A case\n\n\n      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {\n        for (p = tptr[J]; p < tptr[J + 1]; p++) {\n          i = tindex[p];\n          var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor); // check A(i,j) is in skeleton\n\n          if (r.jleaf >= 1) {\n            colcount[j]++;\n          } // check account for overlap in q\n\n\n          if (r.jleaf === 2) {\n            colcount[r.q]--;\n          }\n        }\n      }\n\n      if (parent[j] !== -1) {\n        w[ancestor + j] = parent[j];\n      }\n    } // sum up colcount's of each child\n\n\n    for (j = 0; j < n; j++) {\n      if (parent[j] !== -1) {\n        colcount[parent[j]] += colcount[j];\n      }\n    }\n\n    return colcount;\n  };\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}