{"ast":null,"code":"import { isInteger } from './number.js';\nimport { isNumber } from './is.js';\nimport { format } from './string.js';\nimport { DimensionError } from '../error/DimensionError.js';\nimport { IndexError } from '../error/IndexError.js';\n/**\n * Calculate the size of a multi dimensional array.\n * This function checks the size of the first entry, it does not validate\n * whether all dimensions match. (use function `validate` for that)\n * @param {Array} x\n * @Return {Number[]} size\n */\n\nexport function arraySize(x) {\n  var s = [];\n\n  while (Array.isArray(x)) {\n    s.push(x.length);\n    x = x[0];\n  }\n\n  return s;\n}\n/**\n * Recursively validate whether each element in a multi dimensional array\n * has a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @param {number} dim   Current dimension\n * @throws DimensionError\n * @private\n */\n\nfunction _validate(array, size, dim) {\n  var i;\n  var len = array.length;\n\n  if (len !== size[dim]) {\n    throw new DimensionError(len, size[dim]);\n  }\n\n  if (dim < size.length - 1) {\n    // recursively validate each child array\n    var dimNext = dim + 1;\n\n    for (i = 0; i < len; i++) {\n      var child = array[i];\n\n      if (!Array.isArray(child)) {\n        throw new DimensionError(size.length - 1, size.length, '<');\n      }\n\n      _validate(array[i], size, dimNext);\n    }\n  } else {\n    // last dimension. none of the childs may be an array\n    for (i = 0; i < len; i++) {\n      if (Array.isArray(array[i])) {\n        throw new DimensionError(size.length + 1, size.length, '>');\n      }\n    }\n  }\n}\n/**\n * Validate whether each element in a multi dimensional array has\n * a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @throws DimensionError\n */\n\n\nexport function validate(array, size) {\n  var isScalar = size.length === 0;\n\n  if (isScalar) {\n    // scalar\n    if (Array.isArray(array)) {\n      throw new DimensionError(array.length, 0);\n    }\n  } else {\n    // array\n    _validate(array, size, 0);\n  }\n}\n/**\n * Test whether index is an integer number with index >= 0 and index < length\n * when length is provided\n * @param {number} index    Zero-based index\n * @param {number} [length] Length of the array\n */\n\nexport function validateIndex(index, length) {\n  if (!isNumber(index) || !isInteger(index)) {\n    throw new TypeError('Index must be an integer (value: ' + index + ')');\n  }\n\n  if (index < 0 || typeof length === 'number' && index >= length) {\n    throw new IndexError(index, length);\n  }\n}\n/**\n * Resize a multi dimensional array. The resized array is returned.\n * @param {Array} array         Array to be resized\n * @param {Array.<number>} size Array with the size of each dimension\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\n *                              zero by default. Specify for example `null`,\n *                              to clearly see entries that are not explicitly\n *                              set.\n * @return {Array} array         The resized array\n */\n\nexport function resize(array, size, defaultValue) {\n  // TODO: add support for scalars, having size=[] ?\n  // check the type of the arguments\n  if (!Array.isArray(array) || !Array.isArray(size)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (size.length === 0) {\n    throw new Error('Resizing to scalar is not supported');\n  } // check whether size contains positive integers\n\n\n  size.forEach(function (value) {\n    if (!isNumber(value) || !isInteger(value) || value < 0) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n    }\n  }); // recursively resize the array\n\n  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;\n\n  _resize(array, size, 0, _defaultValue);\n\n  return array;\n}\n/**\n * Recursively resize a multi dimensional array\n * @param {Array} array         Array to be resized\n * @param {number[]} size       Array with the size of each dimension\n * @param {number} dim          Current dimension\n * @param {*} [defaultValue]    Value to be filled in in new entries,\n *                              undefined by default.\n * @private\n */\n\nfunction _resize(array, size, dim, defaultValue) {\n  var i;\n  var elem;\n  var oldLen = array.length;\n  var newLen = size[dim];\n  var minLen = Math.min(oldLen, newLen); // apply new length\n\n  array.length = newLen;\n\n  if (dim < size.length - 1) {\n    // non-last dimension\n    var dimNext = dim + 1; // resize existing child arrays\n\n    for (i = 0; i < minLen; i++) {\n      // resize child array\n      elem = array[i];\n\n      if (!Array.isArray(elem)) {\n        elem = [elem]; // add a dimension\n\n        array[i] = elem;\n      }\n\n      _resize(elem, size, dimNext, defaultValue);\n    } // create new child arrays\n\n\n    for (i = minLen; i < newLen; i++) {\n      // get child array\n      elem = [];\n      array[i] = elem; // resize new child array\n\n      _resize(elem, size, dimNext, defaultValue);\n    }\n  } else {\n    // last dimension\n    // remove dimensions of existing values\n    for (i = 0; i < minLen; i++) {\n      while (Array.isArray(array[i])) {\n        array[i] = array[i][0];\n      }\n    } // fill new elements with the default value\n\n\n    for (i = minLen; i < newLen; i++) {\n      array[i] = defaultValue;\n    }\n  }\n}\n/**\n * Re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n *\n * @throws {DimensionError}       If the product of the new dimension sizes does\n *                                not equal that of the old ones\n */\n\n\nexport function reshape(array, sizes) {\n  var flatArray = flatten(array);\n  var currentLength = flatArray.length;\n\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (sizes.length === 0) {\n    throw new DimensionError(0, currentLength, '!=');\n  }\n\n  sizes = processSizesWildcard(sizes, currentLength);\n  var newLength = product(sizes);\n\n  if (currentLength !== newLength) {\n    throw new DimensionError(newLength, currentLength, '!=');\n  }\n\n  try {\n    return _reshape(flatArray, sizes);\n  } catch (e) {\n    if (e instanceof DimensionError) {\n      throw new DimensionError(newLength, currentLength, '!=');\n    }\n\n    throw e;\n  }\n}\n/**\n * Replaces the wildcard -1 in the sizes array.\n * @param {Array.<number>} sizes  List of sizes for each dimension. At most on wildcard.\n * @param {number} currentLength  Number of elements in the array.\n * @throws {Error}                If more than one wildcard or unable to replace it.\n * @returns {Array.<number>}      The sizes array with wildcard replaced.\n */\n\nexport function processSizesWildcard(sizes, currentLength) {\n  var newLength = product(sizes);\n  var processedSizes = sizes.slice();\n  var WILDCARD = -1;\n  var wildCardIndex = sizes.indexOf(WILDCARD);\n  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;\n\n  if (isMoreThanOneWildcard) {\n    throw new Error('More than one wildcard in sizes');\n  }\n\n  var hasWildcard = wildCardIndex >= 0;\n  var canReplaceWildcard = currentLength % newLength === 0;\n\n  if (hasWildcard) {\n    if (canReplaceWildcard) {\n      processedSizes[wildCardIndex] = -currentLength / newLength;\n    } else {\n      throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);\n    }\n  }\n\n  return processedSizes;\n}\n/**\n * Computes the product of all array elements.\n * @param {Array<number>} array Array of factors\n * @returns {number}            Product of all elements\n */\n\nfunction product(array) {\n  return array.reduce(function (prev, curr) {\n    return prev * curr;\n  }, 1);\n}\n/**\n * Iteratively re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n */\n\n\nfunction _reshape(array, sizes) {\n  // testing if there are enough elements for the requested shape\n  var tmpArray = array;\n  var tmpArray2; // for each dimensions starting by the last one and ignoring the first one\n\n  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {\n    var size = sizes[sizeIndex];\n    tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size\n\n    var length = tmpArray.length / size;\n\n    for (var i = 0; i < length; i++) {\n      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));\n    } // set it as the new tmpArray for the next loop turn or for return\n\n\n    tmpArray = tmpArray2;\n  }\n\n  return tmpArray;\n}\n/**\n * Squeeze a multi dimensional array\n * @param {Array} array\n * @param {Array} [size]\n * @returns {Array} returns the array itself\n */\n\n\nexport function squeeze(array, size) {\n  var s = size || arraySize(array); // squeeze outer dimensions\n\n  while (Array.isArray(array) && array.length === 1) {\n    array = array[0];\n    s.shift();\n  } // find the first dimension to be squeezed\n\n\n  var dims = s.length;\n\n  while (s[dims - 1] === 1) {\n    dims--;\n  } // squeeze inner dimensions\n\n\n  if (dims < s.length) {\n    array = _squeeze(array, dims, 0);\n    s.length = dims;\n  }\n\n  return array;\n}\n/**\n * Recursively squeeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _squeeze(array, dims, dim) {\n  var i, ii;\n\n  if (dim < dims) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _squeeze(array[i], dims, next);\n    }\n  } else {\n    while (Array.isArray(array)) {\n      array = array[0];\n    }\n  }\n\n  return array;\n}\n/**\n * Unsqueeze a multi dimensional array: add dimensions when missing\n *\n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\n *\n * @param {Array} array\n * @param {number} dims       Desired number of dimensions of the array\n * @param {number} [outer]    Number of outer dimensions to be added\n * @param {Array} [size] Current size of array.\n * @returns {Array} returns the array itself\n * @private\n */\n\n\nexport function unsqueeze(array, dims, outer, size) {\n  var s = size || arraySize(array); // unsqueeze outer dimensions\n\n  if (outer) {\n    for (var i = 0; i < outer; i++) {\n      array = [array];\n      s.unshift(1);\n    }\n  } // unsqueeze inner dimensions\n\n\n  array = _unsqueeze(array, dims, 0);\n\n  while (s.length < dims) {\n    s.push(1);\n  }\n\n  return array;\n}\n/**\n * Recursively unsqueeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _unsqueeze(array, dims, dim) {\n  var i, ii;\n\n  if (Array.isArray(array)) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _unsqueeze(array[i], dims, next);\n    }\n  } else {\n    for (var d = dim; d < dims; d++) {\n      array = [array];\n    }\n  }\n\n  return array;\n}\n/**\n * Flatten a multi dimensional array, put all elements in a one dimensional\n * array\n * @param {Array} array   A multi dimensional array\n * @return {Array}        The flattened array (1 dimensional)\n */\n\n\nexport function flatten(array) {\n  if (!Array.isArray(array)) {\n    // if not an array, return as is\n    return array;\n  }\n\n  var flat = [];\n  array.forEach(function callback(value) {\n    if (Array.isArray(value)) {\n      value.forEach(callback); // traverse through sub-arrays recursively\n    } else {\n      flat.push(value);\n    }\n  });\n  return flat;\n}\n/**\n * A safe map\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function map(array, callback) {\n  return Array.prototype.map.call(array, callback);\n}\n/**\n * A safe forEach\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function forEach(array, callback) {\n  Array.prototype.forEach.call(array, callback);\n}\n/**\n * A safe filter\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function filter(array, callback) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, callback);\n}\n/**\n * Filter values in a callback given a regular expression\n * @param {Array} array\n * @param {RegExp} regexp\n * @return {Array} Returns the filtered array\n * @private\n */\n\nexport function filterRegExp(array, regexp) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, function (entry) {\n    return regexp.test(entry);\n  });\n}\n/**\n * A safe join\n * @param {Array} array\n * @param {string} separator\n */\n\nexport function join(array, separator) {\n  return Array.prototype.join.call(array, separator);\n}\n/**\n * Assign a numeric identifier to every element of a sorted array\n * @param {Array} a  An array\n * @return {Array} An array of objects containing the original value and its identifier\n */\n\nexport function identify(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n  var count = 0;\n  b[0] = {\n    value: a[0],\n    identifier: 0\n  };\n\n  for (var i = 1; i < a.length; i++) {\n    if (a[i] === a[i - 1]) {\n      count++;\n    } else {\n      count = 0;\n    }\n\n    b.push({\n      value: a[i],\n      identifier: count\n    });\n  }\n\n  return b;\n}\n/**\n * Remove the numeric identifier from the elements\n * @param {array} a  An array\n * @return {array} An array of values without identifiers\n */\n\nexport function generalize(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n\n  for (var i = 0; i < a.length; i++) {\n    b.push(a[i].value);\n  }\n\n  return b;\n}\n/**\n * Check the datatype of a given object\n * This is a low level implementation that should only be used by\n * parent Matrix classes such as SparseMatrix or DenseMatrix\n * This method does not validate Array Matrix shape\n * @param {Array} array\n * @param {function} typeOf   Callback function to use to determine the type of a value\n * @return {string}\n */\n\nexport function getArrayDataType(array, typeOf) {\n  var type; // to hold type info\n\n  var length = 0; // to hold length value to ensure it has consistent sizes\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    var isArray = Array.isArray(item); // Saving the target matrix row size\n\n    if (i === 0 && isArray) {\n      length = item.length;\n    } // If the current item is an array but the length does not equal the targetVectorSize\n\n\n    if (isArray && item.length !== length) {\n      return undefined;\n    }\n\n    var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array\n    : typeOf(item);\n\n    if (type === undefined) {\n      type = itemType; // first item\n    } else if (type !== itemType) {\n      return 'mixed';\n    } else {// we're good, everything has the same type so far\n    }\n  }\n\n  return type;\n}\n/**\n * Return the last item from an array\n * @param array\n * @returns {*}\n */\n\nexport function last(array) {\n  return array[array.length - 1];\n}\n/**\n * Get all but the last element of array.\n */\n\nexport function initial(array) {\n  return array.slice(0, array.length - 1);\n}\n/**\n * Test whether an array or string contains an item\n * @param {Array | string} array\n * @param {*} item\n * @return {boolean}\n */\n\nexport function contains(array, item) {\n  return array.indexOf(item) !== -1;\n}","map":{"version":3,"names":["isInteger","isNumber","format","DimensionError","IndexError","arraySize","x","s","Array","isArray","push","length","_validate","array","size","dim","i","len","dimNext","child","validate","isScalar","validateIndex","index","TypeError","resize","defaultValue","Error","forEach","value","_defaultValue","undefined","_resize","elem","oldLen","newLen","minLen","Math","min","reshape","sizes","flatArray","flatten","currentLength","processSizesWildcard","newLength","product","_reshape","e","processedSizes","slice","WILDCARD","wildCardIndex","indexOf","isMoreThanOneWildcard","hasWildcard","canReplaceWildcard","reduce","prev","curr","tmpArray","tmpArray2","sizeIndex","squeeze","shift","dims","_squeeze","ii","next","unsqueeze","outer","unshift","_unsqueeze","d","flat","callback","map","prototype","call","filter","filterRegExp","regexp","entry","test","join","separator","identify","a","b","count","identifier","generalize","getArrayDataType","typeOf","type","item","itemType","last","initial","contains"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/utils/array.js"],"sourcesContent":["import { isInteger } from './number.js';\nimport { isNumber } from './is.js';\nimport { format } from './string.js';\nimport { DimensionError } from '../error/DimensionError.js';\nimport { IndexError } from '../error/IndexError.js';\n/**\n * Calculate the size of a multi dimensional array.\n * This function checks the size of the first entry, it does not validate\n * whether all dimensions match. (use function `validate` for that)\n * @param {Array} x\n * @Return {Number[]} size\n */\n\nexport function arraySize(x) {\n  var s = [];\n\n  while (Array.isArray(x)) {\n    s.push(x.length);\n    x = x[0];\n  }\n\n  return s;\n}\n/**\n * Recursively validate whether each element in a multi dimensional array\n * has a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @param {number} dim   Current dimension\n * @throws DimensionError\n * @private\n */\n\nfunction _validate(array, size, dim) {\n  var i;\n  var len = array.length;\n\n  if (len !== size[dim]) {\n    throw new DimensionError(len, size[dim]);\n  }\n\n  if (dim < size.length - 1) {\n    // recursively validate each child array\n    var dimNext = dim + 1;\n\n    for (i = 0; i < len; i++) {\n      var child = array[i];\n\n      if (!Array.isArray(child)) {\n        throw new DimensionError(size.length - 1, size.length, '<');\n      }\n\n      _validate(array[i], size, dimNext);\n    }\n  } else {\n    // last dimension. none of the childs may be an array\n    for (i = 0; i < len; i++) {\n      if (Array.isArray(array[i])) {\n        throw new DimensionError(size.length + 1, size.length, '>');\n      }\n    }\n  }\n}\n/**\n * Validate whether each element in a multi dimensional array has\n * a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @throws DimensionError\n */\n\n\nexport function validate(array, size) {\n  var isScalar = size.length === 0;\n\n  if (isScalar) {\n    // scalar\n    if (Array.isArray(array)) {\n      throw new DimensionError(array.length, 0);\n    }\n  } else {\n    // array\n    _validate(array, size, 0);\n  }\n}\n/**\n * Test whether index is an integer number with index >= 0 and index < length\n * when length is provided\n * @param {number} index    Zero-based index\n * @param {number} [length] Length of the array\n */\n\nexport function validateIndex(index, length) {\n  if (!isNumber(index) || !isInteger(index)) {\n    throw new TypeError('Index must be an integer (value: ' + index + ')');\n  }\n\n  if (index < 0 || typeof length === 'number' && index >= length) {\n    throw new IndexError(index, length);\n  }\n}\n/**\n * Resize a multi dimensional array. The resized array is returned.\n * @param {Array} array         Array to be resized\n * @param {Array.<number>} size Array with the size of each dimension\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\n *                              zero by default. Specify for example `null`,\n *                              to clearly see entries that are not explicitly\n *                              set.\n * @return {Array} array         The resized array\n */\n\nexport function resize(array, size, defaultValue) {\n  // TODO: add support for scalars, having size=[] ?\n  // check the type of the arguments\n  if (!Array.isArray(array) || !Array.isArray(size)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (size.length === 0) {\n    throw new Error('Resizing to scalar is not supported');\n  } // check whether size contains positive integers\n\n\n  size.forEach(function (value) {\n    if (!isNumber(value) || !isInteger(value) || value < 0) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n    }\n  }); // recursively resize the array\n\n  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;\n\n  _resize(array, size, 0, _defaultValue);\n\n  return array;\n}\n/**\n * Recursively resize a multi dimensional array\n * @param {Array} array         Array to be resized\n * @param {number[]} size       Array with the size of each dimension\n * @param {number} dim          Current dimension\n * @param {*} [defaultValue]    Value to be filled in in new entries,\n *                              undefined by default.\n * @private\n */\n\nfunction _resize(array, size, dim, defaultValue) {\n  var i;\n  var elem;\n  var oldLen = array.length;\n  var newLen = size[dim];\n  var minLen = Math.min(oldLen, newLen); // apply new length\n\n  array.length = newLen;\n\n  if (dim < size.length - 1) {\n    // non-last dimension\n    var dimNext = dim + 1; // resize existing child arrays\n\n    for (i = 0; i < minLen; i++) {\n      // resize child array\n      elem = array[i];\n\n      if (!Array.isArray(elem)) {\n        elem = [elem]; // add a dimension\n\n        array[i] = elem;\n      }\n\n      _resize(elem, size, dimNext, defaultValue);\n    } // create new child arrays\n\n\n    for (i = minLen; i < newLen; i++) {\n      // get child array\n      elem = [];\n      array[i] = elem; // resize new child array\n\n      _resize(elem, size, dimNext, defaultValue);\n    }\n  } else {\n    // last dimension\n    // remove dimensions of existing values\n    for (i = 0; i < minLen; i++) {\n      while (Array.isArray(array[i])) {\n        array[i] = array[i][0];\n      }\n    } // fill new elements with the default value\n\n\n    for (i = minLen; i < newLen; i++) {\n      array[i] = defaultValue;\n    }\n  }\n}\n/**\n * Re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n *\n * @throws {DimensionError}       If the product of the new dimension sizes does\n *                                not equal that of the old ones\n */\n\n\nexport function reshape(array, sizes) {\n  var flatArray = flatten(array);\n  var currentLength = flatArray.length;\n\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (sizes.length === 0) {\n    throw new DimensionError(0, currentLength, '!=');\n  }\n\n  sizes = processSizesWildcard(sizes, currentLength);\n  var newLength = product(sizes);\n\n  if (currentLength !== newLength) {\n    throw new DimensionError(newLength, currentLength, '!=');\n  }\n\n  try {\n    return _reshape(flatArray, sizes);\n  } catch (e) {\n    if (e instanceof DimensionError) {\n      throw new DimensionError(newLength, currentLength, '!=');\n    }\n\n    throw e;\n  }\n}\n/**\n * Replaces the wildcard -1 in the sizes array.\n * @param {Array.<number>} sizes  List of sizes for each dimension. At most on wildcard.\n * @param {number} currentLength  Number of elements in the array.\n * @throws {Error}                If more than one wildcard or unable to replace it.\n * @returns {Array.<number>}      The sizes array with wildcard replaced.\n */\n\nexport function processSizesWildcard(sizes, currentLength) {\n  var newLength = product(sizes);\n  var processedSizes = sizes.slice();\n  var WILDCARD = -1;\n  var wildCardIndex = sizes.indexOf(WILDCARD);\n  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;\n\n  if (isMoreThanOneWildcard) {\n    throw new Error('More than one wildcard in sizes');\n  }\n\n  var hasWildcard = wildCardIndex >= 0;\n  var canReplaceWildcard = currentLength % newLength === 0;\n\n  if (hasWildcard) {\n    if (canReplaceWildcard) {\n      processedSizes[wildCardIndex] = -currentLength / newLength;\n    } else {\n      throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);\n    }\n  }\n\n  return processedSizes;\n}\n/**\n * Computes the product of all array elements.\n * @param {Array<number>} array Array of factors\n * @returns {number}            Product of all elements\n */\n\nfunction product(array) {\n  return array.reduce((prev, curr) => prev * curr, 1);\n}\n/**\n * Iteratively re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n */\n\n\nfunction _reshape(array, sizes) {\n  // testing if there are enough elements for the requested shape\n  var tmpArray = array;\n  var tmpArray2; // for each dimensions starting by the last one and ignoring the first one\n\n  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {\n    var size = sizes[sizeIndex];\n    tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size\n\n    var length = tmpArray.length / size;\n\n    for (var i = 0; i < length; i++) {\n      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));\n    } // set it as the new tmpArray for the next loop turn or for return\n\n\n    tmpArray = tmpArray2;\n  }\n\n  return tmpArray;\n}\n/**\n * Squeeze a multi dimensional array\n * @param {Array} array\n * @param {Array} [size]\n * @returns {Array} returns the array itself\n */\n\n\nexport function squeeze(array, size) {\n  var s = size || arraySize(array); // squeeze outer dimensions\n\n  while (Array.isArray(array) && array.length === 1) {\n    array = array[0];\n    s.shift();\n  } // find the first dimension to be squeezed\n\n\n  var dims = s.length;\n\n  while (s[dims - 1] === 1) {\n    dims--;\n  } // squeeze inner dimensions\n\n\n  if (dims < s.length) {\n    array = _squeeze(array, dims, 0);\n    s.length = dims;\n  }\n\n  return array;\n}\n/**\n * Recursively squeeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _squeeze(array, dims, dim) {\n  var i, ii;\n\n  if (dim < dims) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _squeeze(array[i], dims, next);\n    }\n  } else {\n    while (Array.isArray(array)) {\n      array = array[0];\n    }\n  }\n\n  return array;\n}\n/**\n * Unsqueeze a multi dimensional array: add dimensions when missing\n *\n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\n *\n * @param {Array} array\n * @param {number} dims       Desired number of dimensions of the array\n * @param {number} [outer]    Number of outer dimensions to be added\n * @param {Array} [size] Current size of array.\n * @returns {Array} returns the array itself\n * @private\n */\n\n\nexport function unsqueeze(array, dims, outer, size) {\n  var s = size || arraySize(array); // unsqueeze outer dimensions\n\n  if (outer) {\n    for (var i = 0; i < outer; i++) {\n      array = [array];\n      s.unshift(1);\n    }\n  } // unsqueeze inner dimensions\n\n\n  array = _unsqueeze(array, dims, 0);\n\n  while (s.length < dims) {\n    s.push(1);\n  }\n\n  return array;\n}\n/**\n * Recursively unsqueeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _unsqueeze(array, dims, dim) {\n  var i, ii;\n\n  if (Array.isArray(array)) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _unsqueeze(array[i], dims, next);\n    }\n  } else {\n    for (var d = dim; d < dims; d++) {\n      array = [array];\n    }\n  }\n\n  return array;\n}\n/**\n * Flatten a multi dimensional array, put all elements in a one dimensional\n * array\n * @param {Array} array   A multi dimensional array\n * @return {Array}        The flattened array (1 dimensional)\n */\n\n\nexport function flatten(array) {\n  if (!Array.isArray(array)) {\n    // if not an array, return as is\n    return array;\n  }\n\n  var flat = [];\n  array.forEach(function callback(value) {\n    if (Array.isArray(value)) {\n      value.forEach(callback); // traverse through sub-arrays recursively\n    } else {\n      flat.push(value);\n    }\n  });\n  return flat;\n}\n/**\n * A safe map\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function map(array, callback) {\n  return Array.prototype.map.call(array, callback);\n}\n/**\n * A safe forEach\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function forEach(array, callback) {\n  Array.prototype.forEach.call(array, callback);\n}\n/**\n * A safe filter\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function filter(array, callback) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, callback);\n}\n/**\n * Filter values in a callback given a regular expression\n * @param {Array} array\n * @param {RegExp} regexp\n * @return {Array} Returns the filtered array\n * @private\n */\n\nexport function filterRegExp(array, regexp) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, entry => regexp.test(entry));\n}\n/**\n * A safe join\n * @param {Array} array\n * @param {string} separator\n */\n\nexport function join(array, separator) {\n  return Array.prototype.join.call(array, separator);\n}\n/**\n * Assign a numeric identifier to every element of a sorted array\n * @param {Array} a  An array\n * @return {Array} An array of objects containing the original value and its identifier\n */\n\nexport function identify(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n  var count = 0;\n  b[0] = {\n    value: a[0],\n    identifier: 0\n  };\n\n  for (var i = 1; i < a.length; i++) {\n    if (a[i] === a[i - 1]) {\n      count++;\n    } else {\n      count = 0;\n    }\n\n    b.push({\n      value: a[i],\n      identifier: count\n    });\n  }\n\n  return b;\n}\n/**\n * Remove the numeric identifier from the elements\n * @param {array} a  An array\n * @return {array} An array of values without identifiers\n */\n\nexport function generalize(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n\n  for (var i = 0; i < a.length; i++) {\n    b.push(a[i].value);\n  }\n\n  return b;\n}\n/**\n * Check the datatype of a given object\n * This is a low level implementation that should only be used by\n * parent Matrix classes such as SparseMatrix or DenseMatrix\n * This method does not validate Array Matrix shape\n * @param {Array} array\n * @param {function} typeOf   Callback function to use to determine the type of a value\n * @return {string}\n */\n\nexport function getArrayDataType(array, typeOf) {\n  var type; // to hold type info\n\n  var length = 0; // to hold length value to ensure it has consistent sizes\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    var isArray = Array.isArray(item); // Saving the target matrix row size\n\n    if (i === 0 && isArray) {\n      length = item.length;\n    } // If the current item is an array but the length does not equal the targetVectorSize\n\n\n    if (isArray && item.length !== length) {\n      return undefined;\n    }\n\n    var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array\n    : typeOf(item);\n\n    if (type === undefined) {\n      type = itemType; // first item\n    } else if (type !== itemType) {\n      return 'mixed';\n    } else {// we're good, everything has the same type so far\n    }\n  }\n\n  return type;\n}\n/**\n * Return the last item from an array\n * @param array\n * @returns {*}\n */\n\nexport function last(array) {\n  return array[array.length - 1];\n}\n/**\n * Get all but the last element of array.\n */\n\nexport function initial(array) {\n  return array.slice(0, array.length - 1);\n}\n/**\n * Test whether an array or string contains an item\n * @param {Array | string} array\n * @param {*} item\n * @return {boolean}\n */\n\nexport function contains(array, item) {\n  return array.indexOf(item) !== -1;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}