{"ast":null,"code":"import _toConsumableArray from \"/Users/ayao/vscode/fourier-series-drawer/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { isAccessorNode, isFunctionAssignmentNode, isIndexNode, isNode, isSymbolNode } from '../../utils/is.js';\nimport { escape, format } from '../../utils/string.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { getSafeProperty, validateSafeMethod } from '../../utils/customs.js';\nimport { createSubScope } from '../../utils/scope.js';\nimport { factory } from '../../utils/factory.js';\nimport { defaultTemplate, latexFunctions } from '../../utils/latex.js';\nvar name = 'FunctionNode';\nvar dependencies = ['math', 'Node', 'SymbolNode'];\nexport var createFunctionNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var math = _ref.math,\n      Node = _ref.Node,\n      SymbolNode = _ref.SymbolNode;\n  /**\n   * @constructor FunctionNode\n   * @extends {./Node}\n   * invoke a list with arguments on a node\n   * @param {./Node | string} fn Node resolving with a function on which to invoke\n   *                             the arguments, typically a SymboNode or AccessorNode\n   * @param {./Node[]} args\n   */\n\n  function FunctionNode(fn, args) {\n    if (!(this instanceof FunctionNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (typeof fn === 'string') {\n      fn = new SymbolNode(fn);\n    } // validate input\n\n\n    if (!isNode(fn)) throw new TypeError('Node expected as parameter \"fn\"');\n\n    if (!Array.isArray(args) || !args.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.fn = fn;\n    this.args = args || []; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        return this.fn.name || '';\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  FunctionNode.prototype = new Node();\n  FunctionNode.prototype.type = 'FunctionNode';\n  FunctionNode.prototype.isFunctionNode = true;\n  /* format to fixed length */\n\n  var strin = function strin(entity) {\n    return format(entity, {\n      truncate: 78\n    });\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  FunctionNode.prototype._compile = function (math, argNames) {\n    if (!(this instanceof FunctionNode)) {\n      throw new TypeError('No valid FunctionNode');\n    } // compile arguments\n\n\n    var evalArgs = this.args.map(function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if (isSymbolNode(this.fn)) {\n      var _name = this.fn.name;\n\n      if (!argNames[_name]) {\n        // we can statically determine whether the function has an rawArgs property\n        var fn = _name in math ? getSafeProperty(math, _name) : undefined;\n        var isRaw = typeof fn === 'function' && fn.rawArgs === true;\n\n        var resolveFn = function resolveFn(scope) {\n          var value;\n\n          if (scope.has(_name)) {\n            value = scope.get(_name);\n          } else if (_name in math) {\n            value = getSafeProperty(math, _name);\n          } else {\n            return FunctionNode.onUndefinedFunction(_name);\n          }\n\n          if (typeof value === 'function') {\n            return value;\n          }\n\n          throw new TypeError(\"'\".concat(_name, \"' is not a function; its value is:\\n  \").concat(strin(value)));\n        };\n\n        if (isRaw) {\n          // pass unevaluated parameters (nodes) to the function\n          // \"raw\" evaluation\n          var rawArgs = this.args;\n          return function evalFunctionNode(scope, args, context) {\n            var fn = resolveFn(scope);\n            return fn(rawArgs, math, createSubScope(scope, args), scope);\n          };\n        } else {\n          // \"regular\" evaluation\n          switch (evalArgs.length) {\n            case 0:\n              return function evalFunctionNode(scope, args, context) {\n                var fn = resolveFn(scope);\n                return fn();\n              };\n\n            case 1:\n              return function evalFunctionNode(scope, args, context) {\n                var fn = resolveFn(scope);\n                var evalArg0 = evalArgs[0];\n                return fn(evalArg0(scope, args, context));\n              };\n\n            case 2:\n              return function evalFunctionNode(scope, args, context) {\n                var fn = resolveFn(scope);\n                var evalArg0 = evalArgs[0];\n                var evalArg1 = evalArgs[1];\n                return fn(evalArg0(scope, args, context), evalArg1(scope, args, context));\n              };\n\n            default:\n              return function evalFunctionNode(scope, args, context) {\n                var fn = resolveFn(scope);\n                var values = evalArgs.map(function (evalArg) {\n                  return evalArg(scope, args, context);\n                });\n                return fn.apply(void 0, _toConsumableArray(values));\n              };\n          }\n        }\n      } else {\n        // the function symbol is an argName\n        var _rawArgs = this.args;\n        return function evalFunctionNode(scope, args, context) {\n          var fn = args[_name];\n\n          if (typeof fn !== 'function') {\n            throw new TypeError(\"Argument '\".concat(_name, \"' was not a function; received: \").concat(strin(fn)));\n          }\n\n          if (fn.rawArgs) {\n            return fn(_rawArgs, math, createSubScope(scope, args), scope); // \"raw\" evaluation\n          } else {\n            var values = evalArgs.map(function (evalArg) {\n              return evalArg(scope, args, context);\n            });\n            return fn.apply(fn, values);\n          }\n        };\n      }\n    } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {\n      // execute the function with the right context: the object of the AccessorNode\n      var evalObject = this.fn.object._compile(math, argNames);\n\n      var prop = this.fn.index.getObjectProperty();\n      var _rawArgs2 = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        validateSafeMethod(object, prop);\n        var isRaw = object[prop] && object[prop].rawArgs;\n\n        if (isRaw) {\n          return object[prop](_rawArgs2, math, createSubScope(scope, args), scope); // \"raw\" evaluation\n        } else {\n          // \"regular\" evaluation\n          var values = evalArgs.map(function (evalArg) {\n            return evalArg(scope, args, context);\n          });\n          return object[prop].apply(object, values);\n        }\n      };\n    } else {\n      // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()\n      // we have to dynamically determine whether the function has a rawArgs property\n      var fnExpr = this.fn.toString();\n\n      var evalFn = this.fn._compile(math, argNames);\n\n      var _rawArgs3 = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var fn = evalFn(scope, args, context);\n\n        if (typeof fn !== 'function') {\n          throw new TypeError(\"Expression '\".concat(fnExpr, \"' did not evaluate to a function; value is:\") + \"\\n  \".concat(strin(fn)));\n        }\n\n        if (fn.rawArgs) {\n          return fn(_rawArgs3, math, createSubScope(scope, args), scope); // \"raw\" evaluation\n        } else {\n          // \"regular\" evaluation\n          var values = evalArgs.map(function (evalArg) {\n            return evalArg(scope, args, context);\n          });\n          return fn.apply(fn, values);\n        }\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionNode.prototype.forEach = function (callback) {\n    callback(this.fn, 'fn', this);\n\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new FunctionNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionNode.prototype.map = function (callback) {\n    var fn = this._ifNode(callback(this.fn, 'fn', this));\n\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new FunctionNode(fn, args);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionNode}\n   */\n\n\n  FunctionNode.prototype.clone = function () {\n    return new FunctionNode(this.fn, this.args.slice(0));\n  };\n  /**\n   * Throws an error 'Undefined function {name}'\n   * @param {string} name\n   */\n\n\n  FunctionNode.onUndefinedFunction = function (name) {\n    throw new Error('Undefined function ' + name);\n  }; // backup Node's toString function\n  // @private\n\n\n  var nodeToString = FunctionNode.prototype.toString;\n  /**\n   * Get string representation. (wrapper function)\n   * This overrides parts of Node's toString function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toString\n   * function.\n   *\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  FunctionNode.prototype.toString = function (options) {\n    var customString;\n    var name = this.fn.toString(options);\n\n    if (options && typeof options.handler === 'object' && hasOwnProperty(options.handler, name)) {\n      // callback is a map of callback functions\n      customString = options.handler[name](this, options);\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    } // fall back to Node's toString\n\n\n    return nodeToString.call(this, options);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toString = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toString(options);\n    });\n    var fn = isFunctionAssignmentNode(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options); // format the arguments like \"add(2, 4.2)\"\n\n    return fn + '(' + args.join(', ') + ')';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'FunctionNode',\n      fn: this.fn,\n      args: this.args\n    };\n  };\n  /**\n   * Instantiate an AssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionNode\", fn: ..., args: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionNode}\n   */\n\n\n  FunctionNode.fromJSON = function (json) {\n    return new FunctionNode(json.fn, json.args);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype.toHTML = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toHTML(options);\n    }); // format the arguments like \"add(2, 4.2)\"\n\n    return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + args.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n  };\n  /*\n   * Expand a LaTeX template\n   *\n   * @param {string} template\n   * @param {Node} node\n   * @param {Object} options\n   * @private\n   **/\n\n\n  function expandTemplate(template, node, options) {\n    var latex = ''; // Match everything of the form ${identifier} or ${identifier[2]} or $$\n    // while submatching identifier and 2 (in the second case)\n\n    var regex = /\\$(?:\\{([a-z_][a-z_0-9]*)(?:\\[([0-9]+)\\])?\\}|\\$)/gi;\n    var inputPos = 0; // position in the input string\n\n    var match;\n\n    while ((match = regex.exec(template)) !== null) {\n      // go through all matches\n      // add everything in front of the match to the LaTeX string\n      latex += template.substring(inputPos, match.index);\n      inputPos = match.index;\n\n      if (match[0] === '$$') {\n        // escaped dollar sign\n        latex += '$';\n        inputPos++;\n      } else {\n        // template parameter\n        inputPos += match[0].length;\n        var property = node[match[1]];\n\n        if (!property) {\n          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');\n        }\n\n        if (match[2] === undefined) {\n          // no square brackets\n          switch (typeof property) {\n            case 'string':\n              latex += property;\n              break;\n\n            case 'object':\n              if (isNode(property)) {\n                latex += property.toTex(options);\n              } else if (Array.isArray(property)) {\n                // make array of Nodes into comma separated list\n                latex += property.map(function (arg, index) {\n                  if (isNode(arg)) {\n                    return arg.toTex(options);\n                  }\n\n                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');\n                }).join(',');\n              } else {\n                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n              }\n\n              break;\n\n            default:\n              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n          }\n        } else {\n          // with square brackets\n          if (isNode(property[match[2]] && property[match[2]])) {\n            latex += property[match[2]].toTex(options);\n          } else {\n            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');\n          }\n        }\n      }\n    }\n\n    latex += template.slice(inputPos); // append rest of the template\n\n    return latex;\n  } // backup Node's toTex function\n  // @private\n\n\n  var nodeToTex = FunctionNode.prototype.toTex;\n  /**\n   * Get LaTeX representation. (wrapper function)\n   * This overrides parts of Node's toTex function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toTex\n   * function.\n   *\n   * @param {Object} options\n   * @return {string}\n   */\n\n  FunctionNode.prototype.toTex = function (options) {\n    var customTex;\n\n    if (options && typeof options.handler === 'object' && hasOwnProperty(options.handler, this.name)) {\n      // callback is a map of callback functions\n      customTex = options.handler[this.name](this, options);\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    } // fall back to Node's toTex\n\n\n    return nodeToTex.call(this, options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toTex = function (options) {\n    var args = this.args.map(function (arg) {\n      // get LaTeX of the arguments\n      return arg.toTex(options);\n    });\n    var latexConverter;\n\n    if (latexFunctions[this.name]) {\n      latexConverter = latexFunctions[this.name];\n    } // toTex property on the function itself\n\n\n    if (math[this.name] && (typeof math[this.name].toTex === 'function' || typeof math[this.name].toTex === 'object' || typeof math[this.name].toTex === 'string')) {\n      // .toTex is a callback function\n      latexConverter = math[this.name].toTex;\n    }\n\n    var customToTex;\n\n    switch (typeof latexConverter) {\n      case 'function':\n        // a callback function\n        customToTex = latexConverter(this, options);\n        break;\n\n      case 'string':\n        // a template string\n        customToTex = expandTemplate(latexConverter, this, options);\n        break;\n\n      case 'object':\n        // an object with different \"converters\" for different numbers of arguments\n        switch (typeof latexConverter[args.length]) {\n          case 'function':\n            customToTex = latexConverter[args.length](this, options);\n            break;\n\n          case 'string':\n            customToTex = expandTemplate(latexConverter[args.length], this, options);\n            break;\n        }\n\n    }\n\n    if (typeof customToTex !== 'undefined') {\n      return customToTex;\n    }\n\n    return expandTemplate(defaultTemplate, this, options);\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  FunctionNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.name;\n  };\n\n  return FunctionNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isAccessorNode","isFunctionAssignmentNode","isIndexNode","isNode","isSymbolNode","escape","format","hasOwnProperty","getSafeProperty","validateSafeMethod","createSubScope","factory","defaultTemplate","latexFunctions","name","dependencies","createFunctionNode","_ref","math","Node","SymbolNode","FunctionNode","fn","args","SyntaxError","TypeError","Array","isArray","every","Object","defineProperty","get","bind","set","Error","prototype","type","isFunctionNode","strin","entity","truncate","_compile","argNames","evalArgs","map","arg","_name","undefined","isRaw","rawArgs","resolveFn","scope","value","has","onUndefinedFunction","concat","evalFunctionNode","context","length","evalArg0","evalArg1","values","evalArg","_rawArgs","apply","index","isObjectProperty","evalObject","object","prop","getObjectProperty","_rawArgs2","fnExpr","toString","evalFn","_rawArgs3","forEach","callback","i","_ifNode","clone","slice","nodeToString","options","customString","handler","call","_toString","join","toJSON","mathjs","fromJSON","json","toHTML","expandTemplate","template","node","latex","regex","inputPos","match","exec","substring","property","ReferenceError","toTex","nodeToTex","customTex","_toTex","latexConverter","customToTex","getIdentifier","isClass"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/expression/node/FunctionNode.js"],"sourcesContent":["import { isAccessorNode, isFunctionAssignmentNode, isIndexNode, isNode, isSymbolNode } from '../../utils/is.js';\nimport { escape, format } from '../../utils/string.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { getSafeProperty, validateSafeMethod } from '../../utils/customs.js';\nimport { createSubScope } from '../../utils/scope.js';\nimport { factory } from '../../utils/factory.js';\nimport { defaultTemplate, latexFunctions } from '../../utils/latex.js';\nvar name = 'FunctionNode';\nvar dependencies = ['math', 'Node', 'SymbolNode'];\nexport var createFunctionNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    math,\n    Node,\n    SymbolNode\n  } = _ref;\n\n  /**\n   * @constructor FunctionNode\n   * @extends {./Node}\n   * invoke a list with arguments on a node\n   * @param {./Node | string} fn Node resolving with a function on which to invoke\n   *                             the arguments, typically a SymboNode or AccessorNode\n   * @param {./Node[]} args\n   */\n  function FunctionNode(fn, args) {\n    if (!(this instanceof FunctionNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (typeof fn === 'string') {\n      fn = new SymbolNode(fn);\n    } // validate input\n\n\n    if (!isNode(fn)) throw new TypeError('Node expected as parameter \"fn\"');\n\n    if (!Array.isArray(args) || !args.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.fn = fn;\n    this.args = args || []; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        return this.fn.name || '';\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  FunctionNode.prototype = new Node();\n  FunctionNode.prototype.type = 'FunctionNode';\n  FunctionNode.prototype.isFunctionNode = true;\n  /* format to fixed length */\n\n  var strin = entity => format(entity, {\n    truncate: 78\n  });\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  FunctionNode.prototype._compile = function (math, argNames) {\n    if (!(this instanceof FunctionNode)) {\n      throw new TypeError('No valid FunctionNode');\n    } // compile arguments\n\n\n    var evalArgs = this.args.map(arg => arg._compile(math, argNames));\n\n    if (isSymbolNode(this.fn)) {\n      var _name = this.fn.name;\n\n      if (!argNames[_name]) {\n        // we can statically determine whether the function has an rawArgs property\n        var fn = _name in math ? getSafeProperty(math, _name) : undefined;\n        var isRaw = typeof fn === 'function' && fn.rawArgs === true;\n\n        var resolveFn = scope => {\n          var value;\n\n          if (scope.has(_name)) {\n            value = scope.get(_name);\n          } else if (_name in math) {\n            value = getSafeProperty(math, _name);\n          } else {\n            return FunctionNode.onUndefinedFunction(_name);\n          }\n\n          if (typeof value === 'function') {\n            return value;\n          }\n\n          throw new TypeError(\"'\".concat(_name, \"' is not a function; its value is:\\n  \").concat(strin(value)));\n        };\n\n        if (isRaw) {\n          // pass unevaluated parameters (nodes) to the function\n          // \"raw\" evaluation\n          var rawArgs = this.args;\n          return function evalFunctionNode(scope, args, context) {\n            var fn = resolveFn(scope);\n            return fn(rawArgs, math, createSubScope(scope, args), scope);\n          };\n        } else {\n          // \"regular\" evaluation\n          switch (evalArgs.length) {\n            case 0:\n              return function evalFunctionNode(scope, args, context) {\n                var fn = resolveFn(scope);\n                return fn();\n              };\n\n            case 1:\n              return function evalFunctionNode(scope, args, context) {\n                var fn = resolveFn(scope);\n                var evalArg0 = evalArgs[0];\n                return fn(evalArg0(scope, args, context));\n              };\n\n            case 2:\n              return function evalFunctionNode(scope, args, context) {\n                var fn = resolveFn(scope);\n                var evalArg0 = evalArgs[0];\n                var evalArg1 = evalArgs[1];\n                return fn(evalArg0(scope, args, context), evalArg1(scope, args, context));\n              };\n\n            default:\n              return function evalFunctionNode(scope, args, context) {\n                var fn = resolveFn(scope);\n                var values = evalArgs.map(evalArg => evalArg(scope, args, context));\n                return fn(...values);\n              };\n          }\n        }\n      } else {\n        // the function symbol is an argName\n        var _rawArgs = this.args;\n        return function evalFunctionNode(scope, args, context) {\n          var fn = args[_name];\n\n          if (typeof fn !== 'function') {\n            throw new TypeError(\"Argument '\".concat(_name, \"' was not a function; received: \").concat(strin(fn)));\n          }\n\n          if (fn.rawArgs) {\n            return fn(_rawArgs, math, createSubScope(scope, args), scope); // \"raw\" evaluation\n          } else {\n            var values = evalArgs.map(evalArg => evalArg(scope, args, context));\n            return fn.apply(fn, values);\n          }\n        };\n      }\n    } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {\n      // execute the function with the right context: the object of the AccessorNode\n      var evalObject = this.fn.object._compile(math, argNames);\n\n      var prop = this.fn.index.getObjectProperty();\n      var _rawArgs2 = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        validateSafeMethod(object, prop);\n        var isRaw = object[prop] && object[prop].rawArgs;\n\n        if (isRaw) {\n          return object[prop](_rawArgs2, math, createSubScope(scope, args), scope); // \"raw\" evaluation\n        } else {\n          // \"regular\" evaluation\n          var values = evalArgs.map(evalArg => evalArg(scope, args, context));\n          return object[prop].apply(object, values);\n        }\n      };\n    } else {\n      // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()\n      // we have to dynamically determine whether the function has a rawArgs property\n      var fnExpr = this.fn.toString();\n\n      var evalFn = this.fn._compile(math, argNames);\n\n      var _rawArgs3 = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var fn = evalFn(scope, args, context);\n\n        if (typeof fn !== 'function') {\n          throw new TypeError(\"Expression '\".concat(fnExpr, \"' did not evaluate to a function; value is:\") + \"\\n  \".concat(strin(fn)));\n        }\n\n        if (fn.rawArgs) {\n          return fn(_rawArgs3, math, createSubScope(scope, args), scope); // \"raw\" evaluation\n        } else {\n          // \"regular\" evaluation\n          var values = evalArgs.map(evalArg => evalArg(scope, args, context));\n          return fn.apply(fn, values);\n        }\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionNode.prototype.forEach = function (callback) {\n    callback(this.fn, 'fn', this);\n\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new FunctionNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionNode.prototype.map = function (callback) {\n    var fn = this._ifNode(callback(this.fn, 'fn', this));\n\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new FunctionNode(fn, args);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionNode}\n   */\n\n\n  FunctionNode.prototype.clone = function () {\n    return new FunctionNode(this.fn, this.args.slice(0));\n  };\n  /**\n   * Throws an error 'Undefined function {name}'\n   * @param {string} name\n   */\n\n\n  FunctionNode.onUndefinedFunction = function (name) {\n    throw new Error('Undefined function ' + name);\n  }; // backup Node's toString function\n  // @private\n\n\n  var nodeToString = FunctionNode.prototype.toString;\n  /**\n   * Get string representation. (wrapper function)\n   * This overrides parts of Node's toString function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toString\n   * function.\n   *\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  FunctionNode.prototype.toString = function (options) {\n    var customString;\n    var name = this.fn.toString(options);\n\n    if (options && typeof options.handler === 'object' && hasOwnProperty(options.handler, name)) {\n      // callback is a map of callback functions\n      customString = options.handler[name](this, options);\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    } // fall back to Node's toString\n\n\n    return nodeToString.call(this, options);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toString = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toString(options);\n    });\n    var fn = isFunctionAssignmentNode(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options); // format the arguments like \"add(2, 4.2)\"\n\n    return fn + '(' + args.join(', ') + ')';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'FunctionNode',\n      fn: this.fn,\n      args: this.args\n    };\n  };\n  /**\n   * Instantiate an AssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionNode\", fn: ..., args: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionNode}\n   */\n\n\n  FunctionNode.fromJSON = function (json) {\n    return new FunctionNode(json.fn, json.args);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype.toHTML = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toHTML(options);\n    }); // format the arguments like \"add(2, 4.2)\"\n\n    return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + args.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n  };\n  /*\n   * Expand a LaTeX template\n   *\n   * @param {string} template\n   * @param {Node} node\n   * @param {Object} options\n   * @private\n   **/\n\n\n  function expandTemplate(template, node, options) {\n    var latex = ''; // Match everything of the form ${identifier} or ${identifier[2]} or $$\n    // while submatching identifier and 2 (in the second case)\n\n    var regex = /\\$(?:\\{([a-z_][a-z_0-9]*)(?:\\[([0-9]+)\\])?\\}|\\$)/gi;\n    var inputPos = 0; // position in the input string\n\n    var match;\n\n    while ((match = regex.exec(template)) !== null) {\n      // go through all matches\n      // add everything in front of the match to the LaTeX string\n      latex += template.substring(inputPos, match.index);\n      inputPos = match.index;\n\n      if (match[0] === '$$') {\n        // escaped dollar sign\n        latex += '$';\n        inputPos++;\n      } else {\n        // template parameter\n        inputPos += match[0].length;\n        var property = node[match[1]];\n\n        if (!property) {\n          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');\n        }\n\n        if (match[2] === undefined) {\n          // no square brackets\n          switch (typeof property) {\n            case 'string':\n              latex += property;\n              break;\n\n            case 'object':\n              if (isNode(property)) {\n                latex += property.toTex(options);\n              } else if (Array.isArray(property)) {\n                // make array of Nodes into comma separated list\n                latex += property.map(function (arg, index) {\n                  if (isNode(arg)) {\n                    return arg.toTex(options);\n                  }\n\n                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');\n                }).join(',');\n              } else {\n                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n              }\n\n              break;\n\n            default:\n              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n          }\n        } else {\n          // with square brackets\n          if (isNode(property[match[2]] && property[match[2]])) {\n            latex += property[match[2]].toTex(options);\n          } else {\n            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');\n          }\n        }\n      }\n    }\n\n    latex += template.slice(inputPos); // append rest of the template\n\n    return latex;\n  } // backup Node's toTex function\n  // @private\n\n\n  var nodeToTex = FunctionNode.prototype.toTex;\n  /**\n   * Get LaTeX representation. (wrapper function)\n   * This overrides parts of Node's toTex function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toTex\n   * function.\n   *\n   * @param {Object} options\n   * @return {string}\n   */\n\n  FunctionNode.prototype.toTex = function (options) {\n    var customTex;\n\n    if (options && typeof options.handler === 'object' && hasOwnProperty(options.handler, this.name)) {\n      // callback is a map of callback functions\n      customTex = options.handler[this.name](this, options);\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    } // fall back to Node's toTex\n\n\n    return nodeToTex.call(this, options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toTex = function (options) {\n    var args = this.args.map(function (arg) {\n      // get LaTeX of the arguments\n      return arg.toTex(options);\n    });\n    var latexConverter;\n\n    if (latexFunctions[this.name]) {\n      latexConverter = latexFunctions[this.name];\n    } // toTex property on the function itself\n\n\n    if (math[this.name] && (typeof math[this.name].toTex === 'function' || typeof math[this.name].toTex === 'object' || typeof math[this.name].toTex === 'string')) {\n      // .toTex is a callback function\n      latexConverter = math[this.name].toTex;\n    }\n\n    var customToTex;\n\n    switch (typeof latexConverter) {\n      case 'function':\n        // a callback function\n        customToTex = latexConverter(this, options);\n        break;\n\n      case 'string':\n        // a template string\n        customToTex = expandTemplate(latexConverter, this, options);\n        break;\n\n      case 'object':\n        // an object with different \"converters\" for different numbers of arguments\n        switch (typeof latexConverter[args.length]) {\n          case 'function':\n            customToTex = latexConverter[args.length](this, options);\n            break;\n\n          case 'string':\n            customToTex = expandTemplate(latexConverter[args.length], this, options);\n            break;\n        }\n\n    }\n\n    if (typeof customToTex !== 'undefined') {\n      return customToTex;\n    }\n\n    return expandTemplate(defaultTemplate, this, options);\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  FunctionNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.name;\n  };\n\n  return FunctionNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}