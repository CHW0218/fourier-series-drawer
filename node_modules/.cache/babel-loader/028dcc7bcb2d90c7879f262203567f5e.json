{"ast":null,"code":"import { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * @constructor RangeNode\n   * @extends {Node}\n   * create a range\n   * @param {Node} start  included lower-bound\n   * @param {Node} end    included upper-bound\n   * @param {Node} [step] optional step\n   */\n\n  function RangeNode(start, end, step) {\n    if (!(this instanceof RangeNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate inputs\n\n\n    if (!isNode(start)) throw new TypeError('Node expected');\n    if (!isNode(end)) throw new TypeError('Node expected');\n    if (step && !isNode(step)) throw new TypeError('Node expected');\n    if (arguments.length > 3) throw new Error('Too many arguments');\n    this.start = start; // included lower-bound\n\n    this.end = end; // included upper-bound\n\n    this.step = step || null; // optional step\n  }\n\n  RangeNode.prototype = new Node();\n  RangeNode.prototype.type = 'RangeNode';\n  RangeNode.prototype.isRangeNode = true;\n  /**\n   * Check whether the RangeNode needs the `end` symbol to be defined.\n   * This end is the size of the Matrix in current dimension.\n   * @return {boolean}\n   */\n\n  RangeNode.prototype.needsEnd = function () {\n    // find all `end` symbols in this RangeNode\n    var endSymbols = this.filter(function (node) {\n      return isSymbolNode(node) && node.name === 'end';\n    });\n    return endSymbols.length > 0;\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  RangeNode.prototype._compile = function (math, argNames) {\n    var range = math.range;\n\n    var evalStart = this.start._compile(math, argNames);\n\n    var evalEnd = this.end._compile(math, argNames);\n\n    if (this.step) {\n      var evalStep = this.step._compile(math, argNames);\n\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n      };\n    } else {\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RangeNode.prototype.forEach = function (callback) {\n    callback(this.start, 'start', this);\n    callback(this.end, 'end', this);\n\n    if (this.step) {\n      callback(this.step, 'step', this);\n    }\n  };\n  /**\n   * Create a new RangeNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RangeNode} Returns a transformed copy of the node\n   */\n\n\n  RangeNode.prototype.map = function (callback) {\n    return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RangeNode}\n   */\n\n\n  RangeNode.prototype.clone = function () {\n    return new RangeNode(this.start, this.end, this.step && this.step);\n  };\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @return {Object} parentheses\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(node, parenthesis) {\n    var precedence = getPrecedence(node, parenthesis);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = getPrecedence(node.end, parenthesis);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toString(options);\n\n    if (parens.start) {\n      start = '(' + start + ')';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toString(options);\n\n      if (parens.step) {\n        step = '(' + step + ')';\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toString(options);\n\n    if (parens.end) {\n      end = '(' + end + ')';\n    }\n\n    str += ':' + end;\n    return str;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RangeNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RangeNode',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate an RangeNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RangeNode}\n   */\n\n\n  RangeNode.fromJSON = function (json) {\n    return new RangeNode(json.start, json.end, json.step);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toHTML(options);\n\n    if (parens.start) {\n      start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toHTML(options);\n\n      if (parens.step) {\n        step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n    }\n\n    var end = this.end.toHTML(options);\n\n    if (parens.end) {\n      end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n    return str;\n  };\n  /**\n   * Get LaTeX representation\n   * @params {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis);\n    var str = this.start.toTex(options);\n\n    if (parens.start) {\n      str = \"\\\\left(\".concat(str, \"\\\\right)\");\n    }\n\n    if (this.step) {\n      var step = this.step.toTex(options);\n\n      if (parens.step) {\n        step = \"\\\\left(\".concat(step, \"\\\\right)\");\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toTex(options);\n\n    if (parens.end) {\n      end = \"\\\\left(\".concat(end, \"\\\\right)\");\n    }\n\n    str += ':' + end;\n    return str;\n  };\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isNode","isSymbolNode","factory","getPrecedence","name","dependencies","createRangeNode","_ref","Node","RangeNode","start","end","step","SyntaxError","TypeError","arguments","length","Error","prototype","type","isRangeNode","needsEnd","endSymbols","filter","node","_compile","math","argNames","range","evalStart","evalEnd","evalStep","evalRangeNode","scope","args","context","forEach","callback","map","_ifNode","clone","calculateNecessaryParentheses","parenthesis","precedence","parens","startPrecedence","stepPrecedence","endPrecedence","_toString","options","str","toString","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","isClass"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/expression/node/RangeNode.js"],"sourcesContent":["import { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * @constructor RangeNode\n   * @extends {Node}\n   * create a range\n   * @param {Node} start  included lower-bound\n   * @param {Node} end    included upper-bound\n   * @param {Node} [step] optional step\n   */\n  function RangeNode(start, end, step) {\n    if (!(this instanceof RangeNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate inputs\n\n\n    if (!isNode(start)) throw new TypeError('Node expected');\n    if (!isNode(end)) throw new TypeError('Node expected');\n    if (step && !isNode(step)) throw new TypeError('Node expected');\n    if (arguments.length > 3) throw new Error('Too many arguments');\n    this.start = start; // included lower-bound\n\n    this.end = end; // included upper-bound\n\n    this.step = step || null; // optional step\n  }\n\n  RangeNode.prototype = new Node();\n  RangeNode.prototype.type = 'RangeNode';\n  RangeNode.prototype.isRangeNode = true;\n  /**\n   * Check whether the RangeNode needs the `end` symbol to be defined.\n   * This end is the size of the Matrix in current dimension.\n   * @return {boolean}\n   */\n\n  RangeNode.prototype.needsEnd = function () {\n    // find all `end` symbols in this RangeNode\n    var endSymbols = this.filter(function (node) {\n      return isSymbolNode(node) && node.name === 'end';\n    });\n    return endSymbols.length > 0;\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  RangeNode.prototype._compile = function (math, argNames) {\n    var range = math.range;\n\n    var evalStart = this.start._compile(math, argNames);\n\n    var evalEnd = this.end._compile(math, argNames);\n\n    if (this.step) {\n      var evalStep = this.step._compile(math, argNames);\n\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n      };\n    } else {\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RangeNode.prototype.forEach = function (callback) {\n    callback(this.start, 'start', this);\n    callback(this.end, 'end', this);\n\n    if (this.step) {\n      callback(this.step, 'step', this);\n    }\n  };\n  /**\n   * Create a new RangeNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RangeNode} Returns a transformed copy of the node\n   */\n\n\n  RangeNode.prototype.map = function (callback) {\n    return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RangeNode}\n   */\n\n\n  RangeNode.prototype.clone = function () {\n    return new RangeNode(this.start, this.end, this.step && this.step);\n  };\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @return {Object} parentheses\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(node, parenthesis) {\n    var precedence = getPrecedence(node, parenthesis);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = getPrecedence(node.end, parenthesis);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toString(options);\n\n    if (parens.start) {\n      start = '(' + start + ')';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toString(options);\n\n      if (parens.step) {\n        step = '(' + step + ')';\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toString(options);\n\n    if (parens.end) {\n      end = '(' + end + ')';\n    }\n\n    str += ':' + end;\n    return str;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RangeNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RangeNode',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate an RangeNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RangeNode}\n   */\n\n\n  RangeNode.fromJSON = function (json) {\n    return new RangeNode(json.start, json.end, json.step);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toHTML(options);\n\n    if (parens.start) {\n      start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toHTML(options);\n\n      if (parens.step) {\n        step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n    }\n\n    var end = this.end.toHTML(options);\n\n    if (parens.end) {\n      end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n    return str;\n  };\n  /**\n   * Get LaTeX representation\n   * @params {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis);\n    var str = this.start.toTex(options);\n\n    if (parens.start) {\n      str = \"\\\\left(\".concat(str, \"\\\\right)\");\n    }\n\n    if (this.step) {\n      var step = this.step.toTex(options);\n\n      if (parens.step) {\n        step = \"\\\\left(\".concat(step, \"\\\\right)\");\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toTex(options);\n\n    if (parens.end) {\n      end = \"\\\\left(\".concat(end, \"\\\\right)\");\n    }\n\n    str += ':' + end;\n    return str;\n  };\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}