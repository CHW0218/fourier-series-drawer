{"ast":null,"code":"import { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'transpose';\nvar dependencies = ['typed', 'matrix'];\nexport var createTranspose = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix;\n  /**\n   * Transpose a matrix. All values of the matrix are reflected over its\n   * main diagonal. Only applicable to two dimensional matrices containing\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\n   * vectors and scalars return the input unchanged.\n   *\n   * Syntax:\n   *\n   *     math.transpose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\n   *\n   * See also:\n   *\n   *     diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be transposed\n   * @return {Array | Matrix}   The transposed matrix\n   */\n\n  return typed('transpose', {\n    Array: function Array(x) {\n      // use dense matrix implementation\n      return this(matrix(x)).valueOf();\n    },\n    Matrix: function Matrix(x) {\n      // matrix size\n      var size = x.size(); // result\n\n      var c; // process dimensions\n\n      switch (size.length) {\n        case 1:\n          // vector\n          c = x.clone();\n          break;\n\n        case 2:\n          {\n            // rows and columns\n            var rows = size[0];\n            var columns = size[1]; // check columns\n\n            if (columns === 0) {\n              // throw exception\n              throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');\n            } // process storage format\n\n\n            switch (x.storage()) {\n              case 'dense':\n                c = _denseTranspose(x, rows, columns);\n                break;\n\n              case 'sparse':\n                c = _sparseTranspose(x, rows, columns);\n                break;\n            }\n          }\n          break;\n\n        default:\n          // multi dimensional\n          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(this._size) + ')');\n      }\n\n      return c;\n    },\n    // scalars\n    any: function any(x) {\n      return clone(x);\n    }\n  });\n\n  function _denseTranspose(m, rows, columns) {\n    // matrix array\n    var data = m._data; // transposed matrix data\n\n    var transposed = [];\n    var transposedRow; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // initialize row\n      transposedRow = transposed[j] = []; // loop rows\n\n      for (var i = 0; i < rows; i++) {\n        // set data\n        transposedRow[i] = clone(data[i][j]);\n      }\n    } // return matrix\n\n\n    return m.createDenseMatrix({\n      data: transposed,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n\n  function _sparseTranspose(m, rows, columns) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result matrices\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // row counts\n\n    var w = [];\n\n    for (var x = 0; x < rows; x++) {\n      w[x] = 0;\n    } // vars\n\n\n    var p, l, j; // loop values in matrix\n\n    for (p = 0, l = index.length; p < l; p++) {\n      // number of values in row\n      w[index[p]]++;\n    } // cumulative sum\n\n\n    var sum = 0; // initialize cptr with the cummulative sum of row counts\n\n    for (var i = 0; i < rows; i++) {\n      // update cptr\n      cptr.push(sum); // update sum\n\n      sum += w[i]; // update w\n\n      w[i] = cptr[i];\n    } // update cptr\n\n\n    cptr.push(sum); // loop columns\n\n    for (j = 0; j < columns; j++) {\n      // values & index in column\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\n        // C values & index\n        var q = w[index[k]]++; // C[j, i] = A[i, j]\n\n        cindex[q] = j; // check we need to process values (pattern matrix)\n\n        if (values) {\n          cvalues[q] = clone(values[k]);\n        }\n      }\n    } // return matrix\n\n\n    return m.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n});","map":{"version":3,"names":["clone","format","factory","name","dependencies","createTranspose","_ref","typed","matrix","Array","x","valueOf","Matrix","size","c","length","rows","columns","RangeError","storage","_denseTranspose","_sparseTranspose","_size","any","m","data","_data","transposed","transposedRow","j","i","createDenseMatrix","datatype","_datatype","values","_values","index","_index","ptr","_ptr","cvalues","undefined","cindex","cptr","w","p","l","sum","push","k0","k1","k","q","createSparseMatrix"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/matrix/transpose.js"],"sourcesContent":["import { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'transpose';\nvar dependencies = ['typed', 'matrix'];\nexport var createTranspose = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix\n  } = _ref;\n\n  /**\n   * Transpose a matrix. All values of the matrix are reflected over its\n   * main diagonal. Only applicable to two dimensional matrices containing\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\n   * vectors and scalars return the input unchanged.\n   *\n   * Syntax:\n   *\n   *     math.transpose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\n   *\n   * See also:\n   *\n   *     diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be transposed\n   * @return {Array | Matrix}   The transposed matrix\n   */\n  return typed('transpose', {\n    Array: function Array(x) {\n      // use dense matrix implementation\n      return this(matrix(x)).valueOf();\n    },\n    Matrix: function Matrix(x) {\n      // matrix size\n      var size = x.size(); // result\n\n      var c; // process dimensions\n\n      switch (size.length) {\n        case 1:\n          // vector\n          c = x.clone();\n          break;\n\n        case 2:\n          {\n            // rows and columns\n            var rows = size[0];\n            var columns = size[1]; // check columns\n\n            if (columns === 0) {\n              // throw exception\n              throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');\n            } // process storage format\n\n\n            switch (x.storage()) {\n              case 'dense':\n                c = _denseTranspose(x, rows, columns);\n                break;\n\n              case 'sparse':\n                c = _sparseTranspose(x, rows, columns);\n                break;\n            }\n          }\n          break;\n\n        default:\n          // multi dimensional\n          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(this._size) + ')');\n      }\n\n      return c;\n    },\n    // scalars\n    any: function any(x) {\n      return clone(x);\n    }\n  });\n\n  function _denseTranspose(m, rows, columns) {\n    // matrix array\n    var data = m._data; // transposed matrix data\n\n    var transposed = [];\n    var transposedRow; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // initialize row\n      transposedRow = transposed[j] = []; // loop rows\n\n      for (var i = 0; i < rows; i++) {\n        // set data\n        transposedRow[i] = clone(data[i][j]);\n      }\n    } // return matrix\n\n\n    return m.createDenseMatrix({\n      data: transposed,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n\n  function _sparseTranspose(m, rows, columns) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result matrices\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // row counts\n\n    var w = [];\n\n    for (var x = 0; x < rows; x++) {\n      w[x] = 0;\n    } // vars\n\n\n    var p, l, j; // loop values in matrix\n\n    for (p = 0, l = index.length; p < l; p++) {\n      // number of values in row\n      w[index[p]]++;\n    } // cumulative sum\n\n\n    var sum = 0; // initialize cptr with the cummulative sum of row counts\n\n    for (var i = 0; i < rows; i++) {\n      // update cptr\n      cptr.push(sum); // update sum\n\n      sum += w[i]; // update w\n\n      w[i] = cptr[i];\n    } // update cptr\n\n\n    cptr.push(sum); // loop columns\n\n    for (j = 0; j < columns; j++) {\n      // values & index in column\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\n        // C values & index\n        var q = w[index[k]]++; // C[j, i] = A[i, j]\n\n        cindex[q] = j; // check we need to process values (pattern matrix)\n\n        if (values) {\n          cvalues[q] = clone(values[k]);\n        }\n      }\n    } // return matrix\n\n\n    return m.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}