{"ast":null,"code":"/* eslint-disable no-loss-of-precision */\n// References\n// ----------\n// [1] Hare, \"Computing the Principal Branch of log-Gamma\", Journal of Algorithms, 1997.\n// [2] https://math.stackexchange.com/questions/1338753/how-do-i-calculate-values-for-gamma-function-with-complex-arguments\nimport { lgammaNumber, lnSqrt2PI } from '../../plain/number/index.js';\nimport { factory } from '../../utils/factory.js';\nimport { copysign } from '../../utils/number.js';\nvar name = 'lgamma';\nvar dependencies = ['Complex', 'typed'];\nexport var createLgamma = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var _Complex = _ref.Complex,\n      typed = _ref.typed; // Stirling series is non-convergent, we need to use the recurrence `lgamma(z) = lgamma(z+1) - log z` to get\n  // sufficient accuracy.\n  //\n  // These two values are copied from Scipy implementation:\n  // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L37\n\n  var SMALL_RE = 7;\n  var SMALL_IM = 7;\n  /**\n   * The coefficients are B[2*n]/(2*n*(2*n - 1)) where B[2*n] is the (2*n)th Bernoulli number. See (1.1) in [1].\n   *\n   * If you cannot access the paper, can also get these values from the formula in [2].\n   *\n   *    1 /     12 = 0.00833333333333333333333333333333\n   *    1 /    360 = 0.00277777777777777777777777777778\n   * ...\n   * 3617 / 133400 = 0.02955065359477124183006535947712\n   */\n\n  var coeffs = [-2.955065359477124183e-2, 6.4102564102564102564e-3, -1.9175269175269175269e-3, 8.4175084175084175084e-4, -5.952380952380952381e-4, 7.9365079365079365079e-4, -2.7777777777777777778e-3, 8.3333333333333333333e-2];\n  /**\n   * Logarithm of the gamma function for real, positive numbers and complex numbers,\n   * using Lanczos approximation for numbers and Stirling series for complex numbers.\n   *\n   * Syntax:\n   *\n   *    math.lgamma(n)\n   *\n   * Examples:\n   *\n   *    math.lgamma(5)       // returns 3.178053830347945\n   *    math.lgamma(0)       // returns Infinity\n   *    math.lgamma(-0.5)    // returns NaN\n   *    math.lgamma(math.i)  // returns -0.6509231993018536 - 1.8724366472624294i\n   *\n   * See also:\n   *\n   *    gamma\n   *\n   * @param {number | Complex} n   A real or complex number\n   * @return {number | Complex}    The log gamma of `n`\n   */\n\n  return typed(name, {\n    number: lgammaNumber,\n    Complex: function Complex(n) {\n      var TWOPI = 6.2831853071795864769252842; // 2*pi\n\n      var LOGPI = 1.1447298858494001741434262; // log(pi)\n\n      var REFLECTION = 0.1;\n\n      if (n.isNaN()) {\n        return new _Complex(NaN, NaN);\n      } else if (n.im === 0) {\n        return new _Complex(lgammaNumber(n.re), 0);\n      } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {\n        return lgammaStirling(n);\n      } else if (n.re <= REFLECTION) {\n        // Reflection formula. see Proposition 3.1 in [1]\n        var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25); // TODO: `complex.js sin` doesn't have extremely high precision, so this value `a` may lose a little precision,\n        // causing the computation results to be less accurate than the lgamma of real numbers\n\n        var a = n.mul(Math.PI).sin().log();\n        var b = this(new _Complex(1 - n.re, -n.im));\n        return new _Complex(LOGPI, tmp).sub(a).sub(b);\n      } else if (n.im >= 0) {\n        return lgammaRecurrence(n);\n      } else {\n        return lgammaRecurrence(n.conjugate()).conjugate();\n      }\n    },\n    BigNumber: function BigNumber() {\n      throw new Error(\"mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber\");\n    }\n  });\n\n  function lgammaStirling(z) {\n    // formula ref in [2]\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L101\n    // left part\n    // x (log(x) - 1) + 1/2 (log(2PI) - log(x))\n    // => (x - 0.5) * log(x) - x + log(2PI) / 2\n    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI); // right part\n\n    var rz = new _Complex(1, 0).div(z);\n    var rzz = rz.div(z);\n    var a = coeffs[0];\n    var b = coeffs[1];\n    var r = 2 * rzz.re;\n    var s = rzz.re * rzz.re + rzz.im * rzz.im;\n\n    for (var i = 2; i < 8; i++) {\n      var tmp = b;\n      b = -s * a + coeffs[i];\n      a = r * a + tmp;\n    }\n\n    var rightPart = rz.mul(rzz.mul(a).add(b)); // plus left and right\n\n    return leftPart.add(rightPart);\n  }\n\n  function lgammaRecurrence(z) {\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L78\n    var signflips = 0;\n    var sb = 0;\n    var shiftprod = z;\n    z = z.add(1);\n\n    while (z.re <= SMALL_RE) {\n      shiftprod = shiftprod.mul(z);\n      var nsb = shiftprod.im < 0 ? 1 : 0;\n      if (nsb !== 0 && sb === 0) signflips++;\n      sb = nsb;\n      z = z.add(1);\n    }\n\n    return lgammaStirling(z).sub(shiftprod.log()).sub(new _Complex(0, signflips * 2 * Math.PI * 1));\n  }\n});","map":{"version":3,"names":["lgammaNumber","lnSqrt2PI","factory","copysign","name","dependencies","createLgamma","_ref","_Complex","Complex","typed","SMALL_RE","SMALL_IM","coeffs","number","n","TWOPI","LOGPI","REFLECTION","isNaN","NaN","im","re","Math","abs","lgammaStirling","tmp","floor","a","mul","PI","sin","log","b","sub","lgammaRecurrence","conjugate","BigNumber","Error","z","leftPart","add","rz","div","rzz","r","s","i","rightPart","signflips","sb","shiftprod","nsb"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/probability/lgamma.js"],"sourcesContent":["/* eslint-disable no-loss-of-precision */\n// References\n// ----------\n// [1] Hare, \"Computing the Principal Branch of log-Gamma\", Journal of Algorithms, 1997.\n// [2] https://math.stackexchange.com/questions/1338753/how-do-i-calculate-values-for-gamma-function-with-complex-arguments\nimport { lgammaNumber, lnSqrt2PI } from '../../plain/number/index.js';\nimport { factory } from '../../utils/factory.js';\nimport { copysign } from '../../utils/number.js';\nvar name = 'lgamma';\nvar dependencies = ['Complex', 'typed'];\nexport var createLgamma = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Complex: _Complex,\n    typed\n  } = _ref;\n  // Stirling series is non-convergent, we need to use the recurrence `lgamma(z) = lgamma(z+1) - log z` to get\n  // sufficient accuracy.\n  //\n  // These two values are copied from Scipy implementation:\n  // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L37\n  var SMALL_RE = 7;\n  var SMALL_IM = 7;\n  /**\n   * The coefficients are B[2*n]/(2*n*(2*n - 1)) where B[2*n] is the (2*n)th Bernoulli number. See (1.1) in [1].\n   *\n   * If you cannot access the paper, can also get these values from the formula in [2].\n   *\n   *    1 /     12 = 0.00833333333333333333333333333333\n   *    1 /    360 = 0.00277777777777777777777777777778\n   * ...\n   * 3617 / 133400 = 0.02955065359477124183006535947712\n   */\n\n  var coeffs = [-2.955065359477124183e-2, 6.4102564102564102564e-3, -1.9175269175269175269e-3, 8.4175084175084175084e-4, -5.952380952380952381e-4, 7.9365079365079365079e-4, -2.7777777777777777778e-3, 8.3333333333333333333e-2];\n  /**\n   * Logarithm of the gamma function for real, positive numbers and complex numbers,\n   * using Lanczos approximation for numbers and Stirling series for complex numbers.\n   *\n   * Syntax:\n   *\n   *    math.lgamma(n)\n   *\n   * Examples:\n   *\n   *    math.lgamma(5)       // returns 3.178053830347945\n   *    math.lgamma(0)       // returns Infinity\n   *    math.lgamma(-0.5)    // returns NaN\n   *    math.lgamma(math.i)  // returns -0.6509231993018536 - 1.8724366472624294i\n   *\n   * See also:\n   *\n   *    gamma\n   *\n   * @param {number | Complex} n   A real or complex number\n   * @return {number | Complex}    The log gamma of `n`\n   */\n\n  return typed(name, {\n    number: lgammaNumber,\n    Complex: function Complex(n) {\n      var TWOPI = 6.2831853071795864769252842; // 2*pi\n\n      var LOGPI = 1.1447298858494001741434262; // log(pi)\n\n      var REFLECTION = 0.1;\n\n      if (n.isNaN()) {\n        return new _Complex(NaN, NaN);\n      } else if (n.im === 0) {\n        return new _Complex(lgammaNumber(n.re), 0);\n      } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {\n        return lgammaStirling(n);\n      } else if (n.re <= REFLECTION) {\n        // Reflection formula. see Proposition 3.1 in [1]\n        var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25); // TODO: `complex.js sin` doesn't have extremely high precision, so this value `a` may lose a little precision,\n        // causing the computation results to be less accurate than the lgamma of real numbers\n\n        var a = n.mul(Math.PI).sin().log();\n        var b = this(new _Complex(1 - n.re, -n.im));\n        return new _Complex(LOGPI, tmp).sub(a).sub(b);\n      } else if (n.im >= 0) {\n        return lgammaRecurrence(n);\n      } else {\n        return lgammaRecurrence(n.conjugate()).conjugate();\n      }\n    },\n    BigNumber: function BigNumber() {\n      throw new Error(\"mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber\");\n    }\n  });\n\n  function lgammaStirling(z) {\n    // formula ref in [2]\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L101\n    // left part\n    // x (log(x) - 1) + 1/2 (log(2PI) - log(x))\n    // => (x - 0.5) * log(x) - x + log(2PI) / 2\n    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI); // right part\n\n    var rz = new _Complex(1, 0).div(z);\n    var rzz = rz.div(z);\n    var a = coeffs[0];\n    var b = coeffs[1];\n    var r = 2 * rzz.re;\n    var s = rzz.re * rzz.re + rzz.im * rzz.im;\n\n    for (var i = 2; i < 8; i++) {\n      var tmp = b;\n      b = -s * a + coeffs[i];\n      a = r * a + tmp;\n    }\n\n    var rightPart = rz.mul(rzz.mul(a).add(b)); // plus left and right\n\n    return leftPart.add(rightPart);\n  }\n\n  function lgammaRecurrence(z) {\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L78\n    var signflips = 0;\n    var sb = 0;\n    var shiftprod = z;\n    z = z.add(1);\n\n    while (z.re <= SMALL_RE) {\n      shiftprod = shiftprod.mul(z);\n      var nsb = shiftprod.im < 0 ? 1 : 0;\n      if (nsb !== 0 && sb === 0) signflips++;\n      sb = nsb;\n      z = z.add(1);\n    }\n\n    return lgammaStirling(z).sub(shiftprod.log()).sub(new _Complex(0, signflips * 2 * Math.PI * 1));\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}