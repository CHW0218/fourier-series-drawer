{"ast":null,"code":"import { getPrecedence } from '../operators.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nexport var createRelationalNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * A node representing a chained conditional expression, such as 'x > y > z'\n   *\n   * @param {String[]} conditionals   An array of conditional operators used to compare the parameters\n   * @param {Node[]} params   The parameters that will be compared\n   *\n   * @constructor RelationalNode\n   * @extends {Node}\n   */\n\n  function RelationalNode(conditionals, params) {\n    if (!(this instanceof RelationalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');\n    if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');\n    if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');\n    this.conditionals = conditionals;\n    this.params = params;\n  }\n\n  RelationalNode.prototype = new Node();\n  RelationalNode.prototype.type = 'RelationalNode';\n  RelationalNode.prototype.isRelationalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  RelationalNode.prototype._compile = function (math, argNames) {\n    var self = this;\n    var compiled = this.params.map(function (p) {\n      return p._compile(math, argNames);\n    });\n    return function evalRelationalNode(scope, args, context) {\n      var evalLhs;\n      var evalRhs = compiled[0](scope, args, context);\n\n      for (var i = 0; i < self.conditionals.length; i++) {\n        evalLhs = evalRhs;\n        evalRhs = compiled[i + 1](scope, args, context);\n        var condFn = getSafeProperty(math, self.conditionals[i]);\n\n        if (!condFn(evalLhs, evalRhs)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RelationalNode.prototype.forEach = function (callback) {\n    var _this = this;\n\n    this.params.forEach(function (n, i) {\n      return callback(n, 'params[' + i + ']', _this);\n    }, this);\n  };\n  /**\n   * Create a new RelationalNode having its childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RelationalNode} Returns a transformed copy of the node\n   */\n\n\n  RelationalNode.prototype.map = function (callback) {\n    var _this2 = this;\n\n    return new RelationalNode(this.conditionals.slice(), this.params.map(function (n, i) {\n      return _this2._ifNode(callback(n, 'params[' + i + ']', _this2));\n    }, this));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RelationalNode}\n   */\n\n\n  RelationalNode.prototype.clone = function () {\n    return new RelationalNode(this.conditionals, this.params);\n  };\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RelationalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RelationalNode',\n      conditionals: this.conditionals,\n      params: this.params\n    };\n  };\n  /**\n   * Instantiate a RelationalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RelationalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RelationalNode}\n   */\n\n\n  RelationalNode.fromJSON = function (json) {\n    return new RelationalNode(json.conditionals, json.params);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n    });\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["getPrecedence","escape","getSafeProperty","latexOperators","factory","name","dependencies","createRelationalNode","_ref","Node","RelationalNode","conditionals","params","SyntaxError","Array","isArray","TypeError","length","prototype","type","isRelationalNode","_compile","math","argNames","self","compiled","map","p","evalRelationalNode","scope","args","context","evalLhs","evalRhs","i","condFn","forEach","callback","n","slice","_ifNode","clone","_toString","options","parenthesis","precedence","paramStrings","index","paramPrecedence","toString","operatorMap","equal","unequal","smaller","larger","smallerEq","largerEq","ret","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isClass","isNode"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/expression/node/RelationalNode.js"],"sourcesContent":["import { getPrecedence } from '../operators.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nexport var createRelationalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * A node representing a chained conditional expression, such as 'x > y > z'\n   *\n   * @param {String[]} conditionals   An array of conditional operators used to compare the parameters\n   * @param {Node[]} params   The parameters that will be compared\n   *\n   * @constructor RelationalNode\n   * @extends {Node}\n   */\n  function RelationalNode(conditionals, params) {\n    if (!(this instanceof RelationalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');\n    if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');\n    if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');\n    this.conditionals = conditionals;\n    this.params = params;\n  }\n\n  RelationalNode.prototype = new Node();\n  RelationalNode.prototype.type = 'RelationalNode';\n  RelationalNode.prototype.isRelationalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  RelationalNode.prototype._compile = function (math, argNames) {\n    var self = this;\n    var compiled = this.params.map(p => p._compile(math, argNames));\n    return function evalRelationalNode(scope, args, context) {\n      var evalLhs;\n      var evalRhs = compiled[0](scope, args, context);\n\n      for (var i = 0; i < self.conditionals.length; i++) {\n        evalLhs = evalRhs;\n        evalRhs = compiled[i + 1](scope, args, context);\n        var condFn = getSafeProperty(math, self.conditionals[i]);\n\n        if (!condFn(evalLhs, evalRhs)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RelationalNode.prototype.forEach = function (callback) {\n    this.params.forEach((n, i) => callback(n, 'params[' + i + ']', this), this);\n  };\n  /**\n   * Create a new RelationalNode having its childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RelationalNode} Returns a transformed copy of the node\n   */\n\n\n  RelationalNode.prototype.map = function (callback) {\n    return new RelationalNode(this.conditionals.slice(), this.params.map((n, i) => this._ifNode(callback(n, 'params[' + i + ']', this)), this));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RelationalNode}\n   */\n\n\n  RelationalNode.prototype.clone = function () {\n    return new RelationalNode(this.conditionals, this.params);\n  };\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RelationalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RelationalNode',\n      conditionals: this.conditionals,\n      params: this.params\n    };\n  };\n  /**\n   * Instantiate a RelationalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RelationalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RelationalNode}\n   */\n\n\n  RelationalNode.fromJSON = function (json) {\n    return new RelationalNode(json.conditionals, json.params);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n    });\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}