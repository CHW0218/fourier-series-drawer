{"ast":null,"code":"import _toConsumableArray from \"/Users/ayao/vscode/fourier-series-drawer/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { map } from '../../utils/array.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isArray, isConstantNode, isMatrix, isNode, isString, typeOf } from '../../utils/is.js';\nimport { escape } from '../../utils/string.js';\nvar name = 'IndexNode';\nvar dependencies = ['Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node,\n      size = _ref.size;\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (dimension, i) {\n      var needsEnd = dimension.filter(function (node) {\n        return node.isSymbolNode && node.name === 'end';\n      }).length > 0;\n\n      if (needsEnd) {\n        // SymbolNode 'end' is used inside the index,\n        // like in `A[end]` or `A[end - 2]`\n        var childArgNames = Object.create(argNames);\n        childArgNames.end = true;\n\n        var _evalDimension = dimension._compile(math, childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          if (!isMatrix(context) && !isArray(context) && !isString(context)) {\n            throw new TypeError('Cannot resolve \"end\": ' + 'context must be a Matrix, Array, or string but is ' + typeOf(context));\n          }\n\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return _evalDimension(scope, childArgs, context);\n        };\n      } else {\n        // SymbolNode `end` not used\n        return dimension._compile(math, argNames);\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index.apply(void 0, _toConsumableArray(dimensions));\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  };\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["map","getSafeProperty","factory","isArray","isConstantNode","isMatrix","isNode","isString","typeOf","escape","name","dependencies","createIndexNode","_ref","Node","size","IndexNode","dimensions","dotNotation","SyntaxError","Array","every","TypeError","isObjectProperty","Error","prototype","type","isIndexNode","_compile","math","argNames","evalDimensions","dimension","i","needsEnd","filter","node","isSymbolNode","length","childArgNames","Object","create","end","_evalDimension","evalDimension","scope","args","context","s","valueOf","childArgs","index","evalIndexNode","forEach","callback","_ifNode","clone","slice","value","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","range","toTex","isClass"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/expression/node/IndexNode.js"],"sourcesContent":["import { map } from '../../utils/array.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isArray, isConstantNode, isMatrix, isNode, isString, typeOf } from '../../utils/is.js';\nimport { escape } from '../../utils/string.js';\nvar name = 'IndexNode';\nvar dependencies = ['Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node,\n    size\n  } = _ref;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (dimension, i) {\n      var needsEnd = dimension.filter(node => node.isSymbolNode && node.name === 'end').length > 0;\n\n      if (needsEnd) {\n        // SymbolNode 'end' is used inside the index,\n        // like in `A[end]` or `A[end - 2]`\n        var childArgNames = Object.create(argNames);\n        childArgNames.end = true;\n\n        var _evalDimension = dimension._compile(math, childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          if (!isMatrix(context) && !isArray(context) && !isString(context)) {\n            throw new TypeError('Cannot resolve \"end\": ' + 'context must be a Matrix, Array, or string but is ' + typeOf(context));\n          }\n\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return _evalDimension(scope, childArgs, context);\n        };\n      } else {\n        // SymbolNode `end` not used\n        return dimension._compile(math, argNames);\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index(...dimensions);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  };\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}