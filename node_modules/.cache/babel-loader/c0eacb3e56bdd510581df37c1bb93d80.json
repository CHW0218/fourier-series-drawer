{"ast":null,"code":"/**\n * Create a typed-function which checks the types of the arguments and\n * can match them against multiple provided signatures. The typed-function\n * automatically converts inputs in order to find a matching signature.\n * Typed functions throw informative errors in case of wrong input arguments.\n *\n * See the library [typed-function](https://github.com/josdejong/typed-function)\n * for detailed documentation.\n *\n * Syntax:\n *\n *     math.typed(name, signatures) : function\n *     math.typed(signatures) : function\n *\n * Examples:\n *\n *     // create a typed function with multiple types per argument (type union)\n *     const fn2 = typed({\n *       'number | boolean': function (b) {\n *         return 'b is a number or boolean'\n *       },\n *       'string, number | boolean': function (a, b) {\n *         return 'a is a string, b is a number or boolean'\n *       }\n *     })\n *\n *     // create a typed function with an any type argument\n *     const log = typed({\n *       'string, any': function (event, data) {\n *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))\n *       }\n *     })\n *\n * @param {string} [name]                          Optional name for the typed-function\n * @param {Object<string, function>} signatures   Object with one or multiple function signatures\n * @returns {function} The created typed-function.\n */\nimport { isAccessorNode, isArray, isArrayNode, isAssignmentNode, isBigNumber, isBlockNode, isBoolean, isChain, isComplex, isConditionalNode, isConstantNode, isDate, isDenseMatrix, isFraction, isFunction, isFunctionAssignmentNode, isFunctionNode, isHelp, isIndex, isIndexNode, isMatrix, isNode, isNull, isNumber, isObject, isObjectNode, isOperatorNode, isParenthesisNode, isRange, isRangeNode, isRegExp, isResultSet, isSparseMatrix, isString, isSymbolNode, isUndefined, isUnit } from '../../utils/is.js';\nimport typedFunction from 'typed-function';\nimport { digits } from '../../utils/number.js';\nimport { factory } from '../../utils/factory.js';\nimport { isMap } from '../../utils/map.js'; // returns a new instance of typed-function\n\nvar _createTyped2 = function _createTyped() {\n  // initially, return the original instance of typed-function\n  // consecutively, return a new instance from typed.create.\n  _createTyped2 = typedFunction.create;\n  return typedFunction;\n};\n\nvar dependencies = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];\n/**\n * Factory function for creating a new typed instance\n * @param {Object} dependencies   Object with data types like Complex and BigNumber\n * @returns {Function}\n */\n\nexport var createTyped = /* #__PURE__ */factory('typed', dependencies, function createTyped(_ref) {\n  var BigNumber = _ref.BigNumber,\n      Complex = _ref.Complex,\n      DenseMatrix = _ref.DenseMatrix,\n      Fraction = _ref.Fraction; // TODO: typed-function must be able to silently ignore signatures with unknown data types\n  // get a new instance of typed-function\n\n  var typed = _createTyped2(); // define all types. The order of the types determines in which order function\n  // arguments are type-checked (so for performance it's important to put the\n  // most used types first).\n\n\n  typed.types = [{\n    name: 'number',\n    test: isNumber\n  }, {\n    name: 'Complex',\n    test: isComplex\n  }, {\n    name: 'BigNumber',\n    test: isBigNumber\n  }, {\n    name: 'Fraction',\n    test: isFraction\n  }, {\n    name: 'Unit',\n    test: isUnit\n  }, {\n    name: 'string',\n    test: isString\n  }, {\n    name: 'Chain',\n    test: isChain\n  }, {\n    name: 'Array',\n    test: isArray\n  }, {\n    name: 'Matrix',\n    test: isMatrix\n  }, {\n    name: 'DenseMatrix',\n    test: isDenseMatrix\n  }, {\n    name: 'SparseMatrix',\n    test: isSparseMatrix\n  }, {\n    name: 'Range',\n    test: isRange\n  }, {\n    name: 'Index',\n    test: isIndex\n  }, {\n    name: 'boolean',\n    test: isBoolean\n  }, {\n    name: 'ResultSet',\n    test: isResultSet\n  }, {\n    name: 'Help',\n    test: isHelp\n  }, {\n    name: 'function',\n    test: isFunction\n  }, {\n    name: 'Date',\n    test: isDate\n  }, {\n    name: 'RegExp',\n    test: isRegExp\n  }, {\n    name: 'null',\n    test: isNull\n  }, {\n    name: 'undefined',\n    test: isUndefined\n  }, {\n    name: 'AccessorNode',\n    test: isAccessorNode\n  }, {\n    name: 'ArrayNode',\n    test: isArrayNode\n  }, {\n    name: 'AssignmentNode',\n    test: isAssignmentNode\n  }, {\n    name: 'BlockNode',\n    test: isBlockNode\n  }, {\n    name: 'ConditionalNode',\n    test: isConditionalNode\n  }, {\n    name: 'ConstantNode',\n    test: isConstantNode\n  }, {\n    name: 'FunctionNode',\n    test: isFunctionNode\n  }, {\n    name: 'FunctionAssignmentNode',\n    test: isFunctionAssignmentNode\n  }, {\n    name: 'IndexNode',\n    test: isIndexNode\n  }, {\n    name: 'Node',\n    test: isNode\n  }, {\n    name: 'ObjectNode',\n    test: isObjectNode\n  }, {\n    name: 'OperatorNode',\n    test: isOperatorNode\n  }, {\n    name: 'ParenthesisNode',\n    test: isParenthesisNode\n  }, {\n    name: 'RangeNode',\n    test: isRangeNode\n  }, {\n    name: 'SymbolNode',\n    test: isSymbolNode\n  }, {\n    name: 'Map',\n    test: isMap\n  }, {\n    name: 'Object',\n    test: isObject\n  } // order 'Object' last, it matches on other classes too\n  ];\n  typed.conversions = [{\n    from: 'number',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      } // note: conversion from number to BigNumber can fail if x has >15 digits\n\n\n      if (digits(x) > 15) {\n        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');\n      }\n\n      return new BigNumber(x);\n    }\n  }, {\n    from: 'number',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x, 0);\n    }\n  }, {\n    from: 'number',\n    to: 'string',\n    convert: function convert(x) {\n      return x + '';\n    }\n  }, {\n    from: 'BigNumber',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.toNumber(), 0);\n    }\n  }, {\n    from: 'Fraction',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\n    }\n  }, {\n    from: 'Fraction',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.valueOf(), 0);\n    }\n  }, {\n    from: 'number',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      var f = new Fraction(x);\n\n      if (f.valueOf() !== x) {\n        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');\n      }\n\n      return f;\n    }\n  }, {\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\n    //  from: 'Fraction',\n    //  to: 'number',\n    //  convert: function (x) {\n    //    return x.valueOf()\n    //  }\n    // }, {\n    from: 'string',\n    to: 'number',\n    convert: function convert(x) {\n      var n = Number(x);\n\n      if (isNaN(n)) {\n        throw new Error('Cannot convert \"' + x + '\" to a number');\n      }\n\n      return n;\n    }\n  }, {\n    from: 'string',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      try {\n        return new BigNumber(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to BigNumber');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      try {\n        return new Fraction(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Fraction');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      try {\n        return new Complex(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Complex');\n      }\n    }\n  }, {\n    from: 'boolean',\n    to: 'number',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'boolean',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      return new BigNumber(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      return new Fraction(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'string',\n    convert: function convert(x) {\n      return String(x);\n    }\n  }, {\n    from: 'Array',\n    to: 'Matrix',\n    convert: function convert(array) {\n      if (!DenseMatrix) {\n        throwNoMatrix();\n      }\n\n      return new DenseMatrix(array);\n    }\n  }, {\n    from: 'Matrix',\n    to: 'Array',\n    convert: function convert(matrix) {\n      return matrix.valueOf();\n    }\n  }];\n  return typed;\n});\n\nfunction throwNoBignumber(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a BigNumber: no class 'BigNumber' provided\"));\n}\n\nfunction throwNoComplex(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Complex number: no class 'Complex' provided\"));\n}\n\nfunction throwNoMatrix() {\n  throw new Error('Cannot convert array into a Matrix: no class \\'DenseMatrix\\' provided');\n}\n\nfunction throwNoFraction(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Fraction, no class 'Fraction' provided.\"));\n}","map":{"version":3,"names":["isAccessorNode","isArray","isArrayNode","isAssignmentNode","isBigNumber","isBlockNode","isBoolean","isChain","isComplex","isConditionalNode","isConstantNode","isDate","isDenseMatrix","isFraction","isFunction","isFunctionAssignmentNode","isFunctionNode","isHelp","isIndex","isIndexNode","isMatrix","isNode","isNull","isNumber","isObject","isObjectNode","isOperatorNode","isParenthesisNode","isRange","isRangeNode","isRegExp","isResultSet","isSparseMatrix","isString","isSymbolNode","isUndefined","isUnit","typedFunction","digits","factory","isMap","_createTyped2","_createTyped","create","dependencies","createTyped","_ref","BigNumber","Complex","DenseMatrix","Fraction","typed","types","name","test","conversions","from","to","convert","x","throwNoBignumber","TypeError","throwNoComplex","toNumber","valueOf","throwNoFraction","f","n","Number","isNaN","Error","err","String","array","throwNoMatrix","matrix","concat"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/core/function/typed.js"],"sourcesContent":["/**\n * Create a typed-function which checks the types of the arguments and\n * can match them against multiple provided signatures. The typed-function\n * automatically converts inputs in order to find a matching signature.\n * Typed functions throw informative errors in case of wrong input arguments.\n *\n * See the library [typed-function](https://github.com/josdejong/typed-function)\n * for detailed documentation.\n *\n * Syntax:\n *\n *     math.typed(name, signatures) : function\n *     math.typed(signatures) : function\n *\n * Examples:\n *\n *     // create a typed function with multiple types per argument (type union)\n *     const fn2 = typed({\n *       'number | boolean': function (b) {\n *         return 'b is a number or boolean'\n *       },\n *       'string, number | boolean': function (a, b) {\n *         return 'a is a string, b is a number or boolean'\n *       }\n *     })\n *\n *     // create a typed function with an any type argument\n *     const log = typed({\n *       'string, any': function (event, data) {\n *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))\n *       }\n *     })\n *\n * @param {string} [name]                          Optional name for the typed-function\n * @param {Object<string, function>} signatures   Object with one or multiple function signatures\n * @returns {function} The created typed-function.\n */\nimport { isAccessorNode, isArray, isArrayNode, isAssignmentNode, isBigNumber, isBlockNode, isBoolean, isChain, isComplex, isConditionalNode, isConstantNode, isDate, isDenseMatrix, isFraction, isFunction, isFunctionAssignmentNode, isFunctionNode, isHelp, isIndex, isIndexNode, isMatrix, isNode, isNull, isNumber, isObject, isObjectNode, isOperatorNode, isParenthesisNode, isRange, isRangeNode, isRegExp, isResultSet, isSparseMatrix, isString, isSymbolNode, isUndefined, isUnit } from '../../utils/is.js';\nimport typedFunction from 'typed-function';\nimport { digits } from '../../utils/number.js';\nimport { factory } from '../../utils/factory.js';\nimport { isMap } from '../../utils/map.js'; // returns a new instance of typed-function\n\nvar _createTyped2 = function _createTyped() {\n  // initially, return the original instance of typed-function\n  // consecutively, return a new instance from typed.create.\n  _createTyped2 = typedFunction.create;\n  return typedFunction;\n};\n\nvar dependencies = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];\n/**\n * Factory function for creating a new typed instance\n * @param {Object} dependencies   Object with data types like Complex and BigNumber\n * @returns {Function}\n */\n\nexport var createTyped = /* #__PURE__ */factory('typed', dependencies, function createTyped(_ref) {\n  var {\n    BigNumber,\n    Complex,\n    DenseMatrix,\n    Fraction\n  } = _ref;\n\n  // TODO: typed-function must be able to silently ignore signatures with unknown data types\n  // get a new instance of typed-function\n  var typed = _createTyped2(); // define all types. The order of the types determines in which order function\n  // arguments are type-checked (so for performance it's important to put the\n  // most used types first).\n\n\n  typed.types = [{\n    name: 'number',\n    test: isNumber\n  }, {\n    name: 'Complex',\n    test: isComplex\n  }, {\n    name: 'BigNumber',\n    test: isBigNumber\n  }, {\n    name: 'Fraction',\n    test: isFraction\n  }, {\n    name: 'Unit',\n    test: isUnit\n  }, {\n    name: 'string',\n    test: isString\n  }, {\n    name: 'Chain',\n    test: isChain\n  }, {\n    name: 'Array',\n    test: isArray\n  }, {\n    name: 'Matrix',\n    test: isMatrix\n  }, {\n    name: 'DenseMatrix',\n    test: isDenseMatrix\n  }, {\n    name: 'SparseMatrix',\n    test: isSparseMatrix\n  }, {\n    name: 'Range',\n    test: isRange\n  }, {\n    name: 'Index',\n    test: isIndex\n  }, {\n    name: 'boolean',\n    test: isBoolean\n  }, {\n    name: 'ResultSet',\n    test: isResultSet\n  }, {\n    name: 'Help',\n    test: isHelp\n  }, {\n    name: 'function',\n    test: isFunction\n  }, {\n    name: 'Date',\n    test: isDate\n  }, {\n    name: 'RegExp',\n    test: isRegExp\n  }, {\n    name: 'null',\n    test: isNull\n  }, {\n    name: 'undefined',\n    test: isUndefined\n  }, {\n    name: 'AccessorNode',\n    test: isAccessorNode\n  }, {\n    name: 'ArrayNode',\n    test: isArrayNode\n  }, {\n    name: 'AssignmentNode',\n    test: isAssignmentNode\n  }, {\n    name: 'BlockNode',\n    test: isBlockNode\n  }, {\n    name: 'ConditionalNode',\n    test: isConditionalNode\n  }, {\n    name: 'ConstantNode',\n    test: isConstantNode\n  }, {\n    name: 'FunctionNode',\n    test: isFunctionNode\n  }, {\n    name: 'FunctionAssignmentNode',\n    test: isFunctionAssignmentNode\n  }, {\n    name: 'IndexNode',\n    test: isIndexNode\n  }, {\n    name: 'Node',\n    test: isNode\n  }, {\n    name: 'ObjectNode',\n    test: isObjectNode\n  }, {\n    name: 'OperatorNode',\n    test: isOperatorNode\n  }, {\n    name: 'ParenthesisNode',\n    test: isParenthesisNode\n  }, {\n    name: 'RangeNode',\n    test: isRangeNode\n  }, {\n    name: 'SymbolNode',\n    test: isSymbolNode\n  }, {\n    name: 'Map',\n    test: isMap\n  }, {\n    name: 'Object',\n    test: isObject\n  } // order 'Object' last, it matches on other classes too\n  ];\n  typed.conversions = [{\n    from: 'number',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      } // note: conversion from number to BigNumber can fail if x has >15 digits\n\n\n      if (digits(x) > 15) {\n        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');\n      }\n\n      return new BigNumber(x);\n    }\n  }, {\n    from: 'number',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x, 0);\n    }\n  }, {\n    from: 'number',\n    to: 'string',\n    convert: function convert(x) {\n      return x + '';\n    }\n  }, {\n    from: 'BigNumber',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.toNumber(), 0);\n    }\n  }, {\n    from: 'Fraction',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\n    }\n  }, {\n    from: 'Fraction',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.valueOf(), 0);\n    }\n  }, {\n    from: 'number',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      var f = new Fraction(x);\n\n      if (f.valueOf() !== x) {\n        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');\n      }\n\n      return f;\n    }\n  }, {\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\n    //  from: 'Fraction',\n    //  to: 'number',\n    //  convert: function (x) {\n    //    return x.valueOf()\n    //  }\n    // }, {\n    from: 'string',\n    to: 'number',\n    convert: function convert(x) {\n      var n = Number(x);\n\n      if (isNaN(n)) {\n        throw new Error('Cannot convert \"' + x + '\" to a number');\n      }\n\n      return n;\n    }\n  }, {\n    from: 'string',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      try {\n        return new BigNumber(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to BigNumber');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      try {\n        return new Fraction(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Fraction');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      try {\n        return new Complex(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Complex');\n      }\n    }\n  }, {\n    from: 'boolean',\n    to: 'number',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'boolean',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      return new BigNumber(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      return new Fraction(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'string',\n    convert: function convert(x) {\n      return String(x);\n    }\n  }, {\n    from: 'Array',\n    to: 'Matrix',\n    convert: function convert(array) {\n      if (!DenseMatrix) {\n        throwNoMatrix();\n      }\n\n      return new DenseMatrix(array);\n    }\n  }, {\n    from: 'Matrix',\n    to: 'Array',\n    convert: function convert(matrix) {\n      return matrix.valueOf();\n    }\n  }];\n  return typed;\n});\n\nfunction throwNoBignumber(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a BigNumber: no class 'BigNumber' provided\"));\n}\n\nfunction throwNoComplex(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Complex number: no class 'Complex' provided\"));\n}\n\nfunction throwNoMatrix() {\n  throw new Error('Cannot convert array into a Matrix: no class \\'DenseMatrix\\' provided');\n}\n\nfunction throwNoFraction(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Fraction, no class 'Fraction' provided.\"));\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}