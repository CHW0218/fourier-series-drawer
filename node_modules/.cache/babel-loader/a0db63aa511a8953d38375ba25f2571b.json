{"ast":null,"code":"import { contains } from './array.js';\nimport { pickShallow } from './object.js';\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\n\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n\n  return assertAndCreate;\n}\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\n\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(function (factory) {\n    factoriesByName[factory.fn] = factory;\n  });\n\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n\n      if (factory.dependencies.some(function (d) {\n        return containsDependency(factoriesByName[d], dependency);\n      })) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var sorted = [];\n\n  function addFactory(factory) {\n    var index = 0;\n\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(function (factory) {\n    return !isFactory(factory);\n  }).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(function (factory) {\n    return factory(scope);\n  });\n  return scope;\n}\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\n\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\n\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(function (dependency) {\n    return !isOptionalDependency(dependency);\n  }) // filter optionals\n  .every(function (dependency) {\n    return scope[dependency] !== undefined;\n  });\n\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(function (dependency) {\n      return scope[dependency] === undefined;\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(function (d) {\n      return \"\\\"\".concat(d, \"\\\"\");\n    }).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}","map":{"version":3,"names":["contains","pickShallow","factory","name","dependencies","create","meta","assertAndCreate","scope","deps","map","stripOptionalNotation","assertDependencies","isFactory","fn","slice","sort","sortFactories","factories","factoriesByName","forEach","containsDependency","dependency","some","d","sorted","addFactory","index","length","splice","filter","arguments","undefined","obj","Array","isArray","allDefined","isOptionalDependency","every","missingDependencies","Error","concat","join"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/utils/factory.js"],"sourcesContent":["import { contains } from './array.js';\nimport { pickShallow } from './object.js';\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\n\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n\n  return assertAndCreate;\n}\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\n\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(factory => {\n    factoriesByName[factory.fn] = factory;\n  });\n\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n\n      if (factory.dependencies.some(d => containsDependency(factoriesByName[d], dependency))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var sorted = [];\n\n  function addFactory(factory) {\n    var index = 0;\n\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(factory => !isFactory(factory)).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(factory => factory(scope));\n  return scope;\n}\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\n\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\n\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals\n  .every(dependency => scope[dependency] !== undefined);\n\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(d => \"\\\"\".concat(d, \"\\\"\")).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}