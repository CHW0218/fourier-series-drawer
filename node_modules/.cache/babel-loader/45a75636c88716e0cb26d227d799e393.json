{"ast":null,"code":"import _defineProperty from \"/Users/ayao/vscode/fourier-series-drawer/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { isBigNumber, isComplex, isFraction, isMatrix, isUnit } from '../../utils/is.js';\nimport { isFactory, stripOptionalNotation } from '../../utils/factory.js';\nimport { hasOwnProperty, lazy } from '../../utils/object.js';\nimport { contains } from '../../utils/array.js';\nimport { ArgumentsError } from '../../error/ArgumentsError.js';\nexport function importFactory(typed, load, math, importedFactories) {\n  /**\n   * Import functions from an object or a module.\n   *\n   * This function is only available on a mathjs instance created using `create`.\n   *\n   * Syntax:\n   *\n   *    math.import(functions)\n   *    math.import(functions, options)\n   *\n   * Where:\n   *\n   * - `functions: Object`\n   *   An object with functions or factories to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    import { create, all } from 'mathjs'\n   *    import * as numbers from 'numbers'\n   *\n   *    // create a mathjs instance\n   *    const math = create(all)\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(numbers, {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} functions  Object with functions to be imported.\n   * @param {Object} [options]          Import options.\n   */\n  function mathImport(functions, options) {\n    var num = arguments.length;\n\n    if (num !== 1 && num !== 2) {\n      throw new ArgumentsError('import', num, 1, 2);\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    function flattenImports(flatValues, value, name) {\n      if (Array.isArray(value)) {\n        value.forEach(function (item) {\n          return flattenImports(flatValues, item);\n        });\n      } else if (typeof value === 'object') {\n        for (var _name in value) {\n          if (hasOwnProperty(value, _name)) {\n            flattenImports(flatValues, value[_name], _name);\n          }\n        }\n      } else if (isFactory(value) || name !== undefined) {\n        var flatName = isFactory(value) ? isTransformFunctionFactory(value) ? value.fn + '.transform' // TODO: this is ugly\n        : value.fn : name; // we allow importing the same function twice if it points to the same implementation\n\n        if (hasOwnProperty(flatValues, flatName) && flatValues[flatName] !== value && !options.silent) {\n          throw new Error('Cannot import \"' + flatName + '\" twice');\n        }\n\n        flatValues[flatName] = value;\n      } else {\n        if (!options.silent) {\n          throw new TypeError('Factory, Object, or Array expected');\n        }\n      }\n    }\n\n    var flatValues = {};\n    flattenImports(flatValues, functions);\n\n    for (var name in flatValues) {\n      if (hasOwnProperty(flatValues, name)) {\n        // console.log('import', name)\n        var value = flatValues[name];\n\n        if (isFactory(value)) {\n          // we ignore name here and enforce the name of the factory\n          // maybe at some point we do want to allow overriding it\n          // in that case we can implement an option overrideFactoryNames: true\n          _importFactory(value, options);\n        } else if (isSupportedType(value)) {\n          _import(name, value, options);\n        } else {\n          if (!options.silent) {\n            throw new TypeError('Factory, Object, or Array expected');\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Add a property to the math namespace\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    } // turn a plain function with a typed-function signature into a typed-function\n\n\n    if (hasTypedFunctionSignature(value)) {\n      value = typed(name, _defineProperty({}, value.signature, value));\n    }\n\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n\n\n  function _wrap(fn) {\n    var wrapper = function wrapper() {\n      var args = [];\n\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n\n      return fn.apply(math, args);\n    };\n\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n\n    return wrapper;\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {function(scope: object)} factory\n   * @param {Object} options  See import for a description of the options\n   * @param {string} [name=factory.name] Optional custom name\n   * @private\n   */\n\n\n  function _importFactory(factory, options) {\n    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : factory.fn;\n\n    if (contains(name, '.')) {\n      throw new Error('Factory name should not contain a nested path. ' + 'Name: ' + JSON.stringify(name));\n    }\n\n    var namespace = isTransformFunctionFactory(factory) ? math.expression.transform : math;\n    var existingTransform = (name in math.expression.transform);\n    var existing = hasOwnProperty(namespace, name) ? namespace[name] : undefined;\n\n    var resolver = function resolver() {\n      // collect all dependencies, handle finding both functions and classes and other special cases\n      var dependencies = {};\n      factory.dependencies.map(stripOptionalNotation).forEach(function (dependency) {\n        if (contains(dependency, '.')) {\n          throw new Error('Factory dependency should not contain a nested path. ' + 'Name: ' + JSON.stringify(dependency));\n        }\n\n        if (dependency === 'math') {\n          dependencies.math = math;\n        } else if (dependency === 'mathWithTransform') {\n          dependencies.mathWithTransform = math.expression.mathWithTransform;\n        } else if (dependency === 'classes') {\n          // special case for json reviver\n          dependencies.classes = math;\n        } else {\n          dependencies[dependency] = math[dependency];\n        }\n      });\n      var instance = /* #__PURE__ */factory(dependencies);\n\n      if (instance && typeof instance.transform === 'function') {\n        throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n      }\n\n      if (existing === undefined || options.override) {\n        return instance;\n      }\n\n      if (isTypedFunction(existing) && isTypedFunction(instance)) {\n        // merge the existing and new typed function\n        return typed(existing, instance);\n      }\n\n      if (options.silent) {\n        // keep existing, ignore imported function\n        return existing;\n      } else {\n        throw new Error('Cannot import \"' + name + '\": already exists');\n      }\n    }; // TODO: add unit test with non-lazy factory\n\n\n    if (!factory.meta || factory.meta.lazy !== false) {\n      lazy(namespace, name, resolver); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } else {\n      namespace[name] = resolver(); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } // TODO: improve factories, store a list with imports instead which can be re-played\n\n\n    importedFactories[name] = factory;\n    math.emit('import', name, resolver);\n  }\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n\n\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || isUnit(object) || isComplex(object) || isBigNumber(object) || isFraction(object) || isMatrix(object) || Array.isArray(object);\n  }\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n\n\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && typeof fn.signatures === 'object';\n  }\n\n  function hasTypedFunctionSignature(fn) {\n    return typeof fn === 'function' && typeof fn.signature === 'string';\n  }\n\n  function allowedInExpressions(name) {\n    return !hasOwnProperty(unsafe, name);\n  }\n\n  function factoryAllowedInExpressions(factory) {\n    return factory.fn.indexOf('.') === -1 && // FIXME: make checking on path redundant, check on meta data instead\n    !hasOwnProperty(unsafe, factory.fn) && (!factory.meta || !factory.meta.isClass);\n  }\n\n  function isTransformFunctionFactory(factory) {\n    return factory !== undefined && factory.meta !== undefined && factory.meta.isTransformFunction === true || false;\n  } // namespaces and functions not available in the parser for safety reasons\n\n\n  var unsafe = {\n    expression: true,\n    type: true,\n    docs: true,\n    error: true,\n    json: true,\n    chain: true // chain method not supported. Note that there is a unit chain too.\n\n  };\n  return mathImport;\n}","map":{"version":3,"names":["isBigNumber","isComplex","isFraction","isMatrix","isUnit","isFactory","stripOptionalNotation","hasOwnProperty","lazy","contains","ArgumentsError","importFactory","typed","load","math","importedFactories","mathImport","functions","options","num","arguments","length","flattenImports","flatValues","value","name","Array","isArray","forEach","item","_name","undefined","flatName","isTransformFunctionFactory","fn","silent","Error","TypeError","_importFactory","isSupportedType","_import","wrap","_wrap","hasTypedFunctionSignature","signature","isTypedFunction","override","signatures","_importTransform","emit","resolver","transform","expression","allowedInExpressions","mathWithTransform","_deleteTransform","wrapper","args","i","len","arg","valueOf","apply","factory","JSON","stringify","namespace","existingTransform","existing","dependencies","map","dependency","classes","instance","meta","factoryAllowedInExpressions","object","unsafe","indexOf","isClass","isTransformFunction","type","docs","error","json","chain"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/core/function/import.js"],"sourcesContent":["import { isBigNumber, isComplex, isFraction, isMatrix, isUnit } from '../../utils/is.js';\nimport { isFactory, stripOptionalNotation } from '../../utils/factory.js';\nimport { hasOwnProperty, lazy } from '../../utils/object.js';\nimport { contains } from '../../utils/array.js';\nimport { ArgumentsError } from '../../error/ArgumentsError.js';\nexport function importFactory(typed, load, math, importedFactories) {\n  /**\n   * Import functions from an object or a module.\n   *\n   * This function is only available on a mathjs instance created using `create`.\n   *\n   * Syntax:\n   *\n   *    math.import(functions)\n   *    math.import(functions, options)\n   *\n   * Where:\n   *\n   * - `functions: Object`\n   *   An object with functions or factories to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    import { create, all } from 'mathjs'\n   *    import * as numbers from 'numbers'\n   *\n   *    // create a mathjs instance\n   *    const math = create(all)\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(numbers, {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} functions  Object with functions to be imported.\n   * @param {Object} [options]          Import options.\n   */\n  function mathImport(functions, options) {\n    var num = arguments.length;\n\n    if (num !== 1 && num !== 2) {\n      throw new ArgumentsError('import', num, 1, 2);\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    function flattenImports(flatValues, value, name) {\n      if (Array.isArray(value)) {\n        value.forEach(item => flattenImports(flatValues, item));\n      } else if (typeof value === 'object') {\n        for (var _name in value) {\n          if (hasOwnProperty(value, _name)) {\n            flattenImports(flatValues, value[_name], _name);\n          }\n        }\n      } else if (isFactory(value) || name !== undefined) {\n        var flatName = isFactory(value) ? isTransformFunctionFactory(value) ? value.fn + '.transform' // TODO: this is ugly\n        : value.fn : name; // we allow importing the same function twice if it points to the same implementation\n\n        if (hasOwnProperty(flatValues, flatName) && flatValues[flatName] !== value && !options.silent) {\n          throw new Error('Cannot import \"' + flatName + '\" twice');\n        }\n\n        flatValues[flatName] = value;\n      } else {\n        if (!options.silent) {\n          throw new TypeError('Factory, Object, or Array expected');\n        }\n      }\n    }\n\n    var flatValues = {};\n    flattenImports(flatValues, functions);\n\n    for (var name in flatValues) {\n      if (hasOwnProperty(flatValues, name)) {\n        // console.log('import', name)\n        var value = flatValues[name];\n\n        if (isFactory(value)) {\n          // we ignore name here and enforce the name of the factory\n          // maybe at some point we do want to allow overriding it\n          // in that case we can implement an option overrideFactoryNames: true\n          _importFactory(value, options);\n        } else if (isSupportedType(value)) {\n          _import(name, value, options);\n        } else {\n          if (!options.silent) {\n            throw new TypeError('Factory, Object, or Array expected');\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Add a property to the math namespace\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    } // turn a plain function with a typed-function signature into a typed-function\n\n\n    if (hasTypedFunctionSignature(value)) {\n      value = typed(name, {\n        [value.signature]: value\n      });\n    }\n\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n\n\n  function _wrap(fn) {\n    var wrapper = function wrapper() {\n      var args = [];\n\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n\n      return fn.apply(math, args);\n    };\n\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n\n    return wrapper;\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {function(scope: object)} factory\n   * @param {Object} options  See import for a description of the options\n   * @param {string} [name=factory.name] Optional custom name\n   * @private\n   */\n\n\n  function _importFactory(factory, options) {\n    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : factory.fn;\n\n    if (contains(name, '.')) {\n      throw new Error('Factory name should not contain a nested path. ' + 'Name: ' + JSON.stringify(name));\n    }\n\n    var namespace = isTransformFunctionFactory(factory) ? math.expression.transform : math;\n    var existingTransform = (name in math.expression.transform);\n    var existing = hasOwnProperty(namespace, name) ? namespace[name] : undefined;\n\n    var resolver = function resolver() {\n      // collect all dependencies, handle finding both functions and classes and other special cases\n      var dependencies = {};\n      factory.dependencies.map(stripOptionalNotation).forEach(dependency => {\n        if (contains(dependency, '.')) {\n          throw new Error('Factory dependency should not contain a nested path. ' + 'Name: ' + JSON.stringify(dependency));\n        }\n\n        if (dependency === 'math') {\n          dependencies.math = math;\n        } else if (dependency === 'mathWithTransform') {\n          dependencies.mathWithTransform = math.expression.mathWithTransform;\n        } else if (dependency === 'classes') {\n          // special case for json reviver\n          dependencies.classes = math;\n        } else {\n          dependencies[dependency] = math[dependency];\n        }\n      });\n      var instance = /* #__PURE__ */factory(dependencies);\n\n      if (instance && typeof instance.transform === 'function') {\n        throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n      }\n\n      if (existing === undefined || options.override) {\n        return instance;\n      }\n\n      if (isTypedFunction(existing) && isTypedFunction(instance)) {\n        // merge the existing and new typed function\n        return typed(existing, instance);\n      }\n\n      if (options.silent) {\n        // keep existing, ignore imported function\n        return existing;\n      } else {\n        throw new Error('Cannot import \"' + name + '\": already exists');\n      }\n    }; // TODO: add unit test with non-lazy factory\n\n\n    if (!factory.meta || factory.meta.lazy !== false) {\n      lazy(namespace, name, resolver); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, () => namespace[name]);\n        }\n      }\n    } else {\n      namespace[name] = resolver(); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, () => namespace[name]);\n        }\n      }\n    } // TODO: improve factories, store a list with imports instead which can be re-played\n\n\n    importedFactories[name] = factory;\n    math.emit('import', name, resolver);\n  }\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n\n\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || isUnit(object) || isComplex(object) || isBigNumber(object) || isFraction(object) || isMatrix(object) || Array.isArray(object);\n  }\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n\n\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && typeof fn.signatures === 'object';\n  }\n\n  function hasTypedFunctionSignature(fn) {\n    return typeof fn === 'function' && typeof fn.signature === 'string';\n  }\n\n  function allowedInExpressions(name) {\n    return !hasOwnProperty(unsafe, name);\n  }\n\n  function factoryAllowedInExpressions(factory) {\n    return factory.fn.indexOf('.') === -1 && // FIXME: make checking on path redundant, check on meta data instead\n    !hasOwnProperty(unsafe, factory.fn) && (!factory.meta || !factory.meta.isClass);\n  }\n\n  function isTransformFunctionFactory(factory) {\n    return factory !== undefined && factory.meta !== undefined && factory.meta.isTransformFunction === true || false;\n  } // namespaces and functions not available in the parser for safety reasons\n\n\n  var unsafe = {\n    expression: true,\n    type: true,\n    docs: true,\n    error: true,\n    json: true,\n    chain: true // chain method not supported. Note that there is a unit chain too.\n\n  };\n  return mathImport;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}