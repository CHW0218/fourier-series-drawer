{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/ayao/vscode/fourier-series-drawer/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/ayao/vscode/fourier-series-drawer/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { clone } from '../../../utils/object.js';\nexport function createComplexEigs(_ref) {\n  var addScalar = _ref.addScalar,\n      subtract = _ref.subtract,\n      flatten = _ref.flatten,\n      multiply = _ref.multiply,\n      multiplyScalar = _ref.multiplyScalar,\n      divideScalar = _ref.divideScalar,\n      sqrt = _ref.sqrt,\n      abs = _ref.abs,\n      bignumber = _ref.bignumber,\n      diag = _ref.diag,\n      inv = _ref.inv,\n      qr = _ref.qr,\n      usolve = _ref.usolve,\n      usolveAll = _ref.usolveAll,\n      equal = _ref.equal,\n      complex = _ref.complex,\n      larger = _ref.larger,\n      smaller = _ref.smaller,\n      matrixFromColumns = _ref.matrixFromColumns,\n      dot = _ref.dot;\n  /**\n   * @param {number[][]} arr the matrix to find eigenvalues of\n   * @param {number} N size of the matrix\n   * @param {number|BigNumber} prec precision, anything lower will be considered zero\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors should we find eigenvectors?\n   *\n   * @returns {{ values: number[], vectors: number[][] }}\n   */\n\n  function complexEigs(arr, N, prec, type, findVectors) {\n    if (findVectors === undefined) {\n      findVectors = true;\n    } // TODO check if any row/col are zero except the diagonal\n    // make sure corresponding rows and columns have similar magnitude\n    // important because of numerical stability\n    // MODIFIES arr by side effect!\n\n\n    var R = balance(arr, N, prec, type, findVectors); // R is the row transformation matrix\n    // arr = A' = R A R⁻¹, A is the original matrix\n    // (if findVectors is false, R is undefined)\n    // (And so to return to original matrix: A = R⁻¹ arr R)\n    // TODO if magnitudes of elements vary over many orders,\n    // move greatest elements to the top left corner\n    // using similarity transformations, reduce the matrix\n    // to Hessenberg form (upper triangular plus one subdiagonal row)\n    // updates the transformation matrix R with new row operationsq\n    // MODIFIES arr by side effect!\n\n    reduceToHessenberg(arr, N, prec, type, findVectors, R); // still true that original A = R⁻¹ arr R)\n    // find eigenvalues\n\n    var _iterateUntilTriangul = iterateUntilTriangular(arr, N, prec, type, findVectors),\n        values = _iterateUntilTriangul.values,\n        C = _iterateUntilTriangul.C; // values is the list of eigenvalues, C is the column\n    // transformation matrix that transforms arr, the hessenberg\n    // matrix, to upper triangular\n    // (So U = C⁻¹ arr C and the relationship between current arr\n    // and original A is unchanged.)\n\n\n    var vectors;\n\n    if (findVectors) {\n      vectors = findEigenvectors(arr, N, C, R, values, prec, type);\n      vectors = matrixFromColumns.apply(void 0, _toConsumableArray(vectors));\n    }\n\n    return {\n      values: values,\n      vectors: vectors\n    };\n  }\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]}\n   */\n\n\n  function balance(arr, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var realzero = big ? bignumber(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    var realone = big ? bignumber(1) : 1; // base of the floating-point arithmetic\n\n    var radix = big ? bignumber(10) : 2;\n    var radixSq = multiplyScalar(radix, radix); // the diagonal transformation matrix R\n\n    var Rdiag;\n\n    if (findVectors) {\n      Rdiag = Array(N).fill(one);\n    } // this isn't the only time we loop thru the matrix...\n\n\n    var last = false;\n\n    while (!last) {\n      // ...haha I'm joking! unless...\n      last = true;\n\n      for (var i = 0; i < N; i++) {\n        // compute the taxicab norm of i-th column and row\n        // TODO optimize for complex numbers\n        var colNorm = realzero;\n        var rowNorm = realzero;\n\n        for (var j = 0; j < N; j++) {\n          if (i === j) continue;\n          var c = abs(arr[i][j]); // should be real\n\n          colNorm = addScalar(colNorm, c);\n          rowNorm = addScalar(rowNorm, c);\n        }\n\n        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {\n          // find integer power closest to balancing the matrix\n          // (we want to scale only by integer powers of radix,\n          // so that we don't lose any precision due to round-off)\n          var f = realone;\n          var _c = colNorm;\n          var rowDivRadix = divideScalar(rowNorm, radix);\n          var rowMulRadix = multiplyScalar(rowNorm, radix);\n\n          while (smaller(_c, rowDivRadix)) {\n            _c = multiplyScalar(_c, radixSq);\n            f = multiplyScalar(f, radix);\n          }\n\n          while (larger(_c, rowMulRadix)) {\n            _c = divideScalar(_c, radixSq);\n            f = divideScalar(f, radix);\n          } // check whether balancing is needed\n          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)\n\n\n          var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95)); // apply balancing similarity transformation\n\n          if (condition) {\n            // we should loop once again to check whether\n            // another rebalancing is needed\n            last = false;\n            var g = divideScalar(1, f);\n\n            for (var _j = 0; _j < N; _j++) {\n              if (i === _j) {\n                continue;\n              }\n\n              arr[i][_j] = multiplyScalar(arr[i][_j], f);\n              arr[_j][i] = multiplyScalar(arr[_j][i], g);\n            } // keep track of transformations\n\n\n            if (findVectors) {\n              Rdiag[i] = multiplyScalar(Rdiag[i], f);\n            }\n          }\n        }\n      }\n    } // return the diagonal row transformation matrix\n\n\n    return diag(Rdiag);\n  }\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors\n   * @param {number[][]} R the row transformation matrix that will be modified\n   */\n\n\n  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n\n    if (big) {\n      prec = bignumber(prec);\n    }\n\n    for (var i = 0; i < N - 2; i++) {\n      // Find the largest subdiag element in the i-th col\n      var maxIndex = 0;\n      var max = zero;\n\n      for (var j = i + 1; j < N; j++) {\n        var el = arr[j][i];\n\n        if (smaller(abs(max), abs(el))) {\n          max = el;\n          maxIndex = j;\n        }\n      } // This col is pivoted, no need to do anything\n\n\n      if (smaller(abs(max), prec)) {\n        continue;\n      }\n\n      if (maxIndex !== i + 1) {\n        // Interchange maxIndex-th and (i+1)-th row\n        var tmp1 = arr[maxIndex];\n        arr[maxIndex] = arr[i + 1];\n        arr[i + 1] = tmp1; // Interchange maxIndex-th and (i+1)-th column\n\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          var tmp2 = arr[_j2][maxIndex];\n          arr[_j2][maxIndex] = arr[_j2][i + 1];\n          arr[_j2][i + 1] = tmp2;\n        } // keep track of transformations\n\n\n        if (findVectors) {\n          var tmp3 = R[maxIndex];\n          R[maxIndex] = R[i + 1];\n          R[i + 1] = tmp3;\n        }\n      } // Reduce following rows and columns\n\n\n      for (var _j3 = i + 2; _j3 < N; _j3++) {\n        var n = divideScalar(arr[_j3][i], max);\n\n        if (n === 0) {\n          continue;\n        } // from j-th row subtract n-times (i+1)th row\n\n\n        for (var k = 0; k < N; k++) {\n          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));\n        } // to (i+1)th column add n-times j-th column\n\n\n        for (var _k = 0; _k < N; _k++) {\n          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));\n        } // keep track of transformations\n\n\n        if (findVectors) {\n          for (var _k2 = 0; _k2 < N; _k2++) {\n            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));\n          }\n        }\n      }\n    }\n\n    return R;\n  }\n  /**\n   * @returns {{values: values, C: Matrix}}\n   * @see Press, Wiliams: Numerical recipes in Fortran 77\n   * @see https://en.wikipedia.org/wiki/QR_algorithm\n   */\n\n\n  function iterateUntilTriangular(A, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    if (big) {\n      prec = bignumber(prec);\n    } // The Francis Algorithm\n    // The core idea of this algorithm is that doing successive\n    // A' = Q⁺AQ transformations will eventually converge to block-\n    // upper-triangular with diagonal blocks either 1x1 or 2x2.\n    // The Q here is the one from the QR decomposition, A = QR.\n    // Since the eigenvalues of a block-upper-triangular matrix are\n    // the eigenvalues of its diagonal blocks and we know how to find\n    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.\n\n\n    var arr = clone(A); // the list of converged eigenvalues\n\n    var lambdas = []; // size of arr, which will get smaller as eigenvalues converge\n\n    var n = N; // the diagonal of the block-diagonal matrix that turns\n    // converged 2x2 matrices into upper triangular matrices\n\n    var Sdiag = []; // N×N matrix describing the overall transformation done during the QR algorithm\n\n    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined; // n×n matrix describing the QR transformations done since last convergence\n\n    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined; // last eigenvalue converged before this many steps\n\n    var lastConvergenceBefore = 0;\n\n    while (lastConvergenceBefore <= 100) {\n      lastConvergenceBefore += 1; // TODO if the convergence is slow, do something clever\n      // Perform the factorization\n\n      var k = 0; // TODO set close to an eigenvalue\n\n      for (var i = 0; i < n; i++) {\n        arr[i][i] = subtract(arr[i][i], k);\n      } // TODO do an implicit QR transformation\n\n\n      var _qr = qr(arr),\n          Q = _qr.Q,\n          R = _qr.R;\n\n      arr = multiply(R, Q);\n\n      for (var _i = 0; _i < n; _i++) {\n        arr[_i][_i] = addScalar(arr[_i][_i], k);\n      } // keep track of transformations\n\n\n      if (findVectors) {\n        Qpartial = multiply(Qpartial, Q);\n      } // The rightmost diagonal element converged to an eigenvalue\n\n\n      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {\n        lastConvergenceBefore = 0;\n        lambdas.push(arr[n - 1][n - 1]); // keep track of transformations\n\n        if (findVectors) {\n          Sdiag.unshift([[1]]);\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n\n          if (n > 1) {\n            Qpartial = diag(Array(n - 1).fill(one));\n          }\n        } // reduce the matrix size\n\n\n        n -= 1;\n        arr.pop();\n\n        for (var _i2 = 0; _i2 < n; _i2++) {\n          arr[_i2].pop();\n        } // The rightmost diagonal 2x2 block converged\n\n      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {\n        lastConvergenceBefore = 0;\n        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);\n        lambdas.push.apply(lambdas, _toConsumableArray(ll)); // keep track of transformations\n\n        if (findVectors) {\n          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n\n          if (n > 2) {\n            Qpartial = diag(Array(n - 2).fill(one));\n          }\n        } // reduce the matrix size\n\n\n        n -= 2;\n        arr.pop();\n        arr.pop();\n\n        for (var _i3 = 0; _i3 < n; _i3++) {\n          arr[_i3].pop();\n\n          arr[_i3].pop();\n        }\n      }\n\n      if (n === 0) {\n        break;\n      }\n    } // standard sorting\n\n\n    lambdas.sort(function (a, b) {\n      return +subtract(abs(a), abs(b));\n    }); // the algorithm didn't converge\n\n    if (lastConvergenceBefore > 100) {\n      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));\n      err.values = lambdas;\n      err.vectors = [];\n      throw err;\n    } // combine the overall QR transformation Qtotal with the subsequent\n    // transformation S that turns the diagonal 2x2 blocks to upper triangular\n\n\n    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;\n    return {\n      values: lambdas,\n      C: C\n    };\n  }\n  /**\n   * @param {Matrix} A hessenberg-form matrix\n   * @param {number} N size of A\n   * @param {Matrix} C column transformation matrix that turns A into upper triangular\n   * @param {Matrix} R similarity that turns original matrix into A\n   * @param {number[]} values array of eigenvalues of A\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]} eigenvalues\n   */\n\n\n  function findEigenvectors(A, N, C, R, values, prec, type) {\n    var Cinv = inv(C);\n    var U = multiply(Cinv, A, C);\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // turn values into a kind of \"multiset\"\n    // this way it is easier to find eigenvectors\n\n    var uniqueValues = [];\n    var multiplicities = [];\n\n    var _iterator = _createForOfIteratorHelper(values),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var λ = _step.value;\n        var i = indexOf(uniqueValues, λ, equal);\n\n        if (i === -1) {\n          uniqueValues.push(λ);\n          multiplicities.push(1);\n        } else {\n          multiplicities[i] += 1;\n        }\n      } // find eigenvectors by solving U − λE = 0\n      // TODO replace with an iterative eigenvector algorithm\n      // (this one might fail for imprecise eigenvalues)\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var vectors = [];\n    var len = uniqueValues.length;\n    var b = Array(N).fill(zero);\n    var E = diag(Array(N).fill(one)); // eigenvalues for which usolve failed (due to numerical error)\n\n    var failedLambdas = [];\n\n    var _loop = function _loop(_i4) {\n      var λ = uniqueValues[_i4];\n      var S = subtract(U, multiply(λ, E)); // the characteristic matrix\n\n      var solutions = usolveAll(S, b);\n      solutions.shift(); // ignore the null vector\n      // looks like we missed something, try inverse iteration\n\n      while (solutions.length < multiplicities[_i4]) {\n        var approxVec = inverseIterate(S, N, solutions, prec, type);\n\n        if (approxVec == null) {\n          // no more vectors were found\n          failedLambdas.push(λ);\n          break;\n        }\n\n        solutions.push(approxVec);\n      } // Transform back into original array coordinates\n\n\n      var correction = multiply(inv(R), C);\n      solutions = solutions.map(function (v) {\n        return multiply(correction, v);\n      });\n      vectors.push.apply(vectors, _toConsumableArray(solutions.map(function (v) {\n        return flatten(v);\n      })));\n    };\n\n    for (var _i4 = 0; _i4 < len; _i4++) {\n      _loop(_i4);\n    }\n\n    if (failedLambdas.length !== 0) {\n      var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));\n      err.values = values;\n      err.vectors = vectors;\n      throw err;\n    }\n\n    return vectors;\n  }\n  /**\n   * Compute the eigenvalues of an 2x2 matrix\n   * @return {[number,number]}\n   */\n\n\n  function eigenvalues2x2(a, b, c, d) {\n    // λ± = ½ trA ± ½ √( tr²A - 4 detA )\n    var trA = addScalar(a, d);\n    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));\n    var x = multiplyScalar(trA, 0.5);\n    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);\n    return [addScalar(x, y), subtract(x, y)];\n  }\n  /**\n   * For an 2x2 matrix compute the transformation matrix S,\n   * so that SAS⁻¹ is an upper triangular matrix\n   * @return {[[number,number],[number,number]]}\n   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf\n   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n   */\n\n\n  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // matrix is already upper triangular\n    // return an identity matrix\n\n    if (smaller(abs(c), prec)) {\n      return [[one, zero], [zero, one]];\n    } // matrix is diagonalizable\n    // return its eigenvectors as columns\n\n\n    if (larger(abs(subtract(l1, l2)), prec)) {\n      return [[subtract(l1, d), subtract(l2, d)], [c, c]];\n    } // matrix is not diagonalizable\n    // compute off-diagonal elements of N = A - λI\n    // N₁₂ = 0 ⇒ S = ( N⃗₁, I⃗₁ )\n    // N₁₂ ≠ 0 ⇒ S = ( N⃗₂, I⃗₂ )\n\n\n    var na = subtract(a, l1);\n    var nb = subtract(b, l1);\n    var nc = subtract(c, l1);\n    var nd = subtract(d, l1);\n\n    if (smaller(abs(nb), prec)) {\n      return [[na, one], [nc, zero]];\n    } else {\n      return [[nb, zero], [nd, one]];\n    }\n  }\n  /**\n   * Enlarge the matrix from n×n to N×N, setting the new\n   * elements to 1 on diagonal and 0 elsewhere\n   */\n\n\n  function inflateMatrix(arr, N) {\n    // add columns\n    for (var i = 0; i < arr.length; i++) {\n      var _arr$i;\n\n      (_arr$i = arr[i]).push.apply(_arr$i, _toConsumableArray(Array(N - arr[i].length).fill(0)));\n    } // add rows\n\n\n    for (var _i5 = arr.length; _i5 < N; _i5++) {\n      arr.push(Array(N).fill(0));\n      arr[_i5][_i5] = 1;\n    }\n\n    return arr;\n  }\n  /**\n   * Create a block-diagonal matrix with the given square matrices on the diagonal\n   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal\n   * @param {number} N the size of the resulting matrix\n   */\n\n\n  function blockDiag(arr, N) {\n    var M = [];\n\n    for (var i = 0; i < N; i++) {\n      M[i] = Array(N).fill(0);\n    }\n\n    var I = 0;\n\n    var _iterator2 = _createForOfIteratorHelper(arr),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var sub = _step2.value;\n        var n = sub.length;\n\n        for (var _i6 = 0; _i6 < n; _i6++) {\n          for (var j = 0; j < n; j++) {\n            M[I + _i6][I + j] = sub[_i6][j];\n          }\n        }\n\n        I += n;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return M;\n  }\n  /**\n   * Finds the index of an element in an array using a custom equality function\n   * @template T\n   * @param {Array<T>} arr array in which to search\n   * @param {T} el the element to find\n   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`\n   * @returns {number} the index of `el`, or -1 when it's not in `arr`\n   */\n\n\n  function indexOf(arr, el, fn) {\n    for (var i = 0; i < arr.length; i++) {\n      if (fn(arr[i], el)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Provided a near-singular upper-triangular matrix A and a list of vectors,\n   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal\n   * to each vector in the list\n   * @template T\n   * @param {T[][]} A near-singular square matrix\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {number} prec epsilon\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @return {T[] | null} eigenvector\n   *\n   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration\n   */\n\n\n  function inverseIterate(A, N, orthog, prec, type) {\n    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;\n    var b; // the vector\n    // you better choose a random vector before I count to five\n\n    var i = 0;\n\n    while (true) {\n      b = randomOrthogonalVector(N, orthog, type);\n      b = usolve(A, b);\n\n      if (larger(norm(b), largeNum)) {\n        break;\n      }\n\n      if (++i >= 5) {\n        return null;\n      }\n    } // you better converge before I count to ten\n\n\n    i = 0;\n\n    while (true) {\n      var c = usolve(A, b);\n\n      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {\n        break;\n      }\n\n      if (++i >= 10) {\n        return null;\n      }\n\n      b = normalize(c);\n    }\n\n    return b;\n  }\n  /**\n   * Generates a random unit vector of dimension N, orthogonal to each vector in the list\n   * @template T\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} random vector\n   */\n\n\n  function randomOrthogonalVector(N, orthog, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex'; // generate random vector with the correct type\n\n    var v = Array(N).fill(0).map(function (_) {\n      return 2 * Math.random() - 1;\n    });\n\n    if (big) {\n      v = v.map(function (n) {\n        return bignumber(n);\n      });\n    }\n\n    if (cplx) {\n      v = v.map(function (n) {\n        return complex(n);\n      });\n    } // project to orthogonal complement\n\n\n    v = orthogonalComplement(v, orthog); // normalize\n\n    return normalize(v, type);\n  }\n  /**\n   * Project vector v to the orthogonal complement of an array of vectors\n   */\n\n\n  function orthogonalComplement(v, orthog) {\n    var _iterator3 = _createForOfIteratorHelper(orthog),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var w = _step3.value;\n        // v := v − (w, v)/∥w∥² w\n        v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return v;\n  }\n  /**\n   * Calculate the norm of a vector.\n   * We can't use math.norm because factory can't handle circular dependency.\n   * Seriously, I'm really fed up with factory.\n   */\n\n\n  function norm(v) {\n    return abs(sqrt(dot(v, v)));\n  }\n  /**\n   * Normalize a vector\n   * @template T\n   * @param {T[]} v\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} normalized vec\n   */\n\n\n  function normalize(v, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    return multiply(divideScalar(one, norm(v)), v);\n  }\n\n  return complexEigs;\n}","map":{"version":3,"names":["clone","createComplexEigs","_ref","addScalar","subtract","flatten","multiply","multiplyScalar","divideScalar","sqrt","abs","bignumber","diag","inv","qr","usolve","usolveAll","equal","complex","larger","smaller","matrixFromColumns","dot","complexEigs","arr","N","prec","type","findVectors","undefined","R","balance","reduceToHessenberg","iterateUntilTriangular","values","C","vectors","findEigenvectors","big","cplx","realzero","one","realone","radix","radixSq","Rdiag","Array","fill","last","i","colNorm","rowNorm","j","c","f","_c","rowDivRadix","rowMulRadix","condition","g","_j","zero","maxIndex","max","el","tmp1","_j2","tmp2","tmp3","_j3","n","k","_k","_k2","A","lambdas","Sdiag","Qtotal","Qpartial","lastConvergenceBefore","Q","_i","push","unshift","inflateMatrix","pop","_i2","ll","eigenvalues2x2","jordanBase2x2","_i3","sort","a","b","err","Error","join","blockDiag","Cinv","U","uniqueValues","multiplicities","λ","indexOf","len","length","E","failedLambdas","_loop","_i4","S","solutions","shift","approxVec","inverseIterate","correction","map","v","d","trA","detA","x","y","l1","l2","na","nb","nc","nd","_i5","M","I","sub","_i6","fn","orthog","largeNum","randomOrthogonalVector","norm","orthogonalComplement","normalize","_","Math","random","w"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js"],"sourcesContent":["import { clone } from '../../../utils/object.js';\nexport function createComplexEigs(_ref) {\n  var {\n    addScalar,\n    subtract,\n    flatten,\n    multiply,\n    multiplyScalar,\n    divideScalar,\n    sqrt,\n    abs,\n    bignumber,\n    diag,\n    inv,\n    qr,\n    usolve,\n    usolveAll,\n    equal,\n    complex,\n    larger,\n    smaller,\n    matrixFromColumns,\n    dot\n  } = _ref;\n\n  /**\n   * @param {number[][]} arr the matrix to find eigenvalues of\n   * @param {number} N size of the matrix\n   * @param {number|BigNumber} prec precision, anything lower will be considered zero\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors should we find eigenvectors?\n   *\n   * @returns {{ values: number[], vectors: number[][] }}\n   */\n  function complexEigs(arr, N, prec, type, findVectors) {\n    if (findVectors === undefined) {\n      findVectors = true;\n    } // TODO check if any row/col are zero except the diagonal\n    // make sure corresponding rows and columns have similar magnitude\n    // important because of numerical stability\n    // MODIFIES arr by side effect!\n\n\n    var R = balance(arr, N, prec, type, findVectors); // R is the row transformation matrix\n    // arr = A' = R A R⁻¹, A is the original matrix\n    // (if findVectors is false, R is undefined)\n    // (And so to return to original matrix: A = R⁻¹ arr R)\n    // TODO if magnitudes of elements vary over many orders,\n    // move greatest elements to the top left corner\n    // using similarity transformations, reduce the matrix\n    // to Hessenberg form (upper triangular plus one subdiagonal row)\n    // updates the transformation matrix R with new row operationsq\n    // MODIFIES arr by side effect!\n\n    reduceToHessenberg(arr, N, prec, type, findVectors, R); // still true that original A = R⁻¹ arr R)\n    // find eigenvalues\n\n    var {\n      values,\n      C\n    } = iterateUntilTriangular(arr, N, prec, type, findVectors); // values is the list of eigenvalues, C is the column\n    // transformation matrix that transforms arr, the hessenberg\n    // matrix, to upper triangular\n    // (So U = C⁻¹ arr C and the relationship between current arr\n    // and original A is unchanged.)\n\n    var vectors;\n\n    if (findVectors) {\n      vectors = findEigenvectors(arr, N, C, R, values, prec, type);\n      vectors = matrixFromColumns(...vectors);\n    }\n\n    return {\n      values,\n      vectors\n    };\n  }\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]}\n   */\n\n\n  function balance(arr, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var realzero = big ? bignumber(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    var realone = big ? bignumber(1) : 1; // base of the floating-point arithmetic\n\n    var radix = big ? bignumber(10) : 2;\n    var radixSq = multiplyScalar(radix, radix); // the diagonal transformation matrix R\n\n    var Rdiag;\n\n    if (findVectors) {\n      Rdiag = Array(N).fill(one);\n    } // this isn't the only time we loop thru the matrix...\n\n\n    var last = false;\n\n    while (!last) {\n      // ...haha I'm joking! unless...\n      last = true;\n\n      for (var i = 0; i < N; i++) {\n        // compute the taxicab norm of i-th column and row\n        // TODO optimize for complex numbers\n        var colNorm = realzero;\n        var rowNorm = realzero;\n\n        for (var j = 0; j < N; j++) {\n          if (i === j) continue;\n          var c = abs(arr[i][j]); // should be real\n\n          colNorm = addScalar(colNorm, c);\n          rowNorm = addScalar(rowNorm, c);\n        }\n\n        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {\n          // find integer power closest to balancing the matrix\n          // (we want to scale only by integer powers of radix,\n          // so that we don't lose any precision due to round-off)\n          var f = realone;\n          var _c = colNorm;\n          var rowDivRadix = divideScalar(rowNorm, radix);\n          var rowMulRadix = multiplyScalar(rowNorm, radix);\n\n          while (smaller(_c, rowDivRadix)) {\n            _c = multiplyScalar(_c, radixSq);\n            f = multiplyScalar(f, radix);\n          }\n\n          while (larger(_c, rowMulRadix)) {\n            _c = divideScalar(_c, radixSq);\n            f = divideScalar(f, radix);\n          } // check whether balancing is needed\n          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)\n\n\n          var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95)); // apply balancing similarity transformation\n\n          if (condition) {\n            // we should loop once again to check whether\n            // another rebalancing is needed\n            last = false;\n            var g = divideScalar(1, f);\n\n            for (var _j = 0; _j < N; _j++) {\n              if (i === _j) {\n                continue;\n              }\n\n              arr[i][_j] = multiplyScalar(arr[i][_j], f);\n              arr[_j][i] = multiplyScalar(arr[_j][i], g);\n            } // keep track of transformations\n\n\n            if (findVectors) {\n              Rdiag[i] = multiplyScalar(Rdiag[i], f);\n            }\n          }\n        }\n      }\n    } // return the diagonal row transformation matrix\n\n\n    return diag(Rdiag);\n  }\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors\n   * @param {number[][]} R the row transformation matrix that will be modified\n   */\n\n\n  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n\n    if (big) {\n      prec = bignumber(prec);\n    }\n\n    for (var i = 0; i < N - 2; i++) {\n      // Find the largest subdiag element in the i-th col\n      var maxIndex = 0;\n      var max = zero;\n\n      for (var j = i + 1; j < N; j++) {\n        var el = arr[j][i];\n\n        if (smaller(abs(max), abs(el))) {\n          max = el;\n          maxIndex = j;\n        }\n      } // This col is pivoted, no need to do anything\n\n\n      if (smaller(abs(max), prec)) {\n        continue;\n      }\n\n      if (maxIndex !== i + 1) {\n        // Interchange maxIndex-th and (i+1)-th row\n        var tmp1 = arr[maxIndex];\n        arr[maxIndex] = arr[i + 1];\n        arr[i + 1] = tmp1; // Interchange maxIndex-th and (i+1)-th column\n\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          var tmp2 = arr[_j2][maxIndex];\n          arr[_j2][maxIndex] = arr[_j2][i + 1];\n          arr[_j2][i + 1] = tmp2;\n        } // keep track of transformations\n\n\n        if (findVectors) {\n          var tmp3 = R[maxIndex];\n          R[maxIndex] = R[i + 1];\n          R[i + 1] = tmp3;\n        }\n      } // Reduce following rows and columns\n\n\n      for (var _j3 = i + 2; _j3 < N; _j3++) {\n        var n = divideScalar(arr[_j3][i], max);\n\n        if (n === 0) {\n          continue;\n        } // from j-th row subtract n-times (i+1)th row\n\n\n        for (var k = 0; k < N; k++) {\n          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));\n        } // to (i+1)th column add n-times j-th column\n\n\n        for (var _k = 0; _k < N; _k++) {\n          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));\n        } // keep track of transformations\n\n\n        if (findVectors) {\n          for (var _k2 = 0; _k2 < N; _k2++) {\n            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));\n          }\n        }\n      }\n    }\n\n    return R;\n  }\n  /**\n   * @returns {{values: values, C: Matrix}}\n   * @see Press, Wiliams: Numerical recipes in Fortran 77\n   * @see https://en.wikipedia.org/wiki/QR_algorithm\n   */\n\n\n  function iterateUntilTriangular(A, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    if (big) {\n      prec = bignumber(prec);\n    } // The Francis Algorithm\n    // The core idea of this algorithm is that doing successive\n    // A' = Q⁺AQ transformations will eventually converge to block-\n    // upper-triangular with diagonal blocks either 1x1 or 2x2.\n    // The Q here is the one from the QR decomposition, A = QR.\n    // Since the eigenvalues of a block-upper-triangular matrix are\n    // the eigenvalues of its diagonal blocks and we know how to find\n    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.\n\n\n    var arr = clone(A); // the list of converged eigenvalues\n\n    var lambdas = []; // size of arr, which will get smaller as eigenvalues converge\n\n    var n = N; // the diagonal of the block-diagonal matrix that turns\n    // converged 2x2 matrices into upper triangular matrices\n\n    var Sdiag = []; // N×N matrix describing the overall transformation done during the QR algorithm\n\n    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined; // n×n matrix describing the QR transformations done since last convergence\n\n    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined; // last eigenvalue converged before this many steps\n\n    var lastConvergenceBefore = 0;\n\n    while (lastConvergenceBefore <= 100) {\n      lastConvergenceBefore += 1; // TODO if the convergence is slow, do something clever\n      // Perform the factorization\n\n      var k = 0; // TODO set close to an eigenvalue\n\n      for (var i = 0; i < n; i++) {\n        arr[i][i] = subtract(arr[i][i], k);\n      } // TODO do an implicit QR transformation\n\n\n      var {\n        Q,\n        R\n      } = qr(arr);\n      arr = multiply(R, Q);\n\n      for (var _i = 0; _i < n; _i++) {\n        arr[_i][_i] = addScalar(arr[_i][_i], k);\n      } // keep track of transformations\n\n\n      if (findVectors) {\n        Qpartial = multiply(Qpartial, Q);\n      } // The rightmost diagonal element converged to an eigenvalue\n\n\n      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {\n        lastConvergenceBefore = 0;\n        lambdas.push(arr[n - 1][n - 1]); // keep track of transformations\n\n        if (findVectors) {\n          Sdiag.unshift([[1]]);\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n\n          if (n > 1) {\n            Qpartial = diag(Array(n - 1).fill(one));\n          }\n        } // reduce the matrix size\n\n\n        n -= 1;\n        arr.pop();\n\n        for (var _i2 = 0; _i2 < n; _i2++) {\n          arr[_i2].pop();\n        } // The rightmost diagonal 2x2 block converged\n\n      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {\n        lastConvergenceBefore = 0;\n        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);\n        lambdas.push(...ll); // keep track of transformations\n\n        if (findVectors) {\n          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n\n          if (n > 2) {\n            Qpartial = diag(Array(n - 2).fill(one));\n          }\n        } // reduce the matrix size\n\n\n        n -= 2;\n        arr.pop();\n        arr.pop();\n\n        for (var _i3 = 0; _i3 < n; _i3++) {\n          arr[_i3].pop();\n\n          arr[_i3].pop();\n        }\n      }\n\n      if (n === 0) {\n        break;\n      }\n    } // standard sorting\n\n\n    lambdas.sort((a, b) => +subtract(abs(a), abs(b))); // the algorithm didn't converge\n\n    if (lastConvergenceBefore > 100) {\n      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));\n      err.values = lambdas;\n      err.vectors = [];\n      throw err;\n    } // combine the overall QR transformation Qtotal with the subsequent\n    // transformation S that turns the diagonal 2x2 blocks to upper triangular\n\n\n    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;\n    return {\n      values: lambdas,\n      C\n    };\n  }\n  /**\n   * @param {Matrix} A hessenberg-form matrix\n   * @param {number} N size of A\n   * @param {Matrix} C column transformation matrix that turns A into upper triangular\n   * @param {Matrix} R similarity that turns original matrix into A\n   * @param {number[]} values array of eigenvalues of A\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]} eigenvalues\n   */\n\n\n  function findEigenvectors(A, N, C, R, values, prec, type) {\n    var Cinv = inv(C);\n    var U = multiply(Cinv, A, C);\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // turn values into a kind of \"multiset\"\n    // this way it is easier to find eigenvectors\n\n    var uniqueValues = [];\n    var multiplicities = [];\n\n    for (var λ of values) {\n      var i = indexOf(uniqueValues, λ, equal);\n\n      if (i === -1) {\n        uniqueValues.push(λ);\n        multiplicities.push(1);\n      } else {\n        multiplicities[i] += 1;\n      }\n    } // find eigenvectors by solving U − λE = 0\n    // TODO replace with an iterative eigenvector algorithm\n    // (this one might fail for imprecise eigenvalues)\n\n\n    var vectors = [];\n    var len = uniqueValues.length;\n    var b = Array(N).fill(zero);\n    var E = diag(Array(N).fill(one)); // eigenvalues for which usolve failed (due to numerical error)\n\n    var failedLambdas = [];\n\n    var _loop = function _loop(_i4) {\n      var λ = uniqueValues[_i4];\n      var S = subtract(U, multiply(λ, E)); // the characteristic matrix\n\n      var solutions = usolveAll(S, b);\n      solutions.shift(); // ignore the null vector\n      // looks like we missed something, try inverse iteration\n\n      while (solutions.length < multiplicities[_i4]) {\n        var approxVec = inverseIterate(S, N, solutions, prec, type);\n\n        if (approxVec == null) {\n          // no more vectors were found\n          failedLambdas.push(λ);\n          break;\n        }\n\n        solutions.push(approxVec);\n      } // Transform back into original array coordinates\n\n\n      var correction = multiply(inv(R), C);\n      solutions = solutions.map(v => multiply(correction, v));\n      vectors.push(...solutions.map(v => flatten(v)));\n    };\n\n    for (var _i4 = 0; _i4 < len; _i4++) {\n      _loop(_i4);\n    }\n\n    if (failedLambdas.length !== 0) {\n      var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));\n      err.values = values;\n      err.vectors = vectors;\n      throw err;\n    }\n\n    return vectors;\n  }\n  /**\n   * Compute the eigenvalues of an 2x2 matrix\n   * @return {[number,number]}\n   */\n\n\n  function eigenvalues2x2(a, b, c, d) {\n    // λ± = ½ trA ± ½ √( tr²A - 4 detA )\n    var trA = addScalar(a, d);\n    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));\n    var x = multiplyScalar(trA, 0.5);\n    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);\n    return [addScalar(x, y), subtract(x, y)];\n  }\n  /**\n   * For an 2x2 matrix compute the transformation matrix S,\n   * so that SAS⁻¹ is an upper triangular matrix\n   * @return {[[number,number],[number,number]]}\n   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf\n   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n   */\n\n\n  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // matrix is already upper triangular\n    // return an identity matrix\n\n    if (smaller(abs(c), prec)) {\n      return [[one, zero], [zero, one]];\n    } // matrix is diagonalizable\n    // return its eigenvectors as columns\n\n\n    if (larger(abs(subtract(l1, l2)), prec)) {\n      return [[subtract(l1, d), subtract(l2, d)], [c, c]];\n    } // matrix is not diagonalizable\n    // compute off-diagonal elements of N = A - λI\n    // N₁₂ = 0 ⇒ S = ( N⃗₁, I⃗₁ )\n    // N₁₂ ≠ 0 ⇒ S = ( N⃗₂, I⃗₂ )\n\n\n    var na = subtract(a, l1);\n    var nb = subtract(b, l1);\n    var nc = subtract(c, l1);\n    var nd = subtract(d, l1);\n\n    if (smaller(abs(nb), prec)) {\n      return [[na, one], [nc, zero]];\n    } else {\n      return [[nb, zero], [nd, one]];\n    }\n  }\n  /**\n   * Enlarge the matrix from n×n to N×N, setting the new\n   * elements to 1 on diagonal and 0 elsewhere\n   */\n\n\n  function inflateMatrix(arr, N) {\n    // add columns\n    for (var i = 0; i < arr.length; i++) {\n      arr[i].push(...Array(N - arr[i].length).fill(0));\n    } // add rows\n\n\n    for (var _i5 = arr.length; _i5 < N; _i5++) {\n      arr.push(Array(N).fill(0));\n      arr[_i5][_i5] = 1;\n    }\n\n    return arr;\n  }\n  /**\n   * Create a block-diagonal matrix with the given square matrices on the diagonal\n   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal\n   * @param {number} N the size of the resulting matrix\n   */\n\n\n  function blockDiag(arr, N) {\n    var M = [];\n\n    for (var i = 0; i < N; i++) {\n      M[i] = Array(N).fill(0);\n    }\n\n    var I = 0;\n\n    for (var sub of arr) {\n      var n = sub.length;\n\n      for (var _i6 = 0; _i6 < n; _i6++) {\n        for (var j = 0; j < n; j++) {\n          M[I + _i6][I + j] = sub[_i6][j];\n        }\n      }\n\n      I += n;\n    }\n\n    return M;\n  }\n  /**\n   * Finds the index of an element in an array using a custom equality function\n   * @template T\n   * @param {Array<T>} arr array in which to search\n   * @param {T} el the element to find\n   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`\n   * @returns {number} the index of `el`, or -1 when it's not in `arr`\n   */\n\n\n  function indexOf(arr, el, fn) {\n    for (var i = 0; i < arr.length; i++) {\n      if (fn(arr[i], el)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Provided a near-singular upper-triangular matrix A and a list of vectors,\n   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal\n   * to each vector in the list\n   * @template T\n   * @param {T[][]} A near-singular square matrix\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {number} prec epsilon\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @return {T[] | null} eigenvector\n   *\n   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration\n   */\n\n\n  function inverseIterate(A, N, orthog, prec, type) {\n    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;\n    var b; // the vector\n    // you better choose a random vector before I count to five\n\n    var i = 0;\n\n    while (true) {\n      b = randomOrthogonalVector(N, orthog, type);\n      b = usolve(A, b);\n\n      if (larger(norm(b), largeNum)) {\n        break;\n      }\n\n      if (++i >= 5) {\n        return null;\n      }\n    } // you better converge before I count to ten\n\n\n    i = 0;\n\n    while (true) {\n      var c = usolve(A, b);\n\n      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {\n        break;\n      }\n\n      if (++i >= 10) {\n        return null;\n      }\n\n      b = normalize(c);\n    }\n\n    return b;\n  }\n  /**\n   * Generates a random unit vector of dimension N, orthogonal to each vector in the list\n   * @template T\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} random vector\n   */\n\n\n  function randomOrthogonalVector(N, orthog, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex'; // generate random vector with the correct type\n\n    var v = Array(N).fill(0).map(_ => 2 * Math.random() - 1);\n\n    if (big) {\n      v = v.map(n => bignumber(n));\n    }\n\n    if (cplx) {\n      v = v.map(n => complex(n));\n    } // project to orthogonal complement\n\n\n    v = orthogonalComplement(v, orthog); // normalize\n\n    return normalize(v, type);\n  }\n  /**\n   * Project vector v to the orthogonal complement of an array of vectors\n   */\n\n\n  function orthogonalComplement(v, orthog) {\n    for (var w of orthog) {\n      // v := v − (w, v)/∥w∥² w\n      v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));\n    }\n\n    return v;\n  }\n  /**\n   * Calculate the norm of a vector.\n   * We can't use math.norm because factory can't handle circular dependency.\n   * Seriously, I'm really fed up with factory.\n   */\n\n\n  function norm(v) {\n    return abs(sqrt(dot(v, v)));\n  }\n  /**\n   * Normalize a vector\n   * @template T\n   * @param {T[]} v\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} normalized vec\n   */\n\n\n  function normalize(v, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    return multiply(divideScalar(one, norm(v)), v);\n  }\n\n  return complexEigs;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}