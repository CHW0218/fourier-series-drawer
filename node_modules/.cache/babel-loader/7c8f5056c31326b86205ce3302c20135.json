{"ast":null,"code":"/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n})(this, function () {\n  function ok() {\n    return true;\n  }\n\n  function notOk() {\n    return false;\n  }\n\n  function undef() {\n    return undefined;\n  }\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n  // create a new instance of typed-function\n\n\n  function create() {\n    // data type tests\n    var _types = [{\n      name: 'number',\n      test: function test(x) {\n        return typeof x === 'number';\n      }\n    }, {\n      name: 'string',\n      test: function test(x) {\n        return typeof x === 'string';\n      }\n    }, {\n      name: 'boolean',\n      test: function test(x) {\n        return typeof x === 'boolean';\n      }\n    }, {\n      name: 'Function',\n      test: function test(x) {\n        return typeof x === 'function';\n      }\n    }, {\n      name: 'Array',\n      test: Array.isArray\n    }, {\n      name: 'Date',\n      test: function test(x) {\n        return x instanceof Date;\n      }\n    }, {\n      name: 'RegExp',\n      test: function test(x) {\n        return x instanceof RegExp;\n      }\n    }, {\n      name: 'Object',\n      test: function test(x) {\n        return typeof x === 'object' && x !== null && x.constructor === Object;\n      }\n    }, {\n      name: 'null',\n      test: function test(x) {\n        return x === null;\n      }\n    }, {\n      name: 'undefined',\n      test: function test(x) {\n        return x === undefined;\n      }\n    }];\n    var anyType = {\n      name: 'any',\n      test: ok\n    }; // types which need to be ignored\n\n    var _ignore = []; // type conversions\n\n    var _conversions = []; // This is a temporary object, will be replaced with a typed function at the end\n\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n\n    function findTypeByName(typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n\n      if (entry) {\n        return entry;\n      }\n\n      if (typeName === 'any') {\n        // special baked-in case 'any'\n        return anyType;\n      }\n\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n      throw new TypeError('Unknown type \"' + typeName + '\"' + (hint ? '. Did you mean \"' + hint.name + '\"?' : ''));\n    }\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n\n\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n\n      return typed.types.indexOf(type);\n    }\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n\n\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n\n      if (entry) {\n        return entry.name;\n      }\n\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n\n\n    function find(fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      } // normalize input\n\n\n      var arr;\n\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      } else if (Array.isArray(signature)) {\n        arr = signature;\n      } else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n\n      var str = arr.join(','); // find an exact match\n\n      var match = fn.signatures[str];\n\n      if (match) {\n        return match;\n      } // TODO: extend find to match non-exact signatures\n\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n\n\n    function convert(value, type) {\n      var from = findTypeName(value); // check conversion is needed\n\n      if (type === from) {\n        return value;\n      }\n\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n\n\n    function stringifyParams(params) {\n      return params.map(function (param) {\n        var typeNames = param.types.map(getTypeName);\n        return (param.restParam ? '...' : '') + typeNames.join('|');\n      }).join(',');\n    }\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n\n\n    function parseParam(param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = !restParam ? param : param.length > 3 ? param.slice(3) : 'any';\n      var typeNames = types.split('|').map(trim).filter(notEmpty).filter(notIgnore);\n      var matchingConversions = filterConversions(conversions, typeNames);\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n\n\n    function parseSignature(signature, fn, conversions) {\n      var params = [];\n\n      if (signature.trim() !== '') {\n        params = signature.split(',').map(trim).map(function (param, index, array) {\n          var parsedParam = parseParam(param, conversions);\n\n          if (parsedParam.restParam && index !== array.length - 1) {\n            throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' + 'only allowed for the last parameter');\n          }\n\n          return parsedParam;\n        });\n      }\n\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n\n\n    function hasRestParam(params) {\n      var param = last(params);\n      return param ? param.restParam : false;\n    }\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n\n\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n\n\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      } else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      } else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        };\n      } else {\n        // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        });\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n\n          return false;\n        };\n      }\n    }\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n\n\n    function compileTests(params) {\n      var tests, test0, test1;\n\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n\n        var testRestParam = function testRestParam(args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n\n          return true;\n        };\n\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n\n          return testRestParam(args) && args.length >= varIndex + 1;\n        };\n      } else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        } else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        } else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        } else {\n          // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n\n\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length ? signature.params[index] : hasRestParam(signature.params) ? last(signature.params) : null;\n    }\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n\n\n    function getExpectedTypeNames(signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param ? excludeConversions ? param.types.filter(isExactType) : param.types : [];\n      return types.map(getTypeName);\n    }\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n\n\n    function getTypeName(type) {\n      return type.name;\n    }\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n\n\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n\n\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n      return typeNames.indexOf('any') !== -1 ? ['any'] : typeNames;\n    }\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n\n\n    function createError(name, args, signatures) {\n      var err, expected;\n\n      var _name = name || 'unnamed'; // test for wrong type at some index\n\n\n      var matchingSignatures = signatures;\n      var index;\n\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) && test(args[index]);\n        });\n\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n            err = new TypeError('Unexpected type of argument in function ' + _name + ' (expected: ' + expected.join(' or ') + ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            };\n            return err;\n          }\n        } else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      } // test for too few arguments\n\n\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name + ' (expected: ' + expected.join(' or ') + ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        };\n        return err;\n      } // test for too many arguments\n\n\n      var maxLength = Math.max.apply(null, lengths);\n\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name + ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        };\n        return err;\n      }\n\n      err = new TypeError('Arguments of type \"' + args.join(', ') + '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      };\n      return err;\n    }\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n\n\n    function getLowestTypeIndex(param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n\n      return min;\n    }\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n\n\n    function getLowestConversionIndex(param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n\n      return min;\n    }\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n\n\n    function compareParams(param1, param2) {\n      var c; // compare having a rest parameter or not\n\n      c = param1.restParam - param2.restParam;\n\n      if (c !== 0) {\n        return c;\n      } // compare having conversions or not\n\n\n      c = hasConversions(param1) - hasConversions(param2);\n\n      if (c !== 0) {\n        return c;\n      } // compare the index of the types\n\n\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n\n      if (c !== 0) {\n        return c;\n      } // compare the index of any conversion\n\n\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n\n\n    function compareSignatures(signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c; // compare whether the params have conversions at all or not\n\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);\n\n      if (c !== 0) {\n        return c;\n      } // next compare whether the params have conversions one by one\n\n\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n\n        if (c !== 0) {\n          return c;\n        }\n      } // compare the types of the params one by one\n\n\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n\n        if (c !== 0) {\n          return c;\n        }\n      } // compare the number of params\n\n\n      return signature1.params.length - signature2.params.length;\n    }\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n\n\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 && typeNames.indexOf(conversion.to) !== -1 && !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n\n\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn; // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion);\n\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n\n          return fn.apply(this, args);\n        };\n      }\n\n      var fnPreprocess = fnConvert;\n\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n\n        fnPreprocess = function preprocessRestParams() {\n          return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        };\n      }\n\n      return fnPreprocess;\n    }\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n\n\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      }); // create optimized conversion functions depending on the number of conversions\n\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          };\n\n        case 1:\n          test0 = tests[0];\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg);\n            }\n\n            return arg;\n          };\n\n        case 2:\n          test0 = tests[0];\n          test1 = tests[1];\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg);\n            }\n\n            if (test1(arg)) {\n              return conversion1(arg);\n            }\n\n            return arg;\n          };\n\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n\n            return arg;\n          };\n      }\n    }\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n\n\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n      return signaturesMap;\n    }\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n\n\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index];\n          var filteredTypes = ignoreConversionTypes ? param.types.filter(isExactType) : param.types;\n          var typeGroups;\n\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType);\n            typeGroups = exactTypes.length < filteredTypes.length ? [exactTypes, filteredTypes] : [filteredTypes];\n          } else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type];\n            });\n          } // recurse over the groups with types\n\n\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n        } else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: typeIndex === params.length - 1 && hasRestParam(params)\n            };\n          });\n          return [splittedParams];\n        }\n      }\n\n      return _splitParams(params, 0, []);\n    }\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n\n\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n      return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;\n    }\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n\n\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      } // parse the signatures, and check for conflicts\n\n\n      var parsedSignatures = [];\n      Object.keys(signaturesMap).map(function (signature) {\n        return parseSignature(signature, signaturesMap[signature], typed.conversions);\n      }).filter(notNull).forEach(function (parsedSignature) {\n        // check whether this parameter conflicts with already parsed signatures\n        var conflictingSignature = findInArray(parsedSignatures, function (s) {\n          return hasConflictingParams(s, parsedSignature);\n        });\n\n        if (conflictingSignature) {\n          throw new TypeError('Conflicting signatures \"' + stringifyParams(conflictingSignature.params) + '\" and \"' + stringifyParams(parsedSignature.params) + '\".');\n        }\n\n        parsedSignatures.push(parsedSignature);\n      }); // split and filter the types of the signatures, and then order them\n\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n      signatures.sort(compareSignatures); // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5; // compile the tests\n\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk; // compile the functions\n\n      var fns = signatures.map(function (signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn);\n      });\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1; // simple and generic, but also slow\n\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(this, arguments);\n          }\n        }\n\n        return typed.onMismatch(name, arguments, signatures);\n      }; // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n\n\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) {\n          return fn0.apply(fn, arguments);\n        }\n\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) {\n          return fn1.apply(fn, arguments);\n        }\n\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) {\n          return fn2.apply(fn, arguments);\n        }\n\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) {\n          return fn3.apply(fn, arguments);\n        }\n\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) {\n          return fn4.apply(fn, arguments);\n        }\n\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) {\n          return fn5.apply(fn, arguments);\n        }\n\n        return generic.apply(fn, arguments);\n      }; // attach name the typed function\n\n\n      try {\n        Object.defineProperty(fn, 'name', {\n          value: name\n        });\n      } catch (err) {// old browsers do not support Object.defineProperty and some don't support setting the name property\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\n        // so it's fine to have unnamed functions.\n      } // attach signatures to the function\n\n\n      fn.signatures = createSignaturesMap(signatures);\n      return fn;\n    }\n    /**\n     * Action to take on mismatch\n     * @param {string} name      Name of function that was attempted to be called\n     * @param {Array} args       Actual arguments to the call\n     * @param {Array} signatures Known signatures of the named typed-function\n     */\n\n\n    function _onMismatch(name, args, signatures) {\n      throw createError(name, args, signatures);\n    }\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n\n\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n\n\n    function trim(str) {\n      return str.trim();\n    }\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n\n\n    function notEmpty(str) {\n      return !!str;\n    }\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n\n\n    function notNull(value) {\n      return value !== null;\n    }\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n\n\n    function isInvalidParam(param) {\n      return param.types.length === 0;\n    }\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n\n\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n\n\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n\n\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n\n\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n\n\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n\n\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n\n\n    function uniq(arr) {\n      var entries = {};\n\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n\n      return Object.keys(entries);\n    }\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n\n\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n\n\n    function getName(fns) {\n      var name = '';\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i]; // check whether the names are the same when defined\n\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          } else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n\n      return name;\n    } // extract and merge all signatures of a list with typed functions\n\n\n    function extractSignatures(fns) {\n      var err;\n      var signaturesMap = {};\n\n      function validateUnique(_signature, _fn) {\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\n          err = new Error('Signature \"' + _signature + '\" is defined twice');\n          err.data = {\n            signature: _signature\n          };\n          throw err; // else: both signatures point to the same function, that's fine\n        }\n      }\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i]; // test whether this is a typed-function\n\n        if (typeof fn.signatures === 'object') {\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              validateUnique(signature, fn.signatures[signature]);\n              signaturesMap[signature] = fn.signatures[signature];\n            }\n          }\n        } else if (typeof fn.signature === 'string') {\n          validateUnique(fn.signature, fn);\n          signaturesMap[fn.signature] = fn;\n        } else {\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\n          err.data = {\n            index: i\n          };\n          throw err;\n        }\n      }\n\n      return signaturesMap;\n    }\n\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function Object(signaturesMap) {\n        // find existing name\n        var fns = [];\n\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function Function(fns) {\n        return createTypedFunction(getName(fns), extractSignatures(fns));\n      },\n      'string, ...Function': function stringFunction(name, fns) {\n        return createTypedFunction(name, extractSignatures(fns));\n      }\n    });\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.onMismatch = _onMismatch;\n    typed.throwMismatchError = _onMismatch;\n    typed.createError = createError;\n    typed.convert = convert;\n    typed.find = find;\n    /**\n     * add a type\n     * @param {{name: string, test: function}} type\n     * @param {boolean} [beforeObjectTest=true]\n     *                          If true, the new test will be inserted before\n     *                          the test with name 'Object' (if any), since\n     *                          tests for Object match Array and classes too.\n     */\n\n    typed.addType = function (type, beforeObjectTest) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      if (beforeObjectTest !== false) {\n        for (var i = 0; i < typed.types.length; i++) {\n          if (typed.types[i].name === 'Object') {\n            typed.types.splice(i, 0, type);\n            return;\n          }\n        }\n      }\n\n      typed.types.push(type);\n    }; // add a conversion\n\n\n    typed.addConversion = function (conversion) {\n      if (!conversion || typeof conversion.from !== 'string' || typeof conversion.to !== 'string' || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n\n      typed.conversions.push(conversion);\n    };\n\n    return typed;\n  }\n\n  return create();\n});","map":{"version":3,"names":["root","factory","define","amd","exports","module","typed","ok","notOk","undef","undefined","create","_types","name","test","x","Array","isArray","Date","RegExp","constructor","Object","anyType","_ignore","_conversions","types","conversions","ignore","findTypeByName","typeName","entry","findInArray","hint","toLowerCase","TypeError","findTypeIndex","type","indexOf","findTypeName","value","find","fn","signature","signatures","arr","split","i","length","trim","str","join","match","convert","from","conversion","to","Error","stringifyParams","params","map","param","typeNames","getTypeName","restParam","parseParam","slice","filter","notEmpty","notIgnore","matchingConversions","filterConversions","exactTypes","typeIndex","conversionIndex","convertibleTypes","concat","parseSignature","index","array","parsedParam","SyntaxError","some","isInvalidParam","hasRestParam","last","hasConversions","compileTest","test0","test1","or","tests","compileTests","initial","varIndex","lastTest","testRestParam","args","testArgs","getParamAtIndex","getExpectedTypeNames","excludeConversions","isExactType","mergeExpectedParams","uniq","flatMap","createError","err","expected","_name","matchingSignatures","nextMatchingDefs","actualType","data","category","actual","lengths","Infinity","Math","min","apply","maxLength","max","expectedLength","getLowestTypeIndex","getLowestConversionIndex","compareParams","param1","param2","c","compareSignatures","signature1","signature2","len","matches","forEach","keys","compileArgsPreprocessing","fnConvert","compiledConversions","compileArgConversion","convertArgs","arguments","fnPreprocess","offset","preprocessRestParams","conversion0","conversion1","push","convertArg","arg","createSignaturesMap","signaturesMap","splitParams","ignoreConversionTypes","_splitParams","filteredTypes","typeGroups","typeGroup","splittedParams","hasConflictingParams","ii","typesNames1","typesNames2","hasOverlap","len1","len2","restParam1","restParam2","createTypedFunction","parsedSignatures","notNull","parsedSignature","conflictingSignature","s","sort","ok0","ok1","ok2","ok3","ok4","ok5","allOk","test00","test10","test20","test30","test40","test50","test01","test11","test21","test31","test41","test51","fns","fn0","fn1","fn2","fn3","fn4","fn5","len0","len3","len4","len5","iStart","iEnd","generic","onMismatch","arg0","arg1","defineProperty","_onMismatch","start","end","prototype","call","contains","item","array1","array2","entries","callback","getName","extractSignatures","validateUnique","_signature","_fn","hasOwnProperty","throwMismatchError","addType","beforeObjectTest","splice","addConversion"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/typed-function/typed-function.js"],"sourcesContent":["/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n}(this, function () {\n\n  function ok () {\n    return true;\n  }\n\n  function notOk () {\n    return false;\n  }\n\n  function undef () {\n    return undefined;\n  }\n\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n\n  // create a new instance of typed-function\n  function create () {\n    // data type tests\n    var _types = [\n      { name: 'number',    test: function (x) { return typeof x === 'number' } },\n      { name: 'string',    test: function (x) { return typeof x === 'string' } },\n      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },\n      { name: 'Function',  test: function (x) { return typeof x === 'function'} },\n      { name: 'Array',     test: Array.isArray },\n      { name: 'Date',      test: function (x) { return x instanceof Date } },\n      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },\n      { name: 'Object',    test: function (x) {\n        return typeof x === 'object' && x !== null && x.constructor === Object\n      }},\n      { name: 'null',      test: function (x) { return x === null } },\n      { name: 'undefined', test: function (x) { return x === undefined } }\n    ];\n\n    var anyType = {\n      name: 'any',\n      test: ok\n    }\n\n    // types which need to be ignored\n    var _ignore = [];\n\n    // type conversions\n    var _conversions = [];\n\n    // This is a temporary object, will be replaced with a typed function at the end\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n    function findTypeByName (typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n\n      if (entry) {\n        return entry;\n      }\n\n      if (typeName === 'any') { // special baked-in case 'any'\n        return anyType;\n      }\n\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n\n      throw new TypeError('Unknown type \"' + typeName + '\"' +\n          (hint ? ('. Did you mean \"' + hint.name + '\"?') : ''));\n    }\n\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n\n      return typed.types.indexOf(type);\n    }\n\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n\n      if (entry) {\n        return entry.name;\n      }\n\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n    function find (fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      }\n\n      // normalize input\n      var arr;\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      }\n      else if (Array.isArray(signature)) {\n        arr = signature;\n      }\n      else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n\n      var str = arr.join(',');\n\n      // find an exact match\n      var match = fn.signatures[str];\n      if (match) {\n        return match;\n      }\n\n      // TODO: extend find to match non-exact signatures\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n    function convert (value, type) {\n      var from = findTypeName(value);\n\n      // check conversion is needed\n      if (type === from) {\n        return value;\n      }\n\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n    \n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n    function stringifyParams (params) {\n      return params\n          .map(function (param) {\n            var typeNames = param.types.map(getTypeName);\n\n            return (param.restParam ? '...' : '') + typeNames.join('|');\n          })\n          .join(',');\n    }\n\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n    function parseParam (param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = (!restParam)\n          ? param\n          : (param.length > 3)\n              ? param.slice(3)\n              : 'any';\n\n      var typeNames = types.split('|').map(trim)\n          .filter(notEmpty)\n          .filter(notIgnore);\n\n      var matchingConversions = filterConversions(conversions, typeNames);\n\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n    function parseSignature (signature, fn, conversions) {\n      var params = [];\n\n      if (signature.trim() !== '') {\n        params = signature\n            .split(',')\n            .map(trim)\n            .map(function (param, index, array) {\n              var parsedParam = parseParam(param, conversions);\n\n              if (parsedParam.restParam && (index !== array.length - 1)) {\n                throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' +\n                    'only allowed for the last parameter');\n              }\n\n              return parsedParam;\n          });\n      }\n\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n    function hasRestParam(params) {\n      var param = last(params)\n      return param ? param.restParam : false;\n    }\n\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      }\n      else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      }\n      else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        }\n      }\n      else { // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        })\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n    function compileTests(params) {\n      var tests, test0, test1;\n\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n        var testRestParam = function (args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n          return testRestParam(args) && (args.length >= varIndex + 1);\n        };\n      }\n      else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        }\n        else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        }\n        else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        }\n        else { // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length\n          ? signature.params[index]\n          : hasRestParam(signature.params)\n              ? last(signature.params)\n              : null\n    }\n\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n    function getExpectedTypeNames (signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param\n          ? excludeConversions\n                  ? param.types.filter(isExactType)\n                  : param.types\n          : [];\n\n      return types.map(getTypeName);\n    }\n\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n    function getTypeName(type) {\n      return type.name;\n    }\n\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n\n      return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;\n    }\n\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n    function createError(name, args, signatures) {\n      var err, expected;\n      var _name = name || 'unnamed';\n\n      // test for wrong type at some index\n      var matchingSignatures = signatures;\n      var index;\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) &&\n              test(args[index]);\n        });\n\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n\n            err = new TypeError('Unexpected type of argument in function ' + _name +\n                ' (expected: ' + expected.join(' or ') +\n                ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            }\n            return err;\n          }\n        }\n        else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      }\n\n      // test for too few arguments\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name +\n            ' (expected: ' + expected.join(' or ') +\n            ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        }\n        return err;\n      }\n\n      // test for too many arguments\n      var maxLength = Math.max.apply(null, lengths);\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name +\n            ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        }\n        return err;\n      }\n\n      err = new TypeError('Arguments of type \"' + args.join(', ') +\n          '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      }\n      return err;\n    }\n\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n    function getLowestTypeIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n    function getLowestConversionIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareParams (param1, param2) {\n      var c;\n\n      // compare having a rest parameter or not\n      c = param1.restParam - param2.restParam;\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare having conversions or not\n      c = hasConversions(param1) - hasConversions(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of the types\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of any conversion\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareSignatures (signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c;\n\n      // compare whether the params have conversions at all or not\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions)\n      if (c !== 0) {\n        return c;\n      }\n\n      // next compare whether the params have conversions one by one\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the types of the params one by one\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the number of params\n      return signature1.params.length - signature2.params.length;\n    }\n\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 &&\n            typeNames.indexOf(conversion.to) !== -1 &&\n            !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn;\n\n      // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion)\n\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n\n          return fn.apply(this, args);\n        }\n      }\n\n      var fnPreprocess = fnConvert;\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n\n        fnPreprocess = function preprocessRestParams () {\n          return fnConvert.apply(this,\n              slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        }\n      }\n\n      return fnPreprocess;\n    }\n\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      });\n\n      // create optimized conversion functions depending on the number of conversions\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          }\n\n        case 1:\n          test0 = tests[0]\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            return arg;\n          }\n\n        case 2:\n          test0 = tests[0]\n          test1 = tests[1]\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            if (test1(arg)) {\n              return conversion1(arg)\n            }\n            return arg;\n          }\n\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n            return arg;\n          }\n      }\n    }\n\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n\n      return signaturesMap;\n    }\n\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index]\n          var filteredTypes = ignoreConversionTypes\n              ? param.types.filter(isExactType)\n              : param.types;\n          var typeGroups\n\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType)\n            typeGroups = exactTypes.length < filteredTypes.length\n                ? [exactTypes, filteredTypes]\n                : [filteredTypes]\n\n          }\n          else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type]\n            })\n          }\n\n          // recurse over the groups with types\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n\n        }\n        else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: (typeIndex === params.length - 1) && hasRestParam(params)\n            }\n          });\n\n          return [splittedParams];\n        }\n      }\n\n      return _splitParams(params, 0, []);\n    }\n\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n\n      return restParam1\n          ? restParam2 ? (len1 === len2) : (len2 >= len1)\n          : restParam2 ? (len1 >= len2)  : (len1 === len2)\n    }\n\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      }\n\n      // parse the signatures, and check for conflicts\n      var parsedSignatures = [];\n      Object.keys(signaturesMap)\n          .map(function (signature) {\n            return parseSignature(signature, signaturesMap[signature], typed.conversions);\n          })\n          .filter(notNull)\n          .forEach(function (parsedSignature) {\n            // check whether this parameter conflicts with already parsed signatures\n            var conflictingSignature = findInArray(parsedSignatures, function (s) {\n              return hasConflictingParams(s, parsedSignature)\n            });\n            if (conflictingSignature) {\n              throw new TypeError('Conflicting signatures \"' +\n                  stringifyParams(conflictingSignature.params) + '\" and \"' +\n                  stringifyParams(parsedSignature.params) + '\".');\n            }\n\n            parsedSignatures.push(parsedSignature);\n          });\n\n      // split and filter the types of the signatures, and then order them\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : []\n\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n\n      signatures.sort(compareSignatures);\n\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\n\n      // compile the tests\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\n\n      // compile the functions\n      var fns = signatures.map(function(signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn);\n      });\n\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1;\n\n      // simple and generic, but also slow\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(this, arguments);\n          }\n        }\n\n        return typed.onMismatch(name, arguments, signatures);\n      }\n\n      // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(fn, arguments); }\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(fn, arguments); }\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(fn, arguments); }\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(fn, arguments); }\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(fn, arguments); }\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(fn, arguments); }\n\n        return generic.apply(fn, arguments);\n      }\n\n      // attach name the typed function\n      try {\n        Object.defineProperty(fn, 'name', {value: name});\n      }\n      catch (err) {\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\n        // so it's fine to have unnamed functions.\n      }\n\n      // attach signatures to the function\n      fn.signatures = createSignaturesMap(signatures);\n\n      return fn;\n    }\n\n    /**\n     * Action to take on mismatch\n     * @param {string} name      Name of function that was attempted to be called\n     * @param {Array} args       Actual arguments to the call\n     * @param {Array} signatures Known signatures of the named typed-function\n     */\n    function _onMismatch(name, args, signatures) {\n      throw createError(name, args, signatures);\n    }\n\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n    function trim(str) {\n      return str.trim();\n    }\n\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n    function notEmpty(str) {\n      return !!str;\n    }\n\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n    function notNull(value) {\n      return value !== null;\n    }\n\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n    function isInvalidParam (param) {\n      return param.types.length === 0;\n    }\n\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n    function uniq(arr) {\n      var entries = {}\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n      return Object.keys(entries);\n    }\n\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n    function getName (fns) {\n      var name = '';\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // check whether the names are the same when defined\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          }\n          else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n\n      return name;\n    }\n\n    // extract and merge all signatures of a list with typed functions\n    function extractSignatures(fns) {\n      var err;\n      var signaturesMap = {};\n\n      function validateUnique(_signature, _fn) {\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\n          err = new Error('Signature \"' + _signature + '\" is defined twice');\n          err.data = {signature: _signature};\n          throw err;\n          // else: both signatures point to the same function, that's fine\n        }\n      }\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // test whether this is a typed-function\n        if (typeof fn.signatures === 'object') {\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              validateUnique(signature, fn.signatures[signature]);\n              signaturesMap[signature] = fn.signatures[signature];\n            }\n          }\n        }\n        else if (typeof fn.signature === 'string') {\n          validateUnique(fn.signature, fn);\n          signaturesMap[fn.signature] = fn;\n        }\n        else {\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\n          err.data = {index: i};\n          throw err;\n        }\n      }\n\n      return signaturesMap;\n    }\n\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function (signaturesMap) {\n        // find existing name\n        var fns = [];\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function (fns) {\n        return createTypedFunction(getName(fns), extractSignatures(fns));\n      },\n      'string, ...Function': function (name, fns) {\n        return createTypedFunction(name, extractSignatures(fns));\n      }\n    });\n\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.onMismatch = _onMismatch;\n    typed.throwMismatchError = _onMismatch;\n    typed.createError = createError;\n    typed.convert = convert;\n    typed.find = find;\n\n    /**\n     * add a type\n     * @param {{name: string, test: function}} type\n     * @param {boolean} [beforeObjectTest=true]\n     *                          If true, the new test will be inserted before\n     *                          the test with name 'Object' (if any), since\n     *                          tests for Object match Array and classes too.\n     */\n    typed.addType = function (type, beforeObjectTest) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      if (beforeObjectTest !== false) {\n        for (var i = 0; i < typed.types.length; i++) {\n          if (typed.types[i].name === 'Object') {\n            typed.types.splice(i, 0, type);\n            return\n          }\n        }\n      }\n\n      typed.types.push(type);\n    };\n\n    // add a conversion\n    typed.addConversion = function (conversion) {\n      if (!conversion\n          || typeof conversion.from !== 'string'\n          || typeof conversion.to !== 'string'\n          || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n\n      typed.conversions.push(conversion);\n    };\n\n    return typed;\n  }\n\n  return create();\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}