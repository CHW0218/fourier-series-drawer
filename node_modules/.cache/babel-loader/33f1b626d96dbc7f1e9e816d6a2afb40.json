{"ast":null,"code":"import { isChain } from '../../utils/is.js';\nimport { format } from '../../utils/string.js';\nimport { hasOwnProperty, lazy } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'Chain';\nvar dependencies = ['?on', 'math'];\nexport var createChainClass = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var on = _ref.on,\n      math = _ref.math;\n  /**\n   * @constructor Chain\n   * Wrap any value in a chain, allowing to perform chained operations on\n   * the value.\n   *\n   * All methods available in the math.js library can be called upon the chain,\n   * and then will be evaluated with the value itself as first argument.\n   * The chain can be closed by executing chain.done(), which will return\n   * the final value.\n   *\n   * The Chain has a number of special functions:\n   * - done()             Finalize the chained operation and return the\n   *                      chain's value.\n   * - valueOf()          The same as done()\n   * - toString()         Returns a string representation of the chain's value.\n   *\n   * @param {*} [value]\n   */\n\n  function Chain(value) {\n    if (!(this instanceof Chain)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (isChain(value)) {\n      this.value = value.value;\n    } else {\n      this.value = value;\n    }\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Chain.prototype.type = 'Chain';\n  Chain.prototype.isChain = true;\n  /**\n   * Close the chain. Returns the final value.\n   * Does the same as method valueOf()\n   * @returns {*} value\n   */\n\n  Chain.prototype.done = function () {\n    return this.value;\n  };\n  /**\n   * Close the chain. Returns the final value.\n   * Does the same as method done()\n   * @returns {*} value\n   */\n\n\n  Chain.prototype.valueOf = function () {\n    return this.value;\n  };\n  /**\n   * Get a string representation of the value in the chain\n   * @returns {string}\n   */\n\n\n  Chain.prototype.toString = function () {\n    return format(this.value);\n  };\n  /**\n   * Get a JSON representation of the chain\n   * @returns {Object}\n   */\n\n\n  Chain.prototype.toJSON = function () {\n    return {\n      mathjs: 'Chain',\n      value: this.value\n    };\n  };\n  /**\n   * Instantiate a Chain from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"Chain\", value: ...}`,\n   *                       where mathjs is optional\n   * @returns {Chain}\n   */\n\n\n  Chain.fromJSON = function (json) {\n    return new Chain(json.value);\n  };\n  /**\n   * Create a proxy method for the chain\n   * @param {string} name\n   * @param {Function} fn      The function to be proxied\n   *                           If fn is no function, it is silently ignored.\n   * @private\n   */\n\n\n  function createProxy(name, fn) {\n    if (typeof fn === 'function') {\n      Chain.prototype[name] = chainify(fn);\n    }\n  }\n  /**\n   * Create a proxy method for the chain\n   * @param {string} name\n   * @param {function} resolver   The function resolving with the\n   *                              function to be proxied\n   * @private\n   */\n\n\n  function createLazyProxy(name, resolver) {\n    lazy(Chain.prototype, name, function outerResolver() {\n      var fn = resolver();\n\n      if (typeof fn === 'function') {\n        return chainify(fn);\n      }\n\n      return undefined; // if not a function, ignore\n    });\n  }\n  /**\n   * Make a function chainable\n   * @param {function} fn\n   * @return {Function} chain function\n   * @private\n   */\n\n\n  function chainify(fn) {\n    return function () {\n      var args = [this.value]; // `this` will be the context of a Chain instance\n\n      for (var i = 0; i < arguments.length; i++) {\n        args[i + 1] = arguments[i];\n      }\n\n      return new Chain(fn.apply(fn, args));\n    };\n  }\n  /**\n   * Create a proxy for a single method, or an object with multiple methods.\n   * Example usage:\n   *\n   *   Chain.createProxy('add', function add (x, y) {...})\n   *   Chain.createProxy({\n   *     add:      function add (x, y) {...},\n   *     subtract: function subtract (x, y) {...}\n   *   }\n   *\n   * @param {string | Object} arg0   A name (string), or an object with\n   *                                 functions\n   * @param {*} [arg1]               A function, when arg0 is a name\n   */\n\n\n  Chain.createProxy = function (arg0, arg1) {\n    if (typeof arg0 === 'string') {\n      // createProxy(name, value)\n      createProxy(arg0, arg1);\n    } else {\n      var _loop = function _loop(_name) {\n        if (hasOwnProperty(arg0, _name) && excludedNames[_name] === undefined) {\n          createLazyProxy(_name, function () {\n            return arg0[_name];\n          });\n        }\n      }; // createProxy(values)\n\n\n      for (var _name in arg0) {\n        _loop(_name);\n      }\n    }\n  };\n\n  var excludedNames = {\n    expression: true,\n    docs: true,\n    type: true,\n    classes: true,\n    json: true,\n    error: true,\n    isChain: true // conflicts with the property isChain of a Chain instance\n\n  }; // create proxy for everything that is in math.js\n\n  Chain.createProxy(math); // register on the import event, automatically add a proxy for every imported function.\n\n  if (on) {\n    on('import', function (name, resolver, path) {\n      if (!path) {\n        // an imported function (not a data type or something special)\n        createLazyProxy(name, resolver);\n      }\n    });\n  }\n\n  return Chain;\n}, {\n  isClass: true\n});","map":{"version":3,"names":["isChain","format","hasOwnProperty","lazy","factory","name","dependencies","createChainClass","_ref","on","math","Chain","value","SyntaxError","prototype","type","done","valueOf","toString","toJSON","mathjs","fromJSON","json","createProxy","fn","chainify","createLazyProxy","resolver","outerResolver","undefined","args","i","arguments","length","apply","arg0","arg1","_loop","_name","excludedNames","expression","docs","classes","error","path","isClass"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/type/chain/Chain.js"],"sourcesContent":["import { isChain } from '../../utils/is.js';\nimport { format } from '../../utils/string.js';\nimport { hasOwnProperty, lazy } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'Chain';\nvar dependencies = ['?on', 'math'];\nexport var createChainClass = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    on,\n    math\n  } = _ref;\n\n  /**\n   * @constructor Chain\n   * Wrap any value in a chain, allowing to perform chained operations on\n   * the value.\n   *\n   * All methods available in the math.js library can be called upon the chain,\n   * and then will be evaluated with the value itself as first argument.\n   * The chain can be closed by executing chain.done(), which will return\n   * the final value.\n   *\n   * The Chain has a number of special functions:\n   * - done()             Finalize the chained operation and return the\n   *                      chain's value.\n   * - valueOf()          The same as done()\n   * - toString()         Returns a string representation of the chain's value.\n   *\n   * @param {*} [value]\n   */\n  function Chain(value) {\n    if (!(this instanceof Chain)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (isChain(value)) {\n      this.value = value.value;\n    } else {\n      this.value = value;\n    }\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Chain.prototype.type = 'Chain';\n  Chain.prototype.isChain = true;\n  /**\n   * Close the chain. Returns the final value.\n   * Does the same as method valueOf()\n   * @returns {*} value\n   */\n\n  Chain.prototype.done = function () {\n    return this.value;\n  };\n  /**\n   * Close the chain. Returns the final value.\n   * Does the same as method done()\n   * @returns {*} value\n   */\n\n\n  Chain.prototype.valueOf = function () {\n    return this.value;\n  };\n  /**\n   * Get a string representation of the value in the chain\n   * @returns {string}\n   */\n\n\n  Chain.prototype.toString = function () {\n    return format(this.value);\n  };\n  /**\n   * Get a JSON representation of the chain\n   * @returns {Object}\n   */\n\n\n  Chain.prototype.toJSON = function () {\n    return {\n      mathjs: 'Chain',\n      value: this.value\n    };\n  };\n  /**\n   * Instantiate a Chain from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"Chain\", value: ...}`,\n   *                       where mathjs is optional\n   * @returns {Chain}\n   */\n\n\n  Chain.fromJSON = function (json) {\n    return new Chain(json.value);\n  };\n  /**\n   * Create a proxy method for the chain\n   * @param {string} name\n   * @param {Function} fn      The function to be proxied\n   *                           If fn is no function, it is silently ignored.\n   * @private\n   */\n\n\n  function createProxy(name, fn) {\n    if (typeof fn === 'function') {\n      Chain.prototype[name] = chainify(fn);\n    }\n  }\n  /**\n   * Create a proxy method for the chain\n   * @param {string} name\n   * @param {function} resolver   The function resolving with the\n   *                              function to be proxied\n   * @private\n   */\n\n\n  function createLazyProxy(name, resolver) {\n    lazy(Chain.prototype, name, function outerResolver() {\n      var fn = resolver();\n\n      if (typeof fn === 'function') {\n        return chainify(fn);\n      }\n\n      return undefined; // if not a function, ignore\n    });\n  }\n  /**\n   * Make a function chainable\n   * @param {function} fn\n   * @return {Function} chain function\n   * @private\n   */\n\n\n  function chainify(fn) {\n    return function () {\n      var args = [this.value]; // `this` will be the context of a Chain instance\n\n      for (var i = 0; i < arguments.length; i++) {\n        args[i + 1] = arguments[i];\n      }\n\n      return new Chain(fn.apply(fn, args));\n    };\n  }\n  /**\n   * Create a proxy for a single method, or an object with multiple methods.\n   * Example usage:\n   *\n   *   Chain.createProxy('add', function add (x, y) {...})\n   *   Chain.createProxy({\n   *     add:      function add (x, y) {...},\n   *     subtract: function subtract (x, y) {...}\n   *   }\n   *\n   * @param {string | Object} arg0   A name (string), or an object with\n   *                                 functions\n   * @param {*} [arg1]               A function, when arg0 is a name\n   */\n\n\n  Chain.createProxy = function (arg0, arg1) {\n    if (typeof arg0 === 'string') {\n      // createProxy(name, value)\n      createProxy(arg0, arg1);\n    } else {\n      var _loop = function _loop(_name) {\n        if (hasOwnProperty(arg0, _name) && excludedNames[_name] === undefined) {\n          createLazyProxy(_name, () => arg0[_name]);\n        }\n      };\n\n      // createProxy(values)\n      for (var _name in arg0) {\n        _loop(_name);\n      }\n    }\n  };\n\n  var excludedNames = {\n    expression: true,\n    docs: true,\n    type: true,\n    classes: true,\n    json: true,\n    error: true,\n    isChain: true // conflicts with the property isChain of a Chain instance\n\n  }; // create proxy for everything that is in math.js\n\n  Chain.createProxy(math); // register on the import event, automatically add a proxy for every imported function.\n\n  if (on) {\n    on('import', function (name, resolver, path) {\n      if (!path) {\n        // an imported function (not a data type or something special)\n        createLazyProxy(name, resolver);\n      }\n    });\n  }\n\n  return Chain;\n}, {\n  isClass: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}