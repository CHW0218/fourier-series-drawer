{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromFunction';\nvar dependencies = ['typed', 'matrix', 'isZero'];\nexport var createMatrixFromFunction = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      isZero = _ref.isZero;\n  /**\n   * Create a matrix by evaluating a generating function at each index.\n   * The simplest overload returns a multi-dimensional array as long as `size` is an array.\n   * Passing `size` as a Matrix or specifying a `format` will result in returning a Matrix.\n   *\n   * Syntax:\n   *\n   *    math.matrixFromFunction(size, fn)\n   *    math.matrixFromFunction(size, fn, format)\n   *    math.matrixFromFunction(size, fn, format, datatype)\n   *    math.matrixFromFunction(size, format, fn)\n   *    math.matrixFromFunction(size, format, datatype, fn)\n   *\n   * Examples:\n   *\n   *    math.matrixFromFunction([3,3], i => i[0] - i[1]) // an antisymmetric matrix\n   *    math.matrixFromFunction([100, 100], 'sparse', i => i[0] - i[1] === 1 ? 4 : 0) // a sparse subdiagonal matrix\n   *    math.matrixFromFunction([5], i => math.random()) // a random vector\n   *\n   * See also:\n   *\n   *    matrix, zeros\n   *\n   * @param {Array | Matrix} size   The size of the matrix to be created\n   * @param {function} fn           Callback function invoked for every entry in the matrix\n   * @param {string} [format]       The Matrix storage format, either `'dense'` or `'sparse'`\n   * @param {string} [datatype]     Type of the values\n   * @return {Array | Matrix} Returns the created matrix\n   */\n\n  return typed(name, {\n    'Array | Matrix, function, string, string': function ArrayMatrixFunctionStringString(size, fn, format, datatype) {\n      return _create(size, fn, format, datatype);\n    },\n    'Array | Matrix, function, string': function ArrayMatrixFunctionString(size, fn, format) {\n      return _create(size, fn, format);\n    },\n    'Matrix, function': function MatrixFunction(size, fn) {\n      return _create(size, fn, 'dense');\n    },\n    'Array, function': function ArrayFunction(size, fn) {\n      return _create(size, fn, 'dense').toArray();\n    },\n    'Array | Matrix, string, function': function ArrayMatrixStringFunction(size, format, fn) {\n      return _create(size, fn, format);\n    },\n    'Array | Matrix, string, string, function': function ArrayMatrixStringStringFunction(size, format, datatype, fn) {\n      return _create(size, fn, format, datatype);\n    }\n  });\n\n  function _create(size, fn, format, datatype) {\n    var m;\n\n    if (datatype !== undefined) {\n      m = matrix(format, datatype);\n    } else {\n      m = matrix(format);\n    }\n\n    m.resize(size);\n    m.forEach(function (_, index) {\n      var val = fn(index);\n      if (isZero(val)) return;\n      m.set(index, val);\n    });\n    return m;\n  }\n});","map":{"version":3,"names":["factory","name","dependencies","createMatrixFromFunction","_ref","typed","matrix","isZero","ArrayMatrixFunctionStringString","size","fn","format","datatype","_create","ArrayMatrixFunctionString","MatrixFunction","ArrayFunction","toArray","ArrayMatrixStringFunction","ArrayMatrixStringStringFunction","m","undefined","resize","forEach","_","index","val","set"],"sources":["/Users/ayao/vscode/fourier-series-drawer/node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromFunction';\nvar dependencies = ['typed', 'matrix', 'isZero'];\nexport var createMatrixFromFunction = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    isZero\n  } = _ref;\n\n  /**\n   * Create a matrix by evaluating a generating function at each index.\n   * The simplest overload returns a multi-dimensional array as long as `size` is an array.\n   * Passing `size` as a Matrix or specifying a `format` will result in returning a Matrix.\n   *\n   * Syntax:\n   *\n   *    math.matrixFromFunction(size, fn)\n   *    math.matrixFromFunction(size, fn, format)\n   *    math.matrixFromFunction(size, fn, format, datatype)\n   *    math.matrixFromFunction(size, format, fn)\n   *    math.matrixFromFunction(size, format, datatype, fn)\n   *\n   * Examples:\n   *\n   *    math.matrixFromFunction([3,3], i => i[0] - i[1]) // an antisymmetric matrix\n   *    math.matrixFromFunction([100, 100], 'sparse', i => i[0] - i[1] === 1 ? 4 : 0) // a sparse subdiagonal matrix\n   *    math.matrixFromFunction([5], i => math.random()) // a random vector\n   *\n   * See also:\n   *\n   *    matrix, zeros\n   *\n   * @param {Array | Matrix} size   The size of the matrix to be created\n   * @param {function} fn           Callback function invoked for every entry in the matrix\n   * @param {string} [format]       The Matrix storage format, either `'dense'` or `'sparse'`\n   * @param {string} [datatype]     Type of the values\n   * @return {Array | Matrix} Returns the created matrix\n   */\n  return typed(name, {\n    'Array | Matrix, function, string, string': function ArrayMatrixFunctionStringString(size, fn, format, datatype) {\n      return _create(size, fn, format, datatype);\n    },\n    'Array | Matrix, function, string': function ArrayMatrixFunctionString(size, fn, format) {\n      return _create(size, fn, format);\n    },\n    'Matrix, function': function MatrixFunction(size, fn) {\n      return _create(size, fn, 'dense');\n    },\n    'Array, function': function ArrayFunction(size, fn) {\n      return _create(size, fn, 'dense').toArray();\n    },\n    'Array | Matrix, string, function': function ArrayMatrixStringFunction(size, format, fn) {\n      return _create(size, fn, format);\n    },\n    'Array | Matrix, string, string, function': function ArrayMatrixStringStringFunction(size, format, datatype, fn) {\n      return _create(size, fn, format, datatype);\n    }\n  });\n\n  function _create(size, fn, format, datatype) {\n    var m;\n\n    if (datatype !== undefined) {\n      m = matrix(format, datatype);\n    } else {\n      m = matrix(format);\n    }\n\n    m.resize(size);\n    m.forEach(function (_, index) {\n      var val = fn(index);\n      if (isZero(val)) return;\n      m.set(index, val);\n    });\n    return m;\n  }\n});"],"mappings":"AAAA,SAASA,OAAT,QAAwB,wBAAxB;AACA,IAAIC,IAAI,GAAG,oBAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,QAAV,EAAoB,QAApB,CAAnB;AACA,OAAO,IAAIC,wBAAwB,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqB,UAAAE,IAAI,EAAI;EACvF,IACEC,KADF,GAIID,IAJJ,CACEC,KADF;EAAA,IAEEC,MAFF,GAIIF,IAJJ,CAEEE,MAFF;EAAA,IAGEC,MAHF,GAIIH,IAJJ,CAGEG,MAHF;EAMA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,OAAOF,KAAK,CAACJ,IAAD,EAAO;IACjB,4CAA4C,SAASO,+BAAT,CAAyCC,IAAzC,EAA+CC,EAA/C,EAAmDC,MAAnD,EAA2DC,QAA3D,EAAqE;MAC/G,OAAOC,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAWC,MAAX,EAAmBC,QAAnB,CAAd;IACD,CAHgB;IAIjB,oCAAoC,SAASE,yBAAT,CAAmCL,IAAnC,EAAyCC,EAAzC,EAA6CC,MAA7C,EAAqD;MACvF,OAAOE,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAWC,MAAX,CAAd;IACD,CANgB;IAOjB,oBAAoB,SAASI,cAAT,CAAwBN,IAAxB,EAA8BC,EAA9B,EAAkC;MACpD,OAAOG,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAW,OAAX,CAAd;IACD,CATgB;IAUjB,mBAAmB,SAASM,aAAT,CAAuBP,IAAvB,EAA6BC,EAA7B,EAAiC;MAClD,OAAOG,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAW,OAAX,CAAP,CAA2BO,OAA3B,EAAP;IACD,CAZgB;IAajB,oCAAoC,SAASC,yBAAT,CAAmCT,IAAnC,EAAyCE,MAAzC,EAAiDD,EAAjD,EAAqD;MACvF,OAAOG,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAWC,MAAX,CAAd;IACD,CAfgB;IAgBjB,4CAA4C,SAASQ,+BAAT,CAAyCV,IAAzC,EAA+CE,MAA/C,EAAuDC,QAAvD,EAAiEF,EAAjE,EAAqE;MAC/G,OAAOG,OAAO,CAACJ,IAAD,EAAOC,EAAP,EAAWC,MAAX,EAAmBC,QAAnB,CAAd;IACD;EAlBgB,CAAP,CAAZ;;EAqBA,SAASC,OAAT,CAAiBJ,IAAjB,EAAuBC,EAAvB,EAA2BC,MAA3B,EAAmCC,QAAnC,EAA6C;IAC3C,IAAIQ,CAAJ;;IAEA,IAAIR,QAAQ,KAAKS,SAAjB,EAA4B;MAC1BD,CAAC,GAAGd,MAAM,CAACK,MAAD,EAASC,QAAT,CAAV;IACD,CAFD,MAEO;MACLQ,CAAC,GAAGd,MAAM,CAACK,MAAD,CAAV;IACD;;IAEDS,CAAC,CAACE,MAAF,CAASb,IAAT;IACAW,CAAC,CAACG,OAAF,CAAU,UAAUC,CAAV,EAAaC,KAAb,EAAoB;MAC5B,IAAIC,GAAG,GAAGhB,EAAE,CAACe,KAAD,CAAZ;MACA,IAAIlB,MAAM,CAACmB,GAAD,CAAV,EAAiB;MACjBN,CAAC,CAACO,GAAF,CAAMF,KAAN,EAAaC,GAAb;IACD,CAJD;IAKA,OAAON,CAAP;EACD;AACF,CA1E2D,CAArD"},"metadata":{},"sourceType":"module"}